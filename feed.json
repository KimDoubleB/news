{
    "version": "https://jsonfeed.org/version/1",
    "title": "KimDoubleB",
    "home_page_url": "https://kimdoubleb.github.io/news/",
    "feed_url": "https://kimdoubleb.github.io/news/feed.json",
    "description": "Code never lies",
    "icon": "https://kimdoubleb.github.io/news/apple-touch-icon.png",
    "favicon": "https://kimdoubleb.github.io/news/favicon.ico",
    "expired": false,
    
    "author":  {
        "name": "KimDoubleB",
        "url": null,
        "avatar": null
    },
    
"items": [
    
        {
            "id": "https://kimdoubleb.github.io/news/2025/06/30/ai-personal-thinking",
            "title": "[생각] AI와 개발자의 성장/생산성 향상",
            "summary": null,
            "content_text": "최근 개발 과정에서 AI(특히 LLM) 사용은 거의 필수적인 것 같다.개발 생산성을 급격하게 올려주니 계속 사용을 하곤 있는데, 사용하면 할수록 개발을 하며 얻는 즐거움은 떨어지는 느낌이다.뭔가 빠져있는 느낌.관련해서 그냥 생각을 정리했다.AI 기술, 특히 고도화된 코딩 에이전트(Coding Agent)는 개발자의 장기적인 성장을 저해할 수 있다. 개발자의 성장은 본인의 생각으로 문제를 해결하고 코드를 구현하는 과정에서 느끼는 ‘성취감’을 핵심 동력으로 삼는다. 그런데 AI는 바로 이 성취감을 얻는 경험 자체를 위협하기에, 성장을 저해할 수 있는 것이다. 예를 들어, 초기 LLM은 모르는 것을 질문하고 배우는 ‘학습 도우미’ 역할을 했다. 하지만 Cursor와 같은 최신 코딩 에이전트는 몇 가지 요청만으로 완전한 기능의 코드를 생성해준다. 바로 이 지점에서 개발자는 “내가 코드를 ‘개발’한 것인가, 단순히 ‘요청’한 것인가?”라는 근본적인 의구심에 부딪히게 된다. 이러한 의구심은 개발자에게 ‘내가 해냈다’는 성취감을 주기 어려우며, 성장을 위한 동기부여 또한 약화시킬 수 있다. 이처럼 AI가 개발 과정의 핵심인 문제 해결 경험을 대신하게 되면서, 장기적으로 개발자의 성장 동력을 앗아갈 위험이 있다.하지만 개발자의 성장 문제와는 별개로, AI는 개발 생산성 향상에 매우 긍정적인 영향을 미친다. AI는 반복적이거나 정형화된 작업에 소요되는 개발자의 시간을 획기적으로 줄여, 더 중요한 문제에 집중할 수 있도록 돕기 때문이다. 가령, 프로젝트 초기 설정에 필요한 보일러플레이트 코드를 작성하거나, 패턴이 정해진 테스트 코드를 만드는 작업을 AI에게 맡길 수 있다. 또한 복잡한 레거시 코드를 분석하고 이해하는 시간도 크게 단축시킬 수 있다. 결론적으로 AI는 개발자가 핵심적인 문제 해결에 더 집중하도록 도와, 팀과 기업의 전체적인 생산성을 크게 높이는 강력한 도구임이 분명하다.AI가 가져오는 생산성 향상을 개발자 개인의 성장으로 착각해서는 안 된다. 빠른 결과물에 익숙해질수록 AI에 대한 의존성은 깊어질 수밖에 없다. 그리고 역설적이게도, AI 없이는 스스로 문제를 해결하기 어려운 개발자야말로 AI 기술 시대에 가장 먼저 대체될 수 있는 존재일 것이다. 따라서 우리는 AI를 적극적으로 활용하되, 끊임없이 자신의 성장 상태를 성찰해야 한다. 또한 의도적으로 AI에 의존하지 않고 기본기를 다지는 학습과 훈련을 반드시 병행할 필요가 있다.",
            "content_html": "<p>최근 개발 과정에서 AI(특히 LLM) 사용은 거의 필수적인 것 같다.개발 생산성을 급격하게 올려주니 계속 사용을 하곤 있는데, 사용하면 할수록 개발을 하며 얻는 즐거움은 떨어지는 느낌이다.뭔가 빠져있는 느낌.관련해서 그냥 생각을 정리했다.</p><hr /><p><br /></p><p><mark>AI 기술, 특히 고도화된 코딩 에이전트(Coding Agent)는 개발자의 장기적인 성장을 저해할 수 있다.</mark> 개발자의 성장은 본인의 생각으로 문제를 해결하고 코드를 구현하는 과정에서 느끼는 ‘성취감’을 핵심 동력으로 삼는다. 그런데 AI는 바로 이 성취감을 얻는 경험 자체를 위협하기에, 성장을 저해할 수 있는 것이다. 예를 들어, 초기 LLM은 모르는 것을 질문하고 배우는 ‘학습 도우미’ 역할을 했다. 하지만 Cursor와 같은 최신 코딩 에이전트는 몇 가지 요청만으로 완전한 기능의 코드를 생성해준다. 바로 이 지점에서 개발자는 <strong>“내가 코드를 ‘개발’한 것인가, 단순히 ‘요청’한 것인가?”라는 근본적인 의구심에 부딪히게 된다.</strong> 이러한 의구심은 개발자에게 ‘내가 해냈다’는 성취감을 주기 어려우며, 성장을 위한 동기부여 또한 약화시킬 수 있다. 이처럼 AI가 개발 과정의 핵심인 문제 해결 경험을 대신하게 되면서, 장기적으로 개발자의 성장 동력을 앗아갈 위험이 있다.</p><p><mark>하지만 개발자의 성장 문제와는 별개로, AI는 개발 생산성 향상에 매우 긍정적인 영향을 미친다.</mark> AI는 반복적이거나 정형화된 작업에 소요되는 개발자의 시간을 획기적으로 줄여, 더 중요한 문제에 집중할 수 있도록 돕기 때문이다. 가령, 프로젝트 초기 설정에 필요한 보일러플레이트 코드를 작성하거나, 패턴이 정해진 테스트 코드를 만드는 작업을 AI에게 맡길 수 있다. 또한 복잡한 레거시 코드를 분석하고 이해하는 시간도 크게 단축시킬 수 있다. 결론적으로 <strong>AI는 개발자가 핵심적인 문제 해결에 더 집중하도록 도와, 팀과 기업의 전체적인 생산성을 크게 높이는 강력한 도구임이 분명</strong>하다.</p><p><mark>AI가 가져오는 생산성 향상을 개발자 개인의 성장으로 착각해서는 안 된다.</mark> 빠른 결과물에 익숙해질수록 AI에 대한 의존성은 깊어질 수밖에 없다. 그리고 <strong>역설적이게도, AI 없이는 스스로 문제를 해결하기 어려운 개발자야말로 AI 기술 시대에 가장 먼저 대체될 수 있는 존재일 것</strong>이다. 따라서 우리는 AI를 적극적으로 활용하되, 끊임없이 자신의 성장 상태를 성찰해야 한다. 또한 의도적으로 AI에 의존하지 않고 기본기를 다지는 학습과 훈련을 반드시 병행할 필요가 있다.</p>",
            "url": "https://kimdoubleb.github.io/news/2025/06/30/ai-personal-thinking",
            
            
            
            
            
            "date_published": "2025-06-30T00:00:00+09:00",
            "date_modified": "2025-06-30T00:00:00+09:00",
            
                "author":  {
                "name": "KimDoubleB",
                "url": null,
                "avatar": null
                }
                
            
        },
    
        {
            "id": "https://kimdoubleb.github.io/news/2025/06/26/career",
            "title": "'나의 일을 커리어로 연결하는 법'을 듣고",
            "summary": "한기용님의 '나의 일을 커리어로 연결하는 법' 발표에서 들은 내용을 정리",
            "content_text": "2025년 6월 25일 (수) 19:00 구름 COMMIT 행사에서 한기용님께서 ‘나의 일을 커리어로 연결하는 법’ 발표를 진행함.EO 유튜브에서 한기용님의 이야기를 재밌게 들었던 기억이 있어, 직접 들어보고 싶은 마음에 오프라인 참여로 신청해 듣고왔음.발표는 정말 좋았다. 고민되던 부분들에 대해 여러 생각할 거리들을 던져주기도 하고, 멘탈관리 측면에서도 매우 좋았음.나중에(힘이 빠졌을 때) 다시 보면 좋을 것 같아 나왔던 이야기들에 내 생각들을 추가해 정리.주요 인상 깊었던 내용  기술 지향적인 사람은 미래까지 봤을 때 힘들다.  커리어의 여정에서 성장이 계속 우상향은 아니다.  좋은 매니저와 피드백  꿈이 무엇인가?  모든게 좋은 회사와 직무는 없다. 명암이 있는 법.  남과 비교하지 않고 어제의 나와 오늘의 나를 비교하기  복리가 있는 일하기  꾸준한 회고하기기술 지향적인 사람은 미래까지 봤을 때 힘들다.  일을 끝내고 집가서 공부하는 것 → 해봤는데 아주 좋지 않았다.  기술은 계속 발전하고, 새로운 것은 계속 나온다. 공부의 끝이 없음. → 지칠 수 밖에 없다.  기술적인 것을 쫓기보다 “결과 내는 것”에 집중하기          성취하는 경험과 몰두하는 경험을 통해 자신감 얻기      결과 » 기술      비슷한 이야기로 ‘나의 성장을 저해하는 것’에 대한 이야기  전문성에 대한 집착  남과의 비교커리어의 여정 → 성장 계속 우상향 하는가?  계속 성장할 것 같지만 아님. 성장했다가 쇠퇴했다가 반복. 우상향하면 좋은 거임.  길게보면 어디서 시작하느냐는 그리 중요하지 않았던 것 같음.창업 깨끗하게 망했음 → 너무 힘들었던 경험  월급쟁이일 때가 행복했다는 것을 느낌 (걱정할게 적으니).  이 경험을 해보면 다른거 할 때 힘들게 없다고 느껴짐  즉, 경험이 중요함. 직접 해보고 느낀 것/느낄 수 있던 것. 해보지 않으면 지금까지 모를 것.          이야기 하실 때, 힘들었으나 후회되는 것은 아니라고 함. 이런 경험이 없었으면 몰랐을 것이라고.      정신승리가 필요함. 실패는 중요한게 아님. 거기서 뭘 배울 수 있었는지가 중요한 것.      좋은 매니저란 무엇인가?  롤모델이 되는 사람 → 난 이 사람 따라다니고 싶어. 라는 생각이 드는 사람.  기용님이 생각하실 때, 좋은 매니저의 자질          명확한 결정                  나중에 이 결정이 정답이 아닐 순 있음. 그래도 명확하게 방향성을 결정해주는 것이 중요.                    단호하고 명확한 피드백      피드백  매니저로서 피드백을 주고자 하는데, 피드백을 받고 변하는 사람들이 있음  피드백을 줬음에도 변하지 않는 사람들 → 레이오프 당해도 할 말이 없음  Q) 나에게 적합한 피드백을 주는 사람은 누구인가?안식년 때, 든 생각 “커리어가 끝나고 난 뭐하며 살 것인가?”  내 꿈에 대한 고민  사람들은 마일스톤을 찍고, 그걸 이뤄가면서 살아감.          시험 점수, 특정 회사, …      언젠가 다 이루게 될 수 있는데, 그 이후엔 뭐하고 살 것인가?      또한, 마일스톤 초반엔 행복을 이루기 쉬움. 커리어가 쌓일수록 그 기준이 높아짐.      기준이 높아져 성취를 못하며 자존감이 낮아짐.        꿈을 가져야 한다.  기용님의 꿈은? 안식년 때 느낀 것?          꿈에 대한 내용을 이야기한 건 생각이 안나는데, 기용님이 안식년 때 “작은 회사가서 살아있는 느낌을 받아야겠다”라는 다짐을 했다고 함.      커리어 초반에는 자신의 능력으로 이직하지만, 커리어 후반에는 “평판”으로 이직함.  자신이 (협업? 능력적으로?) 좋은 사람이었다면, 일이 없거나 이직을 하고자 할 떄 주변에서 연락올 것  지인 중심으로 옮겨다님  좋은 평판? ⇒ 영향력이 큰 사람. 더 자세히 말하면 \"나의 존재에 따른 긍정적 영향\"이 큰 사람          업무를 할 때 이 마인드를 계속 상기시켜야겠다 라고 느낌.      어느 회사, 직무든 명암이 있음  어딜가든 “기대수준”을 관리해야 함.  완벽함을 기대하면 실망이 따라오기 마련.  어느 회사/직무든 좋은 점이 있다면 나쁜 점도 있기 마련. 다 똑같다.  고로, 나쁜 점만 바라보지 말고, 좋은 점도 바라보려고 노력해라.  만약 그 좋은 점이 정말 없다면 그 때 옮기면 된다.잘하고 싶은게 있다면 오래 할 생각을 해라.  나이들고 주변을 돌아보니 “오래하는 사람이 잘하는 사람”이라는 생각이 들음  (이런 문장이었는진 정확히 기억은 안나긴 하네…)부캐와 본캐  커리어 초창기 때는 부캐와 본캐를 나누는 사람들이 있음. 이걸 나누는 것에 대한 짤막한 이야기.  **내가 정말 하고 싶은게 있다면 그게 본캐가 되는게 맞지 않겠나?** ⇒ 울림이 있었달까.동아시아와 인도권 사람의 차이  매니징, 교수를 하면서 느끼는 건데, 동아시아 사람들과 인도권 사람들의 특성 차이가 분명함  동아시아권 사람들은 기본적으로 샤이/예의를 차리고, 인도권 사람들은 직관적으로 이야기함.  여러 이야기 해주셨지만 기억에 남는 것          동아시아권 사람들                  채용공고 / Job description 보고 “나 너무 부족해”, “이력서 못쓰겠다” 라고 많이 느낌.                          ⇒ 그렇게 느끼지마라. 부족한 것을 느꼈다면 그걸 채우면 됨.                                승진 이야기 → 자기가 원하는 것을 이야기 잘 안함. 욕망을 숨킴.                          ⇒ 원하는 것이 있으면 말할 줄 아는 능력 필요. “나 뭘 더 원해”, “뭐가 되고 싶어”              여기서 느낀 건 어느정도 이런 욕망을 표출할 줄 알아서 더 성장할 수 있을 것 같고, 이러한 순간들도 나 스스로에게 동기부여될 수도 있겠다 싶었음.                                          개발자들이 많이 느끼는 것 → 누군가 잘나보여서 자신감을 잃는 것  동료가 나보다 잘나보인다. 주변 친구가 모두 나보다 잘나간다.  사기꾼 증후군 극복하기                  사기꾼 증후군: 자신의 성공을 노력이 아닌 운의 탓으로 돌리고 자신의 실력이 드러나는 것을 꺼리는 심리                  높은 성취를 이루었는데도 그것을 과대평가된 것으로 치부하는 동시에 스스로를 과소평가한다. 이런 심리는 타인의 시선에 지나치게 신경을 쓰면서 나타나곤 한다. 높은 기대를 받는 사람이 실패의 충격을 미리 완화하기 위한 일종의 방어기제이다. ‘기대가 크면 실망도 크다‘라는 전제 하에 미리 스스로를 믿지 않아 버리면 혹여 일이 잘못되더라도 후폭풍이 크지 않을 것이라는 계산에 의한 것이다.                    자신감 갖기: 남과 비교하지 않고 어제의 나와 오늘의 나를 비교하기      Love Yourself: 불완전한 나를 있는 그대로 받아들이기      복리가 있는 일 하기  아무 일도 안 하면 아무런 일도 발생하지 않는다. ⇒ 하기만 하면 반 정도 한 것  복리가 있는 일들이라고 생각하는 것          운동, 배움/학습 (호기심), 네트워킹 (사람 만나기), 책 읽기/글쓰기      회고  꾸준한 회고 중요 (너무 자주는 말고, 2주/한달 등 주기를 정해서 회고 진행)  회고에서 중요한 것 ⇒ 내가 못한 것만 쓰지 말기          사람들이 회고하는 것들을 보면 자신이 못한 것만 쓰는 경향이 있음. 보통 그런 것만 생각나기 때문에.        건강한 회고는 \"내가 잘한 것\"과 \"내가 아쉬웠던 것\"의 크기가 비슷해야 함. 한 쪽으로 치우치면 안됨.          정신승리 할 것. 잘한 것을 생각해서 자신감 채우기.      아쉬웠던 것에서는 스트레스 받지 말 것. 배울점을 생각하기, 나의 성장을 느끼기.      메모에 있는데 주제가 생각이 안나는 것들  좋은 사람과 일하는 환경의 중요성 (사람/환경의 중요성)          나와 가장 많은 시간을 사용하는 사람은 누구인가? 긍정적 효과가 있는가?        기회가 되면 손들기 → 다양한 경험 중요  가져야 할 자세, 하면 좋은 것          긍정적인 자세 (안된다고 생각하지 말고, 먼저 살펴보기)      변화 두려워하지 말기      회고 - 실수 인정 / 모른다고 하는 솔직함      ",
            "content_html": "<p>2025년 6월 25일 (수) 19:00 구름 COMMIT 행사에서 한기용님께서 ‘나의 일을 커리어로 연결하는 법’ 발표를 진행함.</p><p>EO 유튜브에서 한기용님의 이야기를 재밌게 들었던 기억이 있어, 직접 들어보고 싶은 마음에 오프라인 참여로 신청해 듣고왔음.</p><p>발표는 정말 좋았다. 고민되던 부분들에 대해 여러 생각할 거리들을 던져주기도 하고, 멘탈관리 측면에서도 매우 좋았음.</p><p>나중에(힘이 빠졌을 때) 다시 보면 좋을 것 같아 나왔던 이야기들에 내 생각들을 추가해 정리.</p><p><br /></p><hr /><p><mark>주요 인상 깊었던 내용</mark></p><ul>  <li>기술 지향적인 사람은 미래까지 봤을 때 힘들다.</li>  <li>커리어의 여정에서 성장이 계속 우상향은 아니다.</li>  <li>좋은 매니저와 피드백</li>  <li>꿈이 무엇인가?</li>  <li>모든게 좋은 회사와 직무는 없다. 명암이 있는 법.</li>  <li>남과 비교하지 않고 어제의 나와 오늘의 나를 비교하기</li>  <li>복리가 있는 일하기</li>  <li>꾸준한 회고하기</li></ul><p><br /></p><hr /><p>기술 지향적인 사람은 미래까지 봤을 때 힘들다.</p><ul>  <li>일을 끝내고 집가서 공부하는 것 → 해봤는데 아주 좋지 않았다.</li>  <li>기술은 계속 발전하고, 새로운 것은 계속 나온다. 공부의 끝이 없음. → 지칠 수 밖에 없다.</li>  <li>기술적인 것을 쫓기보다 “결과 내는 것”에 집중하기    <ul>      <li>성취하는 경험과 몰두하는 경험을 통해 자신감 얻기</li>      <li>결과 » 기술</li>    </ul>  </li></ul><p><br /></p><p>비슷한 이야기로 ‘나의 성장을 저해하는 것’에 대한 이야기</p><ul>  <li>전문성에 대한 집착</li>  <li>남과의 비교</li></ul><p><br /></p><p>커리어의 여정 → 성장 계속 우상향 하는가?</p><ul>  <li>계속 성장할 것 같지만 아님. 성장했다가 쇠퇴했다가 반복. 우상향하면 좋은 거임.</li>  <li>길게보면 어디서 시작하느냐는 그리 중요하지 않았던 것 같음.</li></ul><p><br /></p><p>창업 깨끗하게 망했음 → 너무 힘들었던 경험</p><ul>  <li>월급쟁이일 때가 행복했다는 것을 느낌 (걱정할게 적으니).</li>  <li>이 경험을 해보면 다른거 할 때 힘들게 없다고 느껴짐</li>  <li>즉, <mark>경험이 중요함</mark>. 직접 해보고 느낀 것/느낄 수 있던 것. 해보지 않으면 지금까지 모를 것.    <ul>      <li>이야기 하실 때, 힘들었으나 후회되는 것은 아니라고 함. 이런 경험이 없었으면 몰랐을 것이라고.</li>      <li><strong>정신승리가 필요함. 실패는 중요한게 아님. 거기서 뭘 배울 수 있었는지가 중요한 것.</strong></li>    </ul>  </li></ul><p><br /></p><p>좋은 매니저란 무엇인가?</p><ul>  <li><strong>롤모델이 되는 사람 → 난 이 사람 따라다니고 싶어. 라는 생각이 드는 사람.</strong></li>  <li>기용님이 생각하실 때, 좋은 매니저의 자질    <ul>      <li>명확한 결정        <ul>          <li>나중에 이 결정이 정답이 아닐 순 있음. 그래도 명확하게 방향성을 결정해주는 것이 중요.</li>        </ul>      </li>      <li>단호하고 명확한 피드백</li>    </ul>  </li></ul><p><br /></p><p>피드백</p><ul>  <li>매니저로서 피드백을 주고자 하는데, 피드백을 받고 변하는 사람들이 있음</li>  <li>피드백을 줬음에도 변하지 않는 사람들 → 레이오프 당해도 할 말이 없음</li>  <li><strong><em>Q) 나에게 적합한 피드백을 주는 사람은 누구인가?</em></strong></li></ul><p><br /></p><p>안식년 때, 든 생각 “커리어가 끝나고 난 뭐하며 살 것인가?”</p><ul>  <li>내 꿈에 대한 고민</li>  <li>사람들은 마일스톤을 찍고, 그걸 이뤄가면서 살아감.    <ul>      <li>시험 점수, 특정 회사, …</li>      <li>언젠가 다 이루게 될 수 있는데, 그 이후엔 뭐하고 살 것인가?</li>      <li>또한, 마일스톤 초반엔 행복을 이루기 쉬움. 커리어가 쌓일수록 그 기준이 높아짐.</li>      <li>기준이 높아져 성취를 못하며 자존감이 낮아짐.</li>    </ul>  </li>  <li>꿈을 가져야 한다.</li>  <li>기용님의 꿈은? 안식년 때 느낀 것?    <ul>      <li>꿈에 대한 내용을 이야기한 건 생각이 안나는데, 기용님이 안식년 때 “작은 회사가서 살아있는 느낌을 받아야겠다”라는 다짐을 했다고 함.</li>    </ul>  </li></ul><p><br /></p><p>커리어 초반에는 자신의 능력으로 이직하지만, 커리어 후반에는 “평판”으로 이직함.</p><ul>  <li>자신이 (협업? 능력적으로?) 좋은 사람이었다면, 일이 없거나 이직을 하고자 할 떄 주변에서 연락올 것</li>  <li>지인 중심으로 옮겨다님</li>  <li>좋은 평판? ⇒ 영향력이 큰 사람. 더 자세히 말하면 <mark>\"나의 존재에 따른 긍정적 영향\"</mark>이 큰 사람    <ul>      <li>업무를 할 때 이 마인드를 계속 상기시켜야겠다 라고 느낌.</li>    </ul>  </li></ul><p><br /></p><p>어느 회사, 직무든 명암이 있음</p><ul>  <li>어딜가든 “기대수준”을 관리해야 함.</li>  <li>완벽함을 기대하면 실망이 따라오기 마련.</li>  <li>어느 회사/직무든 좋은 점이 있다면 나쁜 점도 있기 마련. 다 똑같다.</li>  <li>고로, <mark>나쁜 점만 바라보지 말고, 좋은 점도 바라보려고 노력해라.</mark></li>  <li>만약 그 좋은 점이 정말 없다면 그 때 옮기면 된다.</li></ul><p><br /></p><p>잘하고 싶은게 있다면 오래 할 생각을 해라.</p><ul>  <li>나이들고 주변을 돌아보니 “오래하는 사람이 잘하는 사람”이라는 생각이 들음</li>  <li>(이런 문장이었는진 정확히 기억은 안나긴 하네…)</li></ul><p><br /></p><p>부캐와 본캐</p><ul>  <li>커리어 초창기 때는 부캐와 본캐를 나누는 사람들이 있음. 이걸 나누는 것에 대한 짤막한 이야기.</li>  <li><mark>**내가 정말 하고 싶은게 있다면 그게 본캐가 되는게 맞지 않겠나?**</mark> ⇒ 울림이 있었달까.</li></ul><p><br /></p><p>동아시아와 인도권 사람의 차이</p><ul>  <li>매니징, 교수를 하면서 느끼는 건데, 동아시아 사람들과 인도권 사람들의 특성 차이가 분명함</li>  <li>동아시아권 사람들은 기본적으로 샤이/예의를 차리고, 인도권 사람들은 직관적으로 이야기함.</li>  <li>여러 이야기 해주셨지만 기억에 남는 것    <ul>      <li>동아시아권 사람들        <ul>          <li>채용공고 / Job description 보고 “나 너무 부족해”, “이력서 못쓰겠다” 라고 많이 느낌.            <ul>              <li>⇒ 그렇게 느끼지마라. 부족한 것을 느꼈다면 그걸 채우면 됨.</li>            </ul>          </li>          <li>승진 이야기 → 자기가 원하는 것을 이야기 잘 안함. 욕망을 숨킴.            <ul>              <li>⇒ 원하는 것이 있으면 말할 줄 아는 능력 필요. “나 뭘 더 원해”, “뭐가 되고 싶어”</li>              <li>여기서 느낀 건 <mark>어느정도 이런 욕망을 표출할 줄 알아서 더 성장할 수 있을 것 같고, 이러한 순간들도 나 스스로에게 동기부여될 수도 있겠다</mark> 싶었음.</li>            </ul>          </li>        </ul>      </li>    </ul>  </li></ul><p><br /></p><p>개발자들이 많이 느끼는 것 → 누군가 잘나보여서 자신감을 잃는 것</p><ul>  <li>동료가 나보다 잘나보인다. 주변 친구가 모두 나보다 잘나간다.</li>  <li>사기꾼 증후군 극복하기    <ul>      <li>        <p>사기꾼 증후군: 자신의 성공을 노력이 아닌 운의 탓으로 돌리고 자신의 실력이 드러나는 것을 꺼리는 심리</p>        <blockquote>          <p>높은 성취를 이루었는데도 그것을 과대평가된 것으로 치부하는 동시에 스스로를 과소평가한다. 이런 심리는 타인의 시선에 지나치게 신경을 쓰면서 나타나곤 한다. 높은 기대를 받는 사람이 실패의 충격을 미리 완화하기 위한 일종의 <a href=\"https://namu.wiki/w/%EB%B0%A9%EC%96%B4%EA%B8%B0%EC%A0%9C\">방어기제</a>이다. ‘<a href=\"https://namu.wiki/w/%EC%9E%98%20%EB%93%A4%EC%96%B4%EB%9D%BC%2C%20%EC%95%A0%EC%B4%88%EC%97%90%20%EA%B8%B0%EB%8C%80%EB%A5%BC%20%ED%95%98%EB%8B%88%EA%B9%8C%20%EB%B0%B0%EC%8B%A0%EC%9D%84%20%EB%8B%B9%ED%95%98%EB%8A%94%20%EA%B1%B0%EB%8B%A4.\">기대가 크면 실망도 크다</a>‘라는 전제 하에 미리 스스로를 믿지 않아 버리면 혹여 일이 잘못되더라도 <a href=\"https://namu.wiki/w/%ED%9B%84%ED%8F%AD%ED%92%8D\">후폭풍</a>이 크지 않을 것이라는 계산에 의한 것이다.</p>        </blockquote>      </li>      <li><strong><mark>자신감 갖기: 남과 비교하지 않고 어제의 나와 오늘의 나를 비교하기</mark></strong></li>      <li><strong>Love Yourself: 불완전한 나를 있는 그대로 받아들이기</strong></li>    </ul>  </li></ul><p><br /></p><p>복리가 있는 일 하기</p><ul>  <li>아무 일도 안 하면 아무런 일도 발생하지 않는다. ⇒ 하기만 하면 반 정도 한 것</li>  <li>복리가 있는 일들이라고 생각하는 것    <ul>      <li><mark>운동, 배움/학습 (호기심), 네트워킹 (사람 만나기), 책 읽기/글쓰기</mark></li>    </ul>  </li></ul><p><br /></p><p>회고</p><ul>  <li>꾸준한 회고 중요 (너무 자주는 말고, 2주/한달 등 주기를 정해서 회고 진행)</li>  <li>회고에서 중요한 것 ⇒ 내가 못한 것만 쓰지 말기    <ul>      <li>사람들이 회고하는 것들을 보면 자신이 못한 것만 쓰는 경향이 있음. 보통 그런 것만 생각나기 때문에.</li>    </ul>  </li>  <li><mark>건강한 회고는 \"내가 잘한 것\"과 \"내가 아쉬웠던 것\"의 크기가 비슷해야 함.</mark> 한 쪽으로 치우치면 안됨.    <ul>      <li>정신승리 할 것. 잘한 것을 생각해서 자신감 채우기.</li>      <li>아쉬웠던 것에서는 스트레스 받지 말 것. 배울점을 생각하기, 나의 성장을 느끼기.</li>    </ul>  </li></ul><p><br /></p><p>메모에 있는데 주제가 생각이 안나는 것들</p><ul>  <li>좋은 사람과 일하는 환경의 중요성 (사람/환경의 중요성)    <ul>      <li>나와 가장 많은 시간을 사용하는 사람은 누구인가? 긍정적 효과가 있는가?</li>    </ul>  </li>  <li>기회가 되면 손들기 → <mark>다양한 경험</mark> 중요</li>  <li>가져야 할 자세, 하면 좋은 것    <ul>      <li>긍정적인 자세 (안된다고 생각하지 말고, 먼저 살펴보기)</li>      <li>변화 두려워하지 말기</li>      <li>회고 - 실수 인정 / 모른다고 하는 솔직함</li>    </ul>  </li></ul>",
            "url": "https://kimdoubleb.github.io/news/2025/06/26/career",
            
            
            
            
            
            "date_published": "2025-06-26T00:00:00+09:00",
            "date_modified": "2025-06-26T00:00:00+09:00",
            
                "author":  {
                "name": "KimDoubleB",
                "url": null,
                "avatar": null
                }
                
            
        },
    
        {
            "id": "https://kimdoubleb.github.io/news/2025/01/17/trace-sampling",
            "title": "Trace Sampling / 트레이스 샘플링",
            "summary": null,
            "content_text": "Trace를 학습하다보면 “Sampling”, “샘플링”에 대해 필수적으로 알아야 한다.근데 주변에서 가끔 헷갈려하시는 분들이 있어 글로 좀 정리해보자 한다.본 글의 내용은 아래 Opentelemetry 공식문서 글을 참조했다.OpenTelemetry - SamplingSampling? 샘플링?Sampling / 샘플링  모든 가시성 지표를 저장하지 않고, 대표적인 데이터만(대표성을 띄는 데이터만) 저장하는 것  ‘대표성’이라는 건 작은 그룹이 더 큰 그룹을 정확하게 대표할 수 있다는 원칙“Sampling 됬어?” 같은 개념을 헷갈리는 사람들이 있다. 헷갈리지 말자.  Sampled (샘플링 됬다): Trace/Span이 전송됨. 전체 데이터의 대표가 된 것  Not Sampled (샘플링 되지 않았다): Trace/Span이 전송/처리되지 않은 것샘플링을 왜 사용할까?“비용”과 “접근성/용이성” 측면이 있다.근데 접근성/용이성도 개발자의 “비용”과 관련이 있으므로 그냥 “비용” 때문에 사용한다라고 볼 수 있다.  샘플링은 “비용”을 줄이는 가장 효과적인 방법 중 하나이다.  대용량 시스템에서 잘 만들어진 트레이싱 샘플링 구조에선 1% 그 이하의 샘플링 비율로도 나머지 99% 데이터를 매우 정확하게 대표한다.샘플링이 비용을 줄이기 위한 기능이지만, 사실 새로운 비용을 만들기도 한다.  Tail Sampling 같이 효과적으로 데이터를 샘플링하는데 드는 직접적인 컴퓨팅 비용 (계산 비용)  더 많은 애플리케이션, 시스템, 데이터가 관련될 때, 효과적인 샘플링 방식을 유지하는데 드는 엔지니어링 비용  비효과적인 샘플링 기술로 인해 중요한 정보를 놓치는 간접적인 기회비용샘플링 자체는 데이터를 줄여(대표성 있는 데이터만 저장해) 비용을 줄이는데 효과적이나, 제대로 수행되지 않으면 오히려 예상치 못한 비용이 발생할 수 있다.언제 샘플링을 사용해야 할까?샘플링이 필요한 경우  초당 1000개 이상의 Trace를 생성하고 있는 경우  대부분의 Trace 데이터가 데이터 변동이 적은 정상 트래픽을 표현하는 경우  오류, 높은 지연시간 같이 문제를 나타내는 일반적인 기준이 있는 경우  오류, 높은 지연시간 외에 이러한 정보를 표현할 수 있는 도메인 별 기준이 있는 경우  데이터 샘플링 할지/말지를 결정할 수 있는 일반적인 규칙이 있는 경우  서비스를 구분할 수 있어 고용량/저용량 서비스를 다르게 샘플링 할 수 있는 경우  샘플링 되지 않은 데이터를 저비용 저장 시스템으로 라우팅 할 수 있는 경우  전체 예산이 제한적인 경우  관찰가능성에 대해 제한된 예산이 있지만 효과적인 샘플링에 시간을 투자할 수 있는 경우샘플링이 적합하지 않은 경우  매우 적은 Trace 데이터를 생성하고 있는 경우 (초당 수십개 정도)  관찰가능성을 데이터 집계로만 사용하고자 하는 경우  데이터 삭제를 금지하는 규제가 존재하는 경우샘플링 방법샘플링은 크게 2가지 방법으로 나뉜다.  Head Sampling  Tail SamplingHead Sampling가능한 빨리 샘플링 여부를 결정하는 기술Trace 전체를 검사하지 않고, Trace/Span을 샘플링 여부 결정 결정한다.가장 일반적인 Head Sampling은 Consistent Probability Sampling이 있으며, Deterministic Sampling(결정론적 샘플링)이라고도 한다.간단히 설명하면 Trace ID와 샘플링 하는 비율 기반으로 샘플링 여부를 결정하는 방식이다. 이를 통해 전체 Trace가 누락된 Span 없이 5% 같은 일관된 비율로 샘플링 된다.장점  이해 및 구성이 쉽다  효율적으로 동작한다. Trace 전체를 볼 필요 없으니 계산이 복잡하지 않다  Trace 수집 파이프라인 어디서나 수행이 가능하다단점전체 Trace 데이터를 기반으로 샘플링 결정을 내리는 것이 아니라는 단점이 있다.예를 들어, 오류가 있는 모든 Trace는 샘플링 되도록 보장하고 싶어도 할 수 없다. 이러한 경우에는 Tail Sampling이 필요하다.Tail SamplingTrace 내의 모든 또는 대부분의 Span을 고려해 샘플링 여부를 결정하는 방식Head Sampling에서는 불가능한 Trace/Span의 정보를 이용하여 특정 기준에 따라 샘플링 여부를 결정할 수 있다.예시  오류가 포함된 Trace를 100% 샘플링 하기  전체 지연시간 기준으로 어느 이상이 되는 Trace를 샘플링 하기  Trace 내 하나 이상의 Span에 있는 특정 속성 존재 혹은 값 기준으로 Trace 샘플링 하기 (배포 버전에 맞게 샘플링 등)  저용량 서비스에서 오는 Trace, 고용량 서비스에서 오는 Trace를 구분해서 샘플링 비율을 다르게 샘플링 하기예시에서 알 수 있듯 Head Sampling보다 훨씬 더 정교하게 샘플링이 가능하다. 샘플링 필요한 대규모 시스템의 경우, 데이터 볼륨/균형을 맞추기 위해 Tail Sampling을 사용하는 것이 거의 항상 필요하다.단점장점만 있지는 않다.  구현의 어려움: 시스템의 변화에 따라 샘플링 전략도 계속 변화해야 함 (설정하고 잊어버려서는 안됨). 대규모/분산 시스템에서 이러한 전략을 구현하는 규칙도 크고 정교할 수 있음  운영의 어려움: Tail Sampling을 구현하는 컴포넌트는 많은 양의 데이터를 받아들이고 저장할 수 있는 stateful system이여야 함. 트래픽 패턴에 따라 많은 양의 컴퓨팅 노드가 필요할 수 있음. 고로, Tail Sampling 컴포넌트를 모니터링해서 샘플링 로직에 필요한 리소스가 여유로운지 모니터링해야 함  관찰가능성을 위해 유료 벤더를 이용하는 경우, 벤더에서 제공하는 Tail Sampling으로 제한될 수 있음Head + Tail Sampling 조합Tail Sampling과 Head Sampling을 따로 사용해야만 하는 것은 아니다.Telemetry Pipeline이 과부하 되는 것을 방지하기 위해 함께 사용될 수도 있다. 매우 많은 양의 Trace 데이터를 생성하는 서비스의 경우, 먼저 Head Sampling을 통해 Trace를 작은 비율로 줄이고 Telemetry Pipeline에서 Tail Sampling을 이용하여 더 정교한 로직을 통해 Sampling 여부를 결정할 수 있다.OpenTelemetry Collector 지원이에 대해서 OpenTelemetry Collector에서도 지원한다.  Filter processor: 전달된 정보를 이용해 필터링 여부 결정할 수 있음 (단순 결정)  Probabilistic Sampling processor: 퍼센트 정해놓고 샘플링 → 헤드 샘플링  Tail Sampling processor: 테일 샘플링. 복잡한 조건도 가능하고, probabilistic sampling도 가능함마무리트레이스 샘플링은 관찰가능성 시스템에서 비용을 효과적으로 관리하면서도 중요한 정보를 놓치지 않는 핵심 기술이다.Head Sampling은 구현이 쉽고 효율적이지만 제한적이고, Tail Sampling은 더 정교하지만 복잡하고 비용이 많이 든다. 실제 환경에서는 두 방식을 적절히 조합해서 사용하는 것이 일반적이다.중요한 것은 샘플링 전략을 한 번 설정하고 끝내는 것이 아니라, 지속적으로 모니터링하고 최적화해야 한다는 점이다. 시스템이 변화하면 샘플링 전략도 함께 변화해야 효과적인 관찰가능성을 유지할 수 있다.",
            "content_html": "<p>Trace를 학습하다보면 “Sampling”, “샘플링”에 대해 필수적으로 알아야 한다.</p><p>근데 주변에서 가끔 헷갈려하시는 분들이 있어 글로 좀 정리해보자 한다.</p><p>본 글의 내용은 아래 Opentelemetry 공식문서 글을 참조했다.</p><p><strong><a href=\"https://opentelemetry.io/docs/concepts/sampling/\">OpenTelemetry - Sampling</a></strong></p><p><br /></p><hr /><h2 id=\"sampling-샘플링\">Sampling? 샘플링?</h2><p><img alt=\"Image\" src=\"https://private-user-images.githubusercontent.com/37873745/465695746-cd730481-ed95-418e-990e-31cc2cf2ccd6.jpeg?jwt=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJnaXRodWIuY29tIiwiYXVkIjoicmF3LmdpdGh1YnVzZXJjb250ZW50LmNvbSIsImtleSI6ImtleTUiLCJleHAiOjE3NTIzODQ4NjksIm5iZiI6MTc1MjM4NDU2OSwicGF0aCI6Ii8zNzg3Mzc0NS80NjU2OTU3NDYtY2Q3MzA0ODEtZWQ5NS00MThlLTk5MGUtMzFjYzJjZjJjY2Q2LmpwZWc_WC1BbXotQWxnb3JpdGhtPUFXUzQtSE1BQy1TSEEyNTYmWC1BbXotQ3JlZGVudGlhbD1BS0lBVkNPRFlMU0E1M1BRSzRaQSUyRjIwMjUwNzEzJTJGdXMtZWFzdC0xJTJGczMlMkZhd3M0X3JlcXVlc3QmWC1BbXotRGF0ZT0yMDI1MDcxM1QwNTI5MjlaJlgtQW16LUV4cGlyZXM9MzAwJlgtQW16LVNpZ25hdHVyZT1mMTBiZGYxMTE3MzY5NjIzNDNmYzY3YzA1ZWY3ZDI4YzYwMGNiNjc3MzM0MTc5ZTg5NTdmZWUxNzE1OGUyYTIxJlgtQW16LVNpZ25lZEhlYWRlcnM9aG9zdCJ9.wC7Bo100TteQdOJ2eAs49BS5Fc99Z_VAeBw7w8CGDWQ\" /></p><p><strong>Sampling / 샘플링</strong></p><ul>  <li>모든 가시성 지표를 저장하지 않고, <mark>대표적인 데이터만(대표성을 띄는 데이터만) 저장하는 것</mark></li>  <li>‘대표성’이라는 건 작은 그룹이 더 큰 그룹을 정확하게 대표할 수 있다는 원칙</li></ul><p><br /></p><p>“Sampling 됬어?” 같은 개념을 헷갈리는 사람들이 있다. 헷갈리지 말자.</p><ul>  <li><strong>Sampled (샘플링 됬다)</strong>: Trace/Span이 전송됨. <mark>전체 데이터의 대표</mark>가 된 것</li>  <li><strong>Not Sampled (샘플링 되지 않았다)</strong>: Trace/Span이 전송/처리되지 않은 것</li></ul><p><br /></p><hr /><h2 id=\"샘플링을-왜-사용할까\">샘플링을 왜 사용할까?</h2><p><strong>“비용”과 “접근성/용이성” 측면이 있다.</strong></p><p>근데 접근성/용이성도 개발자의 “비용”과 관련이 있으므로 그냥 <strong>“비용” 때문에 사용한다</strong>라고 볼 수 있다.</p><ul>  <li>샘플링은 <strong>“비용”을 줄이는 가장 효과적인 방법 중 하나</strong>이다.</li>  <li>대용량 시스템에서 잘 만들어진 트레이싱 샘플링 구조에선 <mark>1% 그 이하의 샘플링 비율로도 나머지 99% 데이터를 매우 정확하게 대표</mark>한다.</li></ul><p><br /></p><p>샘플링이 비용을 줄이기 위한 기능이지만, 사실 <mark>새로운 비용</mark>을 만들기도 한다.</p><ol>  <li><strong>Tail Sampling</strong> 같이 효과적으로 데이터를 샘플링하는데 드는 직접적인 컴퓨팅 비용 (계산 비용)</li>  <li>더 많은 애플리케이션, 시스템, 데이터가 관련될 때, 효과적인 샘플링 방식을 유지하는데 드는 <strong>엔지니어링 비용</strong></li>  <li>비효과적인 샘플링 기술로 인해 중요한 정보를 놓치는 간접적인 <strong>기회비용</strong></li></ol><p>샘플링 자체는 데이터를 줄여(대표성 있는 데이터만 저장해) 비용을 줄이는데 효과적이나, <mark>제대로 수행되지 않으면 오히려 예상치 못한 비용</mark>이 발생할 수 있다.</p><p><br /></p><hr /><h2 id=\"언제-샘플링을-사용해야-할까\">언제 샘플링을 사용해야 할까?</h2><h3 id=\"샘플링이-필요한-경우\">샘플링이 필요한 경우</h3><ul>  <li>초당 1000개 이상의 Trace를 생성하고 있는 경우</li>  <li>대부분의 Trace 데이터가 데이터 변동이 적은 정상 트래픽을 표현하는 경우</li>  <li>오류, 높은 지연시간 같이 문제를 나타내는 일반적인 기준이 있는 경우</li>  <li>오류, 높은 지연시간 외에 이러한 정보를 표현할 수 있는 도메인 별 기준이 있는 경우</li>  <li>데이터 샘플링 할지/말지를 결정할 수 있는 일반적인 규칙이 있는 경우</li>  <li>서비스를 구분할 수 있어 고용량/저용량 서비스를 다르게 샘플링 할 수 있는 경우</li>  <li>샘플링 되지 않은 데이터를 저비용 저장 시스템으로 라우팅 할 수 있는 경우</li>  <li>전체 예산이 제한적인 경우</li>  <li>관찰가능성에 대해 제한된 예산이 있지만 효과적인 샘플링에 시간을 투자할 수 있는 경우</li></ul><p><br /></p><h3 id=\"샘플링이-적합하지-않은-경우\">샘플링이 적합하지 않은 경우</h3><ul>  <li>매우 적은 Trace 데이터를 생성하고 있는 경우 (초당 수십개 정도)</li>  <li>관찰가능성을 데이터 집계로만 사용하고자 하는 경우</li>  <li>데이터 삭제를 금지하는 규제가 존재하는 경우</li></ul><p><br /></p><hr /><h2 id=\"샘플링-방법\">샘플링 방법</h2><p>샘플링은 크게 2가지 방법으로 나뉜다.</p><ul>  <li><strong>Head Sampling</strong></li>  <li><strong>Tail Sampling</strong></li></ul><p><br /></p><h3 id=\"head-sampling\">Head Sampling</h3><p><strong>가능한 빨리 샘플링 여부를 결정하는 기술</strong></p><p>Trace 전체를 검사하지 않고, Trace/Span을 샘플링 여부 결정 결정한다.</p><p>가장 일반적인 Head Sampling은 <strong>Consistent Probability Sampling</strong>이 있으며, <strong>Deterministic Sampling(결정론적 샘플링)</strong>이라고도 한다.</p><p>간단히 설명하면 <strong>Trace ID와 샘플링 하는 비율 기반으로 샘플링 여부를 결정하는 방식</strong>이다. 이를 통해 전체 Trace가 누락된 Span 없이 5% 같은 일관된 비율로 샘플링 된다.</p><p><br /></p><h4 id=\"장점\">장점</h4><ul>  <li>이해 및 구성이 쉽다</li>  <li>효율적으로 동작한다. Trace 전체를 볼 필요 없으니 계산이 복잡하지 않다</li>  <li>Trace 수집 파이프라인 어디서나 수행이 가능하다</li></ul><p><br /></p><h4 id=\"단점\">단점</h4><p><strong>전체 Trace 데이터를 기반으로 샘플링 결정을 내리는 것이 아니라는 단점이 있다.</strong></p><p>예를 들어, 오류가 있는 모든 Trace는 샘플링 되도록 보장하고 싶어도 할 수 없다. 이러한 경우에는 <strong>Tail Sampling이 필요</strong>하다.</p><p><br /></p><p><br /></p><h3 id=\"tail-sampling\">Tail Sampling</h3><p><strong>Trace 내의 모든 또는 대부분의 Span을 고려해 샘플링 여부를 결정하는 방식</strong></p><p>Head Sampling에서는 불가능한 Trace/Span의 정보를 이용하여 특정 기준에 따라 샘플링 여부를 결정할 수 있다.</p><p><img alt=\"Image\" src=\"https://github.com/user-attachments/assets/77737785-d158-49a2-aaea-371fcb90d3c9\" /></p><p><br /></p><h4 id=\"예시\">예시</h4><ul>  <li>오류가 포함된 Trace를 100% 샘플링 하기</li>  <li>전체 지연시간 기준으로 어느 이상이 되는 Trace를 샘플링 하기</li>  <li>Trace 내 하나 이상의 Span에 있는 특정 속성 존재 혹은 값 기준으로 Trace 샘플링 하기 (배포 버전에 맞게 샘플링 등)</li>  <li>저용량 서비스에서 오는 Trace, 고용량 서비스에서 오는 Trace를 구분해서 샘플링 비율을 다르게 샘플링 하기</li></ul><p>예시에서 알 수 있듯 <strong>Head Sampling보다 훨씬 더 정교하게 샘플링이 가능</strong>하다. 샘플링 필요한 대규모 시스템의 경우, 데이터 볼륨/균형을 맞추기 위해 <strong>Tail Sampling을 사용하는 것이 거의 항상 필요</strong>하다.</p><p><br /></p><h4 id=\"단점-1\">단점</h4><p>장점만 있지는 않다.</p><ul>  <li><strong>구현의 어려움</strong>: 시스템의 변화에 따라 샘플링 전략도 계속 변화해야 함 (설정하고 잊어버려서는 안됨). 대규모/분산 시스템에서 이러한 전략을 구현하는 규칙도 크고 정교할 수 있음</li>  <li><strong>운영의 어려움</strong>: Tail Sampling을 구현하는 컴포넌트는 많은 양의 데이터를 받아들이고 저장할 수 있는 stateful system이여야 함. 트래픽 패턴에 따라 많은 양의 컴퓨팅 노드가 필요할 수 있음. 고로, Tail Sampling 컴포넌트를 모니터링해서 샘플링 로직에 필요한 리소스가 여유로운지 모니터링해야 함</li>  <li>관찰가능성을 위해 유료 벤더를 이용하는 경우, 벤더에서 제공하는 Tail Sampling으로 제한될 수 있음</li></ul><p><br /></p><h3 id=\"head--tail-sampling-조합\">Head + Tail Sampling 조합</h3><p><strong>Tail Sampling과 Head Sampling을 따로 사용해야만 하는 것은 아니다.</strong></p><p>Telemetry Pipeline이 과부하 되는 것을 방지하기 위해 함께 사용될 수도 있다. 매우 많은 양의 Trace 데이터를 생성하는 서비스의 경우, 먼저 <strong>Head Sampling을 통해 Trace를 작은 비율로 줄이고 Telemetry Pipeline에서 Tail Sampling을 이용하여 더 정교한 로직을 통해 Sampling 여부를 결정</strong>할 수 있다.</p><p><br /></p><hr /><h2 id=\"opentelemetry-collector-지원\">OpenTelemetry Collector 지원</h2><p>이에 대해서 <a href=\"https://github.com/open-telemetry/opentelemetry-collector-contrib\">OpenTelemetry Collector</a>에서도 지원한다.</p><ul>  <li><strong>Filter processor</strong>: 전달된 정보를 이용해 필터링 여부 결정할 수 있음 (단순 결정)</li>  <li><strong>Probabilistic Sampling processor</strong>: 퍼센트 정해놓고 샘플링 → 헤드 샘플링</li>  <li><strong>Tail Sampling processor</strong>: 테일 샘플링. 복잡한 조건도 가능하고, probabilistic sampling도 가능함</li></ul><p><br /></p><hr /><h2 id=\"마무리\">마무리</h2><p>트레이스 샘플링은 관찰가능성 시스템에서 비용을 효과적으로 관리하면서도 중요한 정보를 놓치지 않는 핵심 기술이다.</p><p><strong>Head Sampling</strong>은 구현이 쉽고 효율적이지만 제한적이고, <strong>Tail Sampling</strong>은 더 정교하지만 복잡하고 비용이 많이 든다. 실제 환경에서는 두 방식을 적절히 조합해서 사용하는 것이 일반적이다.</p><p>중요한 것은 <mark>샘플링 전략을 한 번 설정하고 끝내는 것이 아니라, 지속적으로 모니터링하고 최적화해야 한다는 점</mark>이다. 시스템이 변화하면 샘플링 전략도 함께 변화해야 효과적인 관찰가능성을 유지할 수 있다.</p>",
            "url": "https://kimdoubleb.github.io/news/2025/01/17/trace-sampling",
            
            
            
            "tags": ["trace","sampling","observability","opentelemetry"],
            
            "date_published": "2025-01-17T00:00:00+09:00",
            "date_modified": "2025-01-17T00:00:00+09:00",
            
                "author":  {
                "name": "KimDoubleB",
                "url": null,
                "avatar": null
                }
                
            
        },
    
        {
            "id": "https://kimdoubleb.github.io/news/2024/10/29/sbom",
            "title": "SBOM (Software Bill of Materials)",
            "summary": null,
            "content_text": "이 글을 통해 SBOM 대한 생각을 정리하고, 여러 툴들을 이용해 SBOM을 만들며 보안 이슈를 확인해볼까 해요.간단히 만들어 보는 과정만을 담고 있으므로 SBOM 생성/분석 툴들의 상세한 옵션들은 다루지 않을게요.SBOM이란 무엇일까요?SBOM은 Software Bill of Materials의 약자예요.Maven을 사용해보신 개발자라면 BOM이라는 단어 그리고 Bill of Materials는 많이 접해보셨을 텐데요.단어 뜻 그대로 “자재명세서”를 의미해요. ‘어떤 소프트웨어가 무엇으로 이루어져있지?’한다면 Bill of Materials를 통해 ‘아 이런 소프트웨어들이 내포되어 있구나!’라는 것을 알 수 있어요.이러한 Maven BOM을 이용하여 여러 라이브러리들의 의존성 버전을 관리하고, 라이브러리 간 버전 충돌 방지 등의 이점을 얻을 수 있었죠.SBOM도 비슷한 의미이지만, 하고자 하는 역할이 달라요.SBOM 파일을 통해서 특정 소프트웨어가 어떤 라이브러리, 패키지, 라이선스 등 어떠한 구성요소로 이루어져 있는지 확인할 수 있어요.하지만 Maven BOM에서는 빌드 간 편의성을 이를 관리했던 것과 달리 SBOM은 소프트웨어 공급망(Software Supply Chain)에 대한 가시성을 높이고, 소프트웨어 종속성을 편리하게 추적하고 관리하기 위한 용도로 활용돼요.  Maven은 Maven 생태계에서 빌드 환경에 편의를 위해 고안된 것이라면,SBOM은 특정 언어 및 빌드 툴에 의존적인 형태가 아닌 소프트웨어에 대해 종속성에 대한 가시성을 높이고 편리하게 관리하기 위해 고안되었다고 볼 수 있어요.왜 필요할까요?그럼 ‘소프트웨어 공급망(Software Supply Chain)에 대한 가시성을 높이고, 소프트웨어 종속성을 편리하게 추적하고 관리하기 위한 용도’가 왜 필요할까요?큰 프로젝트를 관리해보신 분이라면 라이브러리 종속성 관리의 어려움을 아실 거예요.프로젝트가 커져감에 따라 필요한 기능들이 많아지고, 기능들을 손수 구현하는 것이 아닌 여러 라이브러리들을 사용하다보면 어느새 엄청나게 많은 라이브러리가 의존성 목록에 존재하게 돼요.이와중에 컨테이너 환경이 도입되면서 빌드에 사용되는 툴/소스들을 관리하게 되고, 운영 컨테이너 내부적으로 사용되는 소프트웨어 등 추가적으로 관리해야하는 소프트웨어들은 엄청나게 많아요.이 때,  특정 소프트웨어의 버전에 보안 취약점이 공개되었다고 해볼까요?  이 소프트웨어가 사용 중인지 어떻게 알 수 있을까요?  더 나아가 특정 버전이 사용 중인지 어떻게 알 수 있을까요?맞아요. 모든 환경에서 사용중인지 직접 찾아보는 과정을 거쳐야 해요.소규모 프로젝트라면 쉽게 확인할 수 있겠지만, 대규모 프로젝트라면 이 과정도 쉽지 않을 거예요.만약 쉽게 찾더라도, 이를 보안 취약점이 공개될 때마다 수동으로 찾아봐야한다는 문제도 있어요.CVE, GHSA 등 보안취약점은 계속적으로 추가되고 공개되는데, 그 때마다 내 소프트웨어가 이에 해당하는지 찾아보는 것은 비효율적이에요.SBOM은 이러한 문제를 해결하기 위해 등장했어요.SBOMSBOM은 라이브러리, 패키지, 라이선스 등 소프트웨어의 구성요소 목록이에요.  패키지 이름, 버전, 작성자, 사용 위치, 배포되는 라이선스, 보안 취약점 등 중요한 정보를 캡슐화하여 제공해요.  단순한 목록이 아닌 소프트웨어 투명성을 위한 도구로서 보안, 규정 준수, 종속성 관리 측면에서 소프트웨어를 개선할 수 있도록 도와요.미래에는 SBOM과 이를 통한 보안 취약점 관리 등이 필수적인 요소로 자리잡을 것으로 예상돼요.  현재는 아직 필수적인 요소로 보여지지는 않아요. 하지만 추후 시간이 지남에 따라 SBOM의 중요성이 부각되면서 필수적인 요소로 보여질 것 같아요 (복잡한 소프트웨어 생태계에서 보안을 위한 스탠다드 느낌).  CI/CD 단계에서도 SBOM을 생성하고, 이를 통해 보안 취약점을 분석하는 작업을 하게 될 거예요. 또한, Private Registry에 올라간 이미지들에 대하여 정기적인 SBOM을 이용한 보안 분석이 수행될 거예요 (빌드 될 때 발견되지 않은 보안취약점/잠재적인 보안취약점 발견을 위한 프로세스).당연하겠지만 그냥 ‘내가 Markdown으로 라이브러리 목록 작성해서 만들어야지~’는 SBOM이 아니에요.위 목적에 맞게 정해진 스펙으로 만들어진 것이 SBOM이며 여러 포맷을 지원하고 있어요. 이에 대해서는 뒤에서 알아볼게요!SBOM과 그 필요성에 대해 더 자세히 보고 싶다면, anchore의 글을 참고하시면 좋아요.SBOM 생성하기이제, SBOM을 만들어볼까요?SBOM은 정해진 형식이 있는 파일이에요. 고로, 저희가 수동으로 만들기보단 툴을 이용해서 만들어요.Syft 이용하기SBOM에는 여러 포맷(Syft, CycloneDX, SPDX 등)이 있으며, 이를 만드는 툴(Trivy, Syft, Docker Scout 등)도 여러가지가 존재해요.  참고) 지금으로부터 2년이 되긴했는데, 포맷에 대해 설명한 IT WORLD (한국어로 작성된) 기사가 있네요.이 중 많이 활용되고 있는 Syft 툴을 이용해볼까요?  https://github.com/anchore/syftSyft는 앞서 이야기한 3개의 포맷을 다 지원하기 때문에(syft output formats), 원하는 포맷을 타겟해서 SBOM을 생성할 수 있어요.사용 방법은 간단해요. CLI를 설치하고 단순히 특정 컨테이너 이미지를 넘겨주기만 하면 돼요.$ syft tree9295/sbom-test-spring:0.0.1 -o syft-json &gt; syft.sbom.json ✔ Loaded image                      tree9295/sbom-test- ✔ Parsed image                    sha256:916882e8fb9a6cb4 ✔ Cataloged contents              5c7a714ff592cac86f4d3ff   ├── ✔ Packages                        [51 packages]   ├── ✔ File digests                    [220 files]   ├── ✔ File metadata                   [220 locations]   └── ✔ Executables                     [107 executables]설치 방법은 Syft README를 참고해주세요.테스트를 위해 Spring boot 3.2.1 + Web/MVC을 이용해 구성된 container를 배포해두었어요 (tree9295/sbom-test-spring)만약 다른 format을 이용하고 싶다면, -o cyclonedx-json 같이 output option으로 설정하시면 돼요.결과 확인위 결과로 만들어진 syft.sbom.json 파일을 살펴볼까요?파일의 양이 많아 전체를 담지는 못했지만, 아래와 같이 사용된 라이브러리와 그 정보들을 담고 있는 것을 확인할 수 있어요.여기서 알아야하는 것은 저희가 사용했다고 생각한 라이브러리(spring boot 등) 뿐 아니라 Container 이미지에서 사용하고 있는 기본 툴들에 대한 정보도 다 포함되어 있다는 거예요.어떻게 만드는걸까요?이렇게 SBOM을 만들어보았는데요. 한 가지 궁금증이 들어요.Syft 같은 SBOM 생성 툴들은 단순 Container image로 SBOM을 어떻게 만들 수 있었던 걸까요?아시다시피 Container image는 단순 애플리케이션이 아닌 애플리케이션을 실행하기 위한 환경도 포함하고 있어요.이러한 모든 것들은 Container image 내 File system에 존재해요.  가끔 Container image가 마법 같이 바로 애플리케이션을 실행시켜주는 단순 실행 프로그램으로 아시는 분들이 있어요. Container image는 애플리케이션과 그 실행에 필요한 모든 종속성을 포함하는 완전한 패키지예요. 오해하면 안 돼요.Syft는 이걸 이용해요.Container image 내 파일들을 스캔하고, 패키지 정보를 수집한 뒤 구조화된 SBOM 형태로 변환하여 사용자가 원하는 포맷으로 출력해요.자세히는 Syft 내 Cataloger들이 stereoscope 라이브러리를 이용하여 image 내 파일들을 스캔하고 정보를 수집해요.  이에 대한 자세한 내용은 Syft Architecture를 참고해주세요.  Syft는 binary 파일에 대해서도 분석을 수행해요 (Improving Syft’s Binary Detection)SBOM을 통해 보안취약점 분석하기SBOM을 만들었다고 해볼까요? 그럼 보안 위험이 해결되는 걸까요?당연히 아니에요. 이를 보고 이해하고 보안 위험 등 운영상의 문제가 있는 부분을 찾을 수 있는 툴이 필요해요.생성된 SBOM을 이용하여 보안 취약점을 분석하는 툴들도 여러가지 존재해요.이 글에서는 Grype을 이용하여 분석해볼게요.  https://github.com/anchore/grype  Grype는 Syft를 만든 anchore에서 만들었어요.  설치 방법은 Grype README를 참고해주세요.사실 Syft를 이용하여 SBOM을 만들지 않아도 Grype 내부에서 Syft를 이용하고 있어 SBOM을 만들고 바로 분석까지 수행이 가능해요.  ex) grype tree9295/sbom-test-spring:0.0.1하지만 저희는 만들어 둔 SBOM을 이용해볼게요.앞선 예제로 사용했던 sbom-test-spring 이미지는 Spring boot 3.2.1을 이용하고 있어요.해당 라이브러리는 spring web 6.1.2 버전을 이용하고 있는데요. 이 버전에서는 High 등급 3개의 보안 취약점이 발견되었어요.  Spring web 6.1.2 Vulnerabilities  Spring Security Advisories List만든 SBOM을 Grype에서 분석하여 위 보안취약점이 검출되는지 확인해볼게요.$ grype syft.sbom.json ✔ Scanned for vulnerabilities     [12 vulnerability matches]   ├── by severity: 0 critical, 6 high, 4 medium, 0 low, 0 negligible (2 unknown)   └── by status:   12 fixed, 0 not-fixed, 0 ignoredNAME                    INSTALLED  FIXED-IN  TYPE          VULNERABILITY        SEVERITYlibcrypto3              3.3.2-r0   3.3.2-r1  apk           CVE-2024-9143        Unknownlibssl3                 3.3.2-r0   3.3.2-r1  apk           CVE-2024-9143        Unknown...spring-web              6.1.2      6.1.5     java-archive  GHSA-hgjh-9rj2-g67j  Highspring-web              6.1.2      6.1.4     java-archive  GHSA-ccgv-vj62-xf9h  Highspring-web              6.1.2      6.1.6     java-archive  GHSA-2wrp-6fg6-hmc5  Highspring-web              6.1.2      6.1.12    java-archive  GHSA-2rmj-mq67-h97g  Medium...위에서 보았던 것처럼 3개의 GHSA High 보안취약점이 확인되는 것을 볼 수 있어요.  예상하지 못했던 컨테이너에 포함된 다양한 다른 보안취약점까지 확인되는 것을 볼 수 있어요.  GHSA는 Github에서 관리되는 보안 취약점 데이터베이스예요. CVE와 개념은 같은데, Github에 존재하는 프로젝트와 관련된 취약점에 초점을 맞춘 것이라고 이해하시면 돼요.위 결과에서 알 수 있듯 단순 보안취약점 검출을 넘어  어떤 타입인지  어떤 Vulnerability인지  그리고 제일 중요한 어떤 버전에서 fix 되었는지까지 다양한 정보를 보여줘요.이렇게 분석된 결과를 바탕으로 보안 취약점 등 이슈를 보고하거나 수정해 나갈 수 있어요.  각 보안취약점을 무조건 수정해야한다는 것은 아니에요.문제 발현조건들이 다 다를 수 있으니 위 리포트를 바탕으로 Vulnerability report를 보고 파악해보는 것이 중요해요.파이프라인 구성하기SBOM 생성과 분석이 포함된 파이프라인 구성은 인프라 구성상황에 따라 다르기에 여러 예시를 첨부하는 것으로 대신할게요.예시) DevSecOps CI/CD예시) Grype를 이용한 Github action pipeline 구성예시) Syft SBOM, Sigstore 컨테이너 서명을 통한 SBOM 증명(attestation) 과정결론이렇게 SBOM을 만들고, SBOM을 분석하여 보안 취약점을 파악해보았어요.이는 어떻게 활용될 수 있을까요?CI/CD 및 정기적인 보안 프로세스에서 컨테이너 이미지에 대해 보안취약점, 부적격 라이센스 이용 등을 손쉽게 파악해볼 수 있을 거예요.가끔 회사 공지 혹은 메일로 오는 것들을 생각해봐요. ‘XXX 취약점으로 인한 버전 확인 요청’, ‘XXX 소프트웨어 라이센스 변경으로 인한 이용 확인 요청’ 등 귀찮은 작업들이 수두룩 하지 않나요?SBOM을 이용한다면 특정 버전을 사용하고 있는지도, 보안 취약점이 존재하는지도, 라이센스 문제가 있는지도 바로 파악이 가능할 거예요.보안 부서 입장에서도, 플랫폼 운영 입장에서도, 소프트웨어를 직접 개발하는 개발자 입장에서도 아주 편리한 회사생활이 될 것 같네요 :-)여기까지 긴 글 읽어주셔서 감사합니다.부록 (끝내기는 아쉽지)글을 작성하며, Spring boot를 주로 사용하는 개발자로서 \"Spring boot에서는 SBOM 생성을 지원하는게 없을까?\"를 중심으로 먼저 찾아보았었는데요.이대로 간직하긴 아쉬워서 관련된 내용들은 부록으로나마 공유드릴게요.Spring boot 3.3 actuator + CycloneDX pluginhttps://spring.io/blog/2024/05/24/sbom-support-in-spring-boot-3-3Spring boot 3.3부터는 actuator를 통해 SBOM을 출력하는 엔드포인트를 제공하도록 업데이트 되었어요.이를 위해서는 아래와 같은 구성이 필요해요.  CycloneDX plugin 추가 =&gt; id(“org.cyclonedx.bom”) version “1.8.2”  Spring Web, Actuator 의존성 추가  Actuator SBOM 활성화 및 노출 property 설정위 설정을 완료한 뒤 /actuator/sbom/application endpoint에 접속하면 CycloneDX format의 SBOM이 노출된 것을 확인할 수 있어요.이를 Grype를 통해 분석하고자 한다면, 아래와 같이 해볼 수 있어요.$ curl http://{host}/actuator/sbom/application | grypeCloud Native Buildpacks (CNB)Spring boot에서는 CNB를 이용한 플러그인을 통해 손쉽게 Container image를 만들 수 있도록 지원하고 있어요.ex) .gradlew bootBuildImage이와 관련되어 아래 문서들을 참고해보면 좋아요.  https://docs.spring.io/spring-boot/gradle-plugin/packaging-oci-image.html  https://docs.spring.io/spring-boot/reference/packaging/container-images/cloud-native-buildpacks.html  https://github.com/paketo-buildpacks/spring-boot  https://buildpacks.io/이 때 CNB를 이용한 빌드 과정에서 syft가 사용되는 것을 볼 수 있어요.$ ./gradlew bootBuildImage...    [creator]     paketo-buildpacks/syft              2.3.1...    [creator]     Paketo Buildpack for Syft 2.3.1    [creator]       https://github.com/paketo-buildpacks/syft...Container Image를 확인해보면, /layers/sbom/launch 디렉토리 아래에 빌드 과정에서 만들어진 SBOM 목록이 존재하는 것을 볼 수 있죠.$ find /layers/sbom/launch -name \"*.json\"/layers/sbom/launch/buildpacksio_lifecycle/launcher/sbom.cdx.json/layers/sbom/launch/buildpacksio_lifecycle/launcher/sbom.spdx.json/layers/sbom/launch/buildpacksio_lifecycle/launcher/sbom.syft.json/layers/sbom/launch/paketo-buildpacks_bellsoft-liberica/helper/sbom.syft.json/layers/sbom/launch/paketo-buildpacks_bellsoft-liberica/jre/sbom.syft.json/layers/sbom/launch/paketo-buildpacks_ca-certificates/helper/sbom.syft.json/layers/sbom/launch/paketo-buildpacks_executable-jar/sbom.cdx.json/layers/sbom/launch/paketo-buildpacks_executable-jar/sbom.syft.json/layers/sbom/launch/paketo-buildpacks_spring-boot/helper/sbom.syft.json/layers/sbom/launch/paketo-buildpacks_spring-boot/spring-cloud-bindings/sbom.syft.json/layers/sbom/launch/sbom.legacy.jsonBuildpack을 이용해 빌드 과정에서 활용되는 라이브러리, 애플리케이션에서 사용되는 라이브러리 등 전체적으로 사용되는 모든 소프트웨어 구성요소를 SBOM로 구성해두고 있는 것을 볼 수 있어요.  Paketo Buildpack 문서를 보면 이에 대해 더 자세히 설명하고 있어요.          Paketo buildpack - SBOM      Paketo buildpack - How to access the SBOM      Syft를 통해 해당 이미지를 분석해보면, 위 SBOM 파일들도 분석 대상에 포함되어 전체적인 하나의 SBOM 파일을 만들 것으로 예상돼요.",
            "content_html": "<p>이 글을 통해 SBOM 대한 생각을 정리하고, 여러 툴들을 이용해 SBOM을 만들며 보안 이슈를 확인해볼까 해요.</p><p>간단히 만들어 보는 과정만을 담고 있으므로 SBOM 생성/분석 툴들의 상세한 옵션들은 다루지 않을게요.</p><p><br /></p><hr /><h2 id=\"sbom이란-무엇일까요\">SBOM이란 무엇일까요?</h2><p>SBOM은 <mark>Software Bill of Materials의 약자</mark>예요.</p><p>Maven을 사용해보신 개발자라면 BOM이라는 단어 그리고 Bill of Materials는 많이 접해보셨을 텐데요.</p><p>단어 뜻 그대로 “자재명세서”를 의미해요. ‘어떤 소프트웨어가 무엇으로 이루어져있지?’한다면 Bill of Materials를 통해 ‘아 이런 소프트웨어들이 내포되어 있구나!’라는 것을 알 수 있어요.</p><p>이러한 Maven BOM을 이용하여 여러 라이브러리들의 의존성 버전을 관리하고, 라이브러리 간 버전 충돌 방지 등의 이점을 얻을 수 있었죠.</p><p><br /></p><p>SBOM도 비슷한 의미이지만, 하고자 하는 역할이 달라요.</p><p>SBOM 파일을 통해서 특정 소프트웨어가 어떤 라이브러리, 패키지, 라이선스 등 어떠한 구성요소로 이루어져 있는지 확인할 수 있어요.</p><p>하지만 Maven BOM에서는 빌드 간 편의성을 이를 관리했던 것과 달리 SBOM은 소프트웨어 공급망(Software Supply Chain)에 대한 가시성을 높이고, 소프트웨어 종속성을 편리하게 추적하고 관리하기 위한 용도로 활용돼요.</p><blockquote>  <p>Maven은 Maven 생태계에서 빌드 환경에 편의를 위해 고안된 것이라면,SBOM은 특정 언어 및 빌드 툴에 의존적인 형태가 아닌 소프트웨어에 대해 종속성에 대한 가시성을 높이고 편리하게 관리하기 위해 고안되었다고 볼 수 있어요.</p></blockquote><p><br /></p><hr /><h2 id=\"왜-필요할까요\">왜 필요할까요?</h2><p>그럼 <strong>‘소프트웨어 공급망(Software Supply Chain)에 대한 가시성을 높이고, 소프트웨어 종속성을 편리하게 추적하고 관리하기 위한 용도’가 왜 필요</strong>할까요?</p><p><br /></p><p>큰 프로젝트를 관리해보신 분이라면 <mark>라이브러리 종속성 관리의 어려움</mark>을 아실 거예요.</p><p>프로젝트가 커져감에 따라 필요한 기능들이 많아지고, 기능들을 손수 구현하는 것이 아닌 여러 라이브러리들을 사용하다보면 어느새 <strong>엄청나게 많은 라이브러리가 의존성 목록에 존재</strong>하게 돼요.</p><p>이와중에 컨테이너 환경이 도입되면서 빌드에 사용되는 툴/소스들을 관리하게 되고, 운영 컨테이너 내부적으로 사용되는 소프트웨어 등 추가적으로 관리해야하는 소프트웨어들은 엄청나게 많아요.</p><p><br /></p><p>이 때,</p><ul>  <li>특정 소프트웨어의 버전에 보안 취약점이 공개되었다고 해볼까요?</li>  <li>이 소프트웨어가 사용 중인지 어떻게 알 수 있을까요?</li>  <li>더 나아가 특정 버전이 사용 중인지 어떻게 알 수 있을까요?</li></ul><p>맞아요. 모든 환경에서 사용중인지 직접 찾아보는 과정을 거쳐야 해요.</p><p>소규모 프로젝트라면 쉽게 확인할 수 있겠지만, 대규모 프로젝트라면 이 과정도 쉽지 않을 거예요.</p><p><br /></p><p>만약 쉽게 찾더라도, 이를 보안 취약점이 공개될 때마다 수동으로 찾아봐야한다는 문제도 있어요.</p><p>CVE, GHSA 등 보안취약점은 계속적으로 추가되고 공개되는데, 그 때마다 내 소프트웨어가 이에 해당하는지 찾아보는 것은 비효율적이에요.</p><p>SBOM은 이러한 문제를 해결하기 위해 등장했어요.</p><p><br /></p><h2 id=\"sbom\">SBOM</h2><p><mark>SBOM은 라이브러리, 패키지, 라이선스 등 소프트웨어의 구성요소 목록</mark>이에요.</p><ul>  <li>패키지 이름, 버전, 작성자, 사용 위치, 배포되는 라이선스, 보안 취약점 등 중요한 정보를 캡슐화하여 제공해요.</li>  <li>단순한 목록이 아닌 소프트웨어 투명성을 위한 도구로서 보안, 규정 준수, 종속성 관리 측면에서 소프트웨어를 개선할 수 있도록 도와요.</li></ul><p><br /></p><p>미래에는 <mark>SBOM과 이를 통한 보안 취약점 관리 등이 필수적인 요소로 자리잡을 것</mark>으로 예상돼요.</p><ul>  <li>현재는 아직 필수적인 요소로 보여지지는 않아요. 하지만 추후 시간이 지남에 따라 SBOM의 중요성이 부각되면서 필수적인 요소로 보여질 것 같아요 (복잡한 소프트웨어 생태계에서 보안을 위한 스탠다드 느낌).</li>  <li>CI/CD 단계에서도 SBOM을 생성하고, 이를 통해 보안 취약점을 분석하는 작업을 하게 될 거예요. 또한, Private Registry에 올라간 이미지들에 대하여 정기적인 SBOM을 이용한 보안 분석이 수행될 거예요 (빌드 될 때 발견되지 않은 보안취약점/잠재적인 보안취약점 발견을 위한 프로세스).</li></ul><p><br /></p><p>당연하겠지만 그냥 ‘내가 Markdown으로 라이브러리 목록 작성해서 만들어야지~’는 SBOM이 아니에요.</p><p>위 목적에 맞게 정해진 스펙으로 만들어진 것이 SBOM이며 여러 포맷을 지원하고 있어요. 이에 대해서는 뒤에서 알아볼게요!</p><p>SBOM과 그 필요성에 대해 더 자세히 보고 싶다면, <a href=\"https://anchore.com/sbom/what-is-an-sbom/\">anchore의 글</a>을 참고하시면 좋아요.</p><p><br /></p><hr /><h2 id=\"sbom-생성하기\">SBOM 생성하기</h2><p>이제, SBOM을 만들어볼까요?</p><p>SBOM은 정해진 형식이 있는 파일이에요. 고로, 저희가 수동으로 만들기보단 툴을 이용해서 만들어요.</p><p><br /></p><h3 id=\"syft-이용하기\">Syft 이용하기</h3><p>SBOM에는 여러 포맷(<a href=\"https://github.com/anchore/syft?tab=readme-ov-file#output-formats\">Syft</a>, <a href=\"https://cyclonedx.org/\">CycloneDX</a>, <a href=\"https://spdx.dev/learn/overview/\">SPDX</a> 등)이 있으며, 이를 만드는 툴(Trivy, Syft, Docker Scout 등)도 여러가지가 존재해요.</p><ul>  <li>참고) 지금으로부터 2년이 되긴했는데, 포맷에 대해 설명한 <a href=\"https://www.itworld.co.kr/article/3555955/%EC%A3%BC%EC%9A%94-sbom-%ED%8F%AC%EB%A7%B7-spdx%EC%99%80-%EC%82%AC%EC%9D%B4%ED%81%B4%EB%A1%A0dx%EC%9D%98-%EB%B9%84%EA%B5%90.html\">IT WORLD (한국어로 작성된) 기사</a>가 있네요.</li></ul><p><br /></p><p>이 중 많이 활용되고 있는 Syft 툴을 이용해볼까요?</p><ul>  <li>https://github.com/anchore/syft</li></ul><p><br /></p><p>Syft는 앞서 이야기한 3개의 포맷을 다 지원하기 때문에(<a href=\"https://github.com/anchore/syft?tab=readme-ov-file#output-formats\">syft output formats</a>), 원하는 포맷을 타겟해서 SBOM을 생성할 수 있어요.</p><p>사용 방법은 간단해요. CLI를 설치하고 단순히 특정 컨테이너 이미지를 넘겨주기만 하면 돼요.</p><div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>$ syft tree9295/sbom-test-spring:0.0.1 -o syft-json &gt; syft.sbom.json ✔ Loaded image                      tree9295/sbom-test- ✔ Parsed image                    sha256:916882e8fb9a6cb4 ✔ Cataloged contents              5c7a714ff592cac86f4d3ff   ├── ✔ Packages                        [51 packages]   ├── ✔ File digests                    [220 files]   ├── ✔ File metadata                   [220 locations]   └── ✔ Executables                     [107 executables]</code></pre></div></div><p>설치 방법은 <a href=\"https://github.com/anchore/syft?tab=readme-ov-file#installation\">Syft README</a>를 참고해주세요.테스트를 위해 Spring boot 3.2.1 + Web/MVC을 이용해 구성된 container를 배포해두었어요 (<a href=\"https://hub.docker.com/repository/docker/tree9295/sbom-test-spring/tags/0.0.1/sha256-3949abbe08c9b0c1a573e458d16267fe335496b572a6732ee2dece194c770197\">tree9295/sbom-test-spring</a>)만약 다른 format을 이용하고 싶다면, <code class=\"language-plaintext highlighter-rouge\">-o cyclonedx-json</code> 같이 output option으로 설정하시면 돼요.</p><p><br /></p><h3 id=\"결과-확인\">결과 확인</h3><p>위 결과로 만들어진 syft.sbom.json 파일을 살펴볼까요?</p><p>파일의 양이 많아 전체를 담지는 못했지만, 아래와 같이 사용된 라이브러리와 그 정보들을 담고 있는 것을 확인할 수 있어요.</p><p>여기서 알아야하는 것은 저희가 사용했다고 생각한 라이브러리(spring boot 등) 뿐 아니라 Container 이미지에서 사용하고 있는 기본 툴들에 대한 정보도 다 포함되어 있다는 거예요.</p><p><img alt=\"bom json\" src=\"https://github.com/user-attachments/assets/13a4158f-3960-401d-a669-73a2682ac9cb\" /></p><p><br /></p><h3 id=\"어떻게-만드는걸까요\">어떻게 만드는걸까요?</h3><p>이렇게 SBOM을 만들어보았는데요. 한 가지 궁금증이 들어요.</p><p>Syft 같은 SBOM 생성 툴들은 단순 Container image로 SBOM을 어떻게 만들 수 있었던 걸까요?</p><p><br /></p><p>아시다시피 Container image는 단순 애플리케이션이 아닌 애플리케이션을 실행하기 위한 환경도 포함하고 있어요.</p><p>이러한 모든 것들은 Container image 내 File system에 존재해요.</p><blockquote>  <p>가끔 Container image가 마법 같이 바로 애플리케이션을 실행시켜주는 단순 실행 프로그램으로 아시는 분들이 있어요. Container image는 애플리케이션과 그 실행에 필요한 모든 종속성을 포함하는 완전한 패키지예요. 오해하면 안 돼요.</p></blockquote><p><br /></p><p>Syft는 이걸 이용해요.</p><p>Container image 내 파일들을 스캔하고, 패키지 정보를 수집한 뒤 구조화된 SBOM 형태로 변환하여 사용자가 원하는 포맷으로 출력해요.</p><p>자세히는 Syft 내 Cataloger들이 stereoscope 라이브러리를 이용하여 image 내 파일들을 스캔하고 정보를 수집해요.</p><ul>  <li>이에 대한 자세한 내용은 <a href=\"https://github.com/anchore/syft/blob/main/DEVELOPING.md#architecture\">Syft Architecture</a>를 참고해주세요.</li>  <li>Syft는 binary 파일에 대해서도 분석을 수행해요 (<a href=\"https://anchore.com/blog/improve-open-source-sbom-tool-syft-with-binary-detection/\">Improving Syft’s Binary Detection</a>)</li></ul><p><br /></p><hr /><h2 id=\"sbom을-통해-보안취약점-분석하기\">SBOM을 통해 보안취약점 분석하기</h2><p>SBOM을 만들었다고 해볼까요? 그럼 보안 위험이 해결되는 걸까요?</p><p>당연히 아니에요. 이를 보고 이해하고 보안 위험 등 운영상의 문제가 있는 부분을 찾을 수 있는 툴이 필요해요.</p><p><br /></p><p>생성된 SBOM을 이용하여 보안 취약점을 분석하는 툴들도 여러가지 존재해요.</p><p>이 글에서는 Grype을 이용하여 분석해볼게요.</p><ul>  <li>https://github.com/anchore/grype</li>  <li>Grype는 Syft를 만든 anchore에서 만들었어요.</li>  <li>설치 방법은 <a href=\"https://github.com/anchore/grype?tab=readme-ov-file#installation\">Grype README</a>를 참고해주세요.</li></ul><p><br /></p><p>사실 Syft를 이용하여 SBOM을 만들지 않아도 Grype 내부에서 Syft를 이용하고 있어 SBOM을 만들고 바로 분석까지 수행이 가능해요.</p><ul>  <li>ex) <code class=\"language-plaintext highlighter-rouge\">grype tree9295/sbom-test-spring:0.0.1</code></li></ul><p><br /></p><p>하지만 저희는 만들어 둔 SBOM을 이용해볼게요.</p><p>앞선 예제로 사용했던 sbom-test-spring 이미지는 Spring boot 3.2.1을 이용하고 있어요.</p><p>해당 라이브러리는 spring web 6.1.2 버전을 이용하고 있는데요. 이 버전에서는 High 등급 3개의 보안 취약점이 발견되었어요.</p><ul>  <li><a href=\"https://ossindex.sonatype.org/component/pkg:maven/org.springframework/spring-web@6.1.2\">Spring web 6.1.2 Vulnerabilities</a></li>  <li><a href=\"https://spring.io/security\">Spring Security Advisories List</a></li></ul><p><br /></p><p>만든 SBOM을 Grype에서 분석하여 위 보안취약점이 검출되는지 확인해볼게요.</p><div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>$ grype syft.sbom.json ✔ Scanned for vulnerabilities     [12 vulnerability matches]   ├── by severity: 0 critical, 6 high, 4 medium, 0 low, 0 negligible (2 unknown)   └── by status:   12 fixed, 0 not-fixed, 0 ignoredNAME                    INSTALLED  FIXED-IN  TYPE          VULNERABILITY        SEVERITYlibcrypto3              3.3.2-r0   3.3.2-r1  apk           CVE-2024-9143        Unknownlibssl3                 3.3.2-r0   3.3.2-r1  apk           CVE-2024-9143        Unknown...spring-web              6.1.2      6.1.5     java-archive  GHSA-hgjh-9rj2-g67j  Highspring-web              6.1.2      6.1.4     java-archive  GHSA-ccgv-vj62-xf9h  Highspring-web              6.1.2      6.1.6     java-archive  GHSA-2wrp-6fg6-hmc5  Highspring-web              6.1.2      6.1.12    java-archive  GHSA-2rmj-mq67-h97g  Medium...</code></pre></div></div><p>위에서 보았던 것처럼 3개의 GHSA High 보안취약점이 확인되는 것을 볼 수 있어요.</p><ul>  <li>예상하지 못했던 컨테이너에 포함된 다양한 다른 보안취약점까지 확인되는 것을 볼 수 있어요.</li>  <li>GHSA는 Github에서 관리되는 보안 취약점 데이터베이스예요. CVE와 개념은 같은데, Github에 존재하는 프로젝트와 관련된 취약점에 초점을 맞춘 것이라고 이해하시면 돼요.</li></ul><p><br /></p><p>위 결과에서 알 수 있듯 단순 보안취약점 검출을 넘어</p><ul>  <li>어떤 타입인지</li>  <li>어떤 Vulnerability인지</li>  <li>그리고 제일 중요한 어떤 버전에서 fix 되었는지까지 다양한 정보를 보여줘요.</li></ul><p><br /></p><p>이렇게 분석된 결과를 바탕으로 보안 취약점 등 이슈를 보고하거나 수정해 나갈 수 있어요.</p><blockquote>  <p>각 보안취약점을 무조건 수정해야한다는 것은 아니에요.문제 발현조건들이 다 다를 수 있으니 위 리포트를 바탕으로 Vulnerability report를 보고 파악해보는 것이 중요해요.</p></blockquote><p><br /></p><hr /><h2 id=\"파이프라인-구성하기\">파이프라인 구성하기</h2><p>SBOM 생성과 분석이 포함된 파이프라인 구성은 인프라 구성상황에 따라 다르기에 여러 예시를 첨부하는 것으로 대신할게요.</p><p><br /></p><p>예시) <a href=\"https://www.infracloud.io/blogs/implement-devsecops-secure-ci-cd-pipeline/\">DevSecOps CI/CD</a></p><p><img alt=\"ex1\" src=\"https://github.com/user-attachments/assets/39f72cc4-6427-43f2-b786-94bdbc78fd77\" /></p><p><br /></p><p>예시) <a href=\"https://www.linkedin.com/pulse/empowering-cicd-github-actions-grype-tools-practical-guide-tor-zhowe/\">Grype를 이용한 Github action pipeline 구성</a></p><p><img alt=\"ex2\" src=\"https://github.com/user-attachments/assets/ee08fe68-ab9b-4739-a0ea-64a943bb71af\" /></p><p><br /></p><p>예시) <a href=\"https://anchore.com/sbom/creating-sbom-attestations-using-syft-and-sigstore/\">Syft SBOM, Sigstore 컨테이너 서명을 통한 SBOM 증명(attestation) 과정</a></p><p><img alt=\"ex3\" src=\"https://github.com/user-attachments/assets/89083854-0b37-41ba-9ea3-9a646ce08328\" /></p><p><br /></p><hr /><h2 id=\"결론\">결론</h2><p>이렇게 SBOM을 만들고, SBOM을 분석하여 보안 취약점을 파악해보았어요.</p><p>이는 어떻게 활용될 수 있을까요?</p><p><strong>CI/CD 및 정기적인 보안 프로세스에서 컨테이너 이미지에 대해 보안취약점, 부적격 라이센스 이용 등을 손쉽게 파악해볼 수 있을 거예요.</strong></p><p><br /></p><p>가끔 회사 공지 혹은 메일로 오는 것들을 생각해봐요. ‘XXX 취약점으로 인한 버전 확인 요청’, ‘XXX 소프트웨어 라이센스 변경으로 인한 이용 확인 요청’ 등 귀찮은 작업들이 수두룩 하지 않나요?</p><p>SBOM을 이용한다면 특정 버전을 사용하고 있는지도, 보안 취약점이 존재하는지도, 라이센스 문제가 있는지도 바로 파악이 가능할 거예요.</p><p>보안 부서 입장에서도, 플랫폼 운영 입장에서도, 소프트웨어를 직접 개발하는 개발자 입장에서도 아주 편리한 회사생활이 될 것 같네요 :-)</p><p><br /></p><p>여기까지 긴 글 읽어주셔서 감사합니다.</p><p><br /></p><hr /><h2 id=\"부록-끝내기는-아쉽지\">부록 (끝내기는 아쉽지)</h2><p>글을 작성하며, Spring boot를 주로 사용하는 개발자로서 <mark>\"Spring boot에서는 SBOM 생성을 지원하는게 없을까?\"</mark>를 중심으로 먼저 찾아보았었는데요.</p><p>이대로 간직하긴 아쉬워서 관련된 내용들은 부록으로나마 공유드릴게요.</p><p><br /></p><h3 id=\"spring-boot-33-actuator--cyclonedx-plugin\">Spring boot 3.3 actuator + CycloneDX plugin</h3><p>https://spring.io/blog/2024/05/24/sbom-support-in-spring-boot-3-3</p><p>Spring boot 3.3부터는 <mark>actuator를 통해 SBOM을 출력하는 엔드포인트를 제공</mark>하도록 업데이트 되었어요.</p><p>이를 위해서는 아래와 같은 구성이 필요해요.</p><ul>  <li>CycloneDX plugin 추가 =&gt; id(“org.cyclonedx.bom”) version “1.8.2”</li>  <li>Spring Web, Actuator 의존성 추가</li>  <li>Actuator SBOM 활성화 및 노출 property 설정</li></ul><p><br /></p><p>위 설정을 완료한 뒤 <code class=\"language-plaintext highlighter-rouge\">/actuator/sbom/application</code> endpoint에 접속하면 CycloneDX format의 SBOM이 노출된 것을 확인할 수 있어요.</p><p>이를 Grype를 통해 분석하고자 한다면, 아래와 같이 해볼 수 있어요.</p><div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>$ curl http://{host}/actuator/sbom/application | grype</code></pre></div></div><p><br /></p><h3 id=\"cloud-native-buildpacks-cnb\">Cloud Native Buildpacks (CNB)</h3><p>Spring boot에서는 CNB를 이용한 플러그인을 통해 손쉽게 Container image를 만들 수 있도록 지원하고 있어요.</p><p>ex) <code class=\"language-plaintext highlighter-rouge\">.gradlew bootBuildImage</code>이와 관련되어 아래 문서들을 참고해보면 좋아요.</p><ul>  <li><a href=\"https://docs.spring.io/spring-boot/gradle-plugin/packaging-oci-image.html\">https://docs.spring.io/spring-boot/gradle-plugin/packaging-oci-image.html</a></li>  <li><a href=\"https://docs.spring.io/spring-boot/reference/packaging/container-images/cloud-native-buildpacks.html\">https://docs.spring.io/spring-boot/reference/packaging/container-images/cloud-native-buildpacks.html</a></li>  <li><a href=\"https://github.com/paketo-buildpacks/spring-boot\">https://github.com/paketo-buildpacks/spring-boot</a></li>  <li><a href=\"https://buildpacks.io/\">https://buildpacks.io/</a></li></ul><p><br /></p><p>이 때 CNB를 이용한 빌드 과정에서 syft가 사용되는 것을 볼 수 있어요.</p><div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>$ ./gradlew bootBuildImage...    [creator]     paketo-buildpacks/syft              2.3.1...    [creator]     Paketo Buildpack for Syft 2.3.1    [creator]       https://github.com/paketo-buildpacks/syft...</code></pre></div></div><p><br /></p><p>Container Image를 확인해보면, <code class=\"language-plaintext highlighter-rouge\">/layers/sbom/launch</code> 디렉토리 아래에 빌드 과정에서 만들어진 SBOM 목록이 존재하는 것을 볼 수 있죠.</p><div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>$ find /layers/sbom/launch -name \"*.json\"/layers/sbom/launch/buildpacksio_lifecycle/launcher/sbom.cdx.json/layers/sbom/launch/buildpacksio_lifecycle/launcher/sbom.spdx.json/layers/sbom/launch/buildpacksio_lifecycle/launcher/sbom.syft.json/layers/sbom/launch/paketo-buildpacks_bellsoft-liberica/helper/sbom.syft.json/layers/sbom/launch/paketo-buildpacks_bellsoft-liberica/jre/sbom.syft.json/layers/sbom/launch/paketo-buildpacks_ca-certificates/helper/sbom.syft.json/layers/sbom/launch/paketo-buildpacks_executable-jar/sbom.cdx.json/layers/sbom/launch/paketo-buildpacks_executable-jar/sbom.syft.json/layers/sbom/launch/paketo-buildpacks_spring-boot/helper/sbom.syft.json/layers/sbom/launch/paketo-buildpacks_spring-boot/spring-cloud-bindings/sbom.syft.json/layers/sbom/launch/sbom.legacy.json</code></pre></div></div><p><br /></p><p>Buildpack을 이용해 빌드 과정에서 활용되는 라이브러리, 애플리케이션에서 사용되는 라이브러리 등 전체적으로 사용되는 모든 소프트웨어 구성요소를 SBOM로 구성해두고 있는 것을 볼 수 있어요.</p><ul>  <li>Paketo Buildpack 문서를 보면 이에 대해 더 자세히 설명하고 있어요.    <ul>      <li><a href=\"https://paketo.io/docs/concepts/sbom/\">Paketo buildpack - SBOM</a></li>      <li><a href=\"https://paketo.io/docs/howto/sbom/\">Paketo buildpack - How to access the SBOM</a></li>    </ul>  </li></ul><p><br /></p><p>Syft를 통해 해당 이미지를 분석해보면, 위 SBOM 파일들도 분석 대상에 포함되어 전체적인 하나의 SBOM 파일을 만들 것으로 예상돼요.</p>",
            "url": "https://kimdoubleb.github.io/news/2024/10/29/sbom",
            
            
            
            "tags": ["security,","SBOM,","opensource,","docker,","vulnerability,","syft,","grype,","spring"],
            
            "date_published": "2024-10-29T00:00:00+09:00",
            "date_modified": "2024-10-29T00:00:00+09:00",
            
                "author":  {
                "name": "KimDoubleB",
                "url": null,
                "avatar": null
                }
                
            
        },
    
        {
            "id": "https://kimdoubleb.github.io/news/2023/05/14/4-news",
            "title": "Monolith vs MSA 아키텍처 / 오픈소스 생태계 / Transactional Outbox 패턴",
            "summary": "Monolith와 MSA 선택 기준, 오픈소스 개발자를 위한 tea 프로젝트, PostgreSQL Transactional Outbox 패턴",
            "content_text": "한 주마다 뉴스를 적고자 했는데, 이직을 준비하고 직접 하면서 시간이 훌쩍 지나버렸다.어느 덧 이전 뉴스를 적은지 8개월. 8개월 전하고 지금의 상황과 마음은 참 많이 달라져있다.기술도 그렇고, 현재 내 상황과 느끼는 부분들도 그렇고.8개월 전 당시는 지금의 모습이 행복할거라 예상했겠지만(?), 막상 그렇진 않다.이것도 경험이겠지 하면서 살아가고 있다.더 많은 도전과 경험, 성장을 위해 뉴스를 다시 작성하기 시작! 4 번째 뉴스 시작!Monolith냐, MSA냐. 그것이 문제로다.(Link) Monoliths are not dinosaurs요즘 해외에서는 다시 ‘Monolith냐 MSA냐’에 불이 붙는 것 같다.그 시작은 아마존 프라임 모니터링 서비스를 모놀리스로 다시 재전환하면서 비용을 90%까지 절약할 수 있었다는 글이었다. 여러 AWS Lambda와 AWS Step Function으로 구성되어진 아키텍처를 ECS task로 넘어가며 비용을 줄였다는 이야기이다 (깊게 읽어보진 않음).  위 글을 읽고 Monolith Follower들은 ‘봐봐, 역시 Monolith가 더 좋은 경우가 많지.’라고 말하는게 참 보기 안좋다. 뒤에 설명하겠지만, 무조건 적으로 좋은게 어디있겠는가. (MSA를 해보기나 했을까?)Monolith와 MSA는 언제나 의견차이를 불러오는 주제이다. 내가 생각한 그 이유는 ‘상황에 따라 적합한 것’이 다르기 때문이다.여러 도메인, 바운디드 컨텍스트가 나뉘고, 관리하는 팀이 분리되며 배포주기가 다른 서비스들이라면 MSA가 적합할 수 있고(이것 또한 무조건 적인 것이 아님), 하나의 팀 서비스면서 서로 연관되어 배포되는 서비스라면 Monolith가 적합할 수 있을 것이다.중요한 것은 무조건 적인 것은 없다인데, Amazon CTO가 쓴 Monoliths are not dinosaurs 글이 그것을 잘 설명해주고 있다.사실 프로젝트가 커가면서 위와 같은 상황은 달라질 수 있다. 처음은 Monolith가 적합하다가도, 프로젝트가 커져감에 따라 MSA가 적합할 수 있기 때문.그렇기에 설계부터 진화 가능한 아키텍처를 생각해야하고(아키텍처가 변경될 것을 대비), 서비스가 성장할 때마다 아키텍처를 재검토하고 다음 단계 성장을 지원할 수 있는지 확인해야한다. 즉, 구조적으로도 리팩토링하는 시간이 필요하다는 것이다.진화 가능한 아키텍처(Evolvable Architecture)를 하기 위해서는 어떻게 해야할까? 시스템의 진화를 고려해 최소한의 종속성으로 시스템을 변경하고 확장할 수 있는 기반을 마련하는 것이 좋다.  이벤트 중심 아키텍처(EDA), MSA 등이 이러한 사례가 될 수 있겠다.  Amazon S3가 진화 가능한 아키텍처의 사례라고 한다. 결국 MSA 였는데, 몇 개의 마이크로서비스에서 시작해 현재는 300개 이상의 마이크로서비스로 관리된다고 한다.하지만 그 과정 속에서 서비스 요구사항이 동일하고, 단일 팀에서 관리하는 서비스라면 결합해 아키텍처를 간소화하는 것이 좋다. 비용적이면에서나 관리측면에서나.  개발자가 5명인 스타트업(소규모팀)에서 EDA/MSA가 적합할 수 있을까? 관리할 컴포넌트는 증가하고, 개발은 다 따로 해야하는 것이 번거로움이 될 수 있다는 것.결론적으로 요약하자면,  아키텍처에는 일방통행이 없다.  시스템을 정기적으로 평가하고, 상황에 맞게 리팩토링하는 것이 중요하다.한 팀에, 한 서비스에 오래 있다보면 새로운 것들에 대해 경계심이 생긴다. 이럴 때, 다른 것들을 무시하지말고 현재 자신의 상황에 적합한지도 살펴보고 어떤 게 어떨 때 적합한지도 생각해보고 할 필요가 있다고 생각한다.오픈소스 개발자를 위한 프로젝트(Link) Something new is brewingMac에서 개발 할 때, Brew를 사용해서 패키징 관리를 하곤 한다.보통 오픈소스 프로젝트/서비스를 사용할 때 기본적으로 활용하는데, 그 이유는 ‘편리함’이 크기 때문이다.하지만 사용하면서 누가 만들었고, 어떻게 운영되는지는 관심이 별로 없었는데 이 글을 읽으면서 처음 알게되었다.Brew를 만들었던 Max Howell은 현재는 Brew를 커뮤니티에 맡기고 tea라는 프로젝트를 시작했다.Brew에서 손을 땔 때는 Brew 자체가 훌륭하다고 생각해서 Brew2는 만들지 않을 것이라고 했는데, 어쩌다가 tea 프로젝트를 만들게 되었는지 설명하고 있다.최근 core-js 이야기도 그렇고 오픈소스 개발자들이 오픈소스로만으로는 삶을 감당할 수 없다고 한다. core-js 같은 경우 정말 많은 프레임워크/서비스의 근간이 되는 오픈소스이지만, 막상 개발자는 경제적으로 홀대받고 있는 것이다.결국엔 이렇게 되면 해당 오픈소스는 제대로 개발될 수 없게 되고 악영향이 발생할 수 있다(메인테이너는 그냥 자원봉사자가 되는 격). 이러한 문제가 커져 발생할 수 있는 문제를 The Nebraska Problem라고 한다 (실제로 Log4J, NPM 등에서 발생한 문제들이 있다).Brew에서도 마찬가지였다. Brew 또한 오픈소스였고, 이를 통해 여러 오픈소스를 다운로드/사용할 수 있었기 때문.Max Howell는 이러한 부정적인 고리를 어떻게 풀어낼까 고민하던 중 블록체인과 Web3에서 이 방법을 찾았고, 오픈소스 유지관리자가 마땅한 보상을 받을 수 있는 서비스인 tea를 개발하게 된 것이다.사실 블록체인, Web3는 잘 알지 못해서 이와 관련된 내용은 이해하지 못했으나, 블록체인이라는 기술을 통해 긍정적인 영향을 만들어낼 수 있다는 것은 참 좋은 아이디어 같다.개발자의 삶 속에서는 오픈소스를 빼놓지 못할텐데 사실 그 개발자(메인테이너)들에게 합당한 보상을 해주고 있는가? 라는 궁금증과 오픈소스인데 보상이 필요한가?라는 이기적인 생각도 들기도 한다.어찌됬든, tea 같은 프로젝트를 통해 사용자들로 하여금 보상을 받으면 오픈소스 생태계가 더 활성화 될 것 이라는 건 자명한 것 같다. 이런 프로젝트들이 많이 나왔으면 좋겠다.Transactional outboxing(Link) Transactional outboxing with Postgres push notifications위 글에서는 Transactional Outbox pattern을 PostgreSQL과 Spring boot 3.x에서 구현하는 법에 대해 설명한다.먼저 간단하게 Transactional Outbox pattern을 설명하고 있는데 간단히 설명하면 DB 변경과 이벤트 발행(Publishing)을 하나의 Transaction(트랜잭션) 안에서 동작하기 위한 방법이라고 볼 수 있다.  이는 MSA 구조의 DDD 같은 곳에서 도메인 이벤트를 발생하여 다른 컴포넌트에서 해당 이벤트로 하여금 트리거시키고 싶은 경우 등에 활용할 수 있다.그냥 @Trasnactional 걸고, DB 데이터 넣으면서 이벤트 발생시키면 안돼? 라고 할 수 있지만, Message broker에는 Database transaction을 함께 사용하지 못한다는 문제가 있다.데이터 변경은 성공했지만 이벤트 발행은 실패하거나, 반대로 이벤트 발행은 성공했으나 데이터 변경은 실패하는 경우가 발생할 수 있다. 즉, 데이터의 일관성이 깨질 수 있다는 것.  이러한 문제를 해결하기 위한 방법으로 Transaction Outbox pattern이 사용된다. MQ의 역할로서 Database table을 이용하자는 것이다.  Message broker에 이벤트를 발행하는 대신 OUTBOX DB table에 메시지 관련 데이터들을 저장한다. 별도의 Message Relay가 OUTBOX table을 폴링하면서 이벤트 데이터를 읽어 Message broker로 발행한다.  얼마나 자주 폴링하는가에 따라 데이터 변경과 이벤트 발행의 시차가 발생할 수는 있지만, 결과적으로 일관성(Eventual Consistency)은 유지할 수 있다. (참조: MSA에서 메시징 트랜잭션 처리하기)PostgreSQL에서는 LISTEN, NOTIFY 매커니즘을 통해 데이터베이스 연결 전반에 비동기적으로 메시지를 전달할 수 있는 기능을 제공한다.Spring integration에서 JdbcChannelMessageStore, PostgresChannelMessageTableSubsriber를 통해 이 푸시알림들을 받을 수 있도록 지원하는 것 같다.이를 통해 번거롭게 특정 테이블을 폴링하는 로직을 작성하지 않아도, 손쉽게 Listener(Message Relay)를 구현하고, Transactional Outbox Pattern을 구현할 수 있다.",
            "content_html": "<p>한 주마다 뉴스를 적고자 했는데, 이직을 준비하고 직접 하면서 시간이 훌쩍 지나버렸다.</p><p>어느 덧 이전 뉴스를 적은지 8개월. 8개월 전하고 지금의 상황과 마음은 참 많이 달라져있다.</p><p>기술도 그렇고, 현재 내 상황과 느끼는 부분들도 그렇고.</p><p>8개월 전 당시는 지금의 모습이 행복할거라 예상했겠지만(?), 막상 그렇진 않다.이것도 경험이겠지 하면서 살아가고 있다.</p><p>더 많은 도전과 경험, 성장을 위해 뉴스를 다시 작성하기 시작! 4 번째 뉴스 시작!</p><p><br /></p><hr /><h1 id=\"monolith냐-msa냐-그것이-문제로다\">Monolith냐, MSA냐. 그것이 문제로다.</h1><p><a href=\"https://www.allthingsdistributed.com/2023/05/monoliths-are-not-dinosaurs.html\">(Link) Monoliths are not dinosaurs</a></p><p>요즘 해외에서는 다시 ‘Monolith냐 MSA냐’에 불이 붙는 것 같다.</p><p>그 시작은 <a href=\"https://www.primevideotech.com/video-streaming/scaling-up-the-prime-video-audio-video-monitoring-service-and-reducing-costs-by-90\">아마존 프라임 모니터링 서비스를 모놀리스로 다시 재전환하면서 비용을 90%까지 절약할 수 있었다는 글</a>이었다. 여러 AWS Lambda와 AWS Step Function으로 구성되어진 아키텍처를 ECS task로 넘어가며 비용을 줄였다는 이야기이다 (깊게 읽어보진 않음).</p><ul>  <li>위 글을 읽고 Monolith Follower들은 ‘봐봐, 역시 Monolith가 더 좋은 경우가 많지.’라고 말하는게 참 보기 안좋다. 뒤에 설명하겠지만, 무조건 적으로 좋은게 어디있겠는가. (MSA를 해보기나 했을까?)</li></ul><p><br /></p><p>Monolith와 MSA는 언제나 의견차이를 불러오는 주제이다. 내가 생각한 그 이유는 ‘상황에 따라 적합한 것’이 다르기 때문이다.</p><p>여러 도메인, 바운디드 컨텍스트가 나뉘고, 관리하는 팀이 분리되며 배포주기가 다른 서비스들이라면 MSA가 적합할 수 있고(이것 또한 무조건 적인 것이 아님), 하나의 팀 서비스면서 서로 연관되어 배포되는 서비스라면 Monolith가 적합할 수 있을 것이다.</p><p><br /></p><p>중요한 것은 무조건 적인 것은 없다인데, Amazon CTO가 쓴 <code class=\"language-plaintext highlighter-rouge\">Monoliths are not dinosaurs</code> 글이 그것을 잘 설명해주고 있다.</p><p>사실 프로젝트가 커가면서 위와 같은 상황은 달라질 수 있다. 처음은 Monolith가 적합하다가도, 프로젝트가 커져감에 따라 MSA가 적합할 수 있기 때문.</p><p>그렇기에 설계부터 진화 가능한 아키텍처를 생각해야하고(아키텍처가 변경될 것을 대비), 서비스가 성장할 때마다 아키텍처를 재검토하고 다음 단계 성장을 지원할 수 있는지 확인해야한다. 즉, 구조적으로도 리팩토링하는 시간이 필요하다는 것이다.</p><p><br /></p><p><code class=\"language-plaintext highlighter-rouge\">진화 가능한 아키텍처(Evolvable Architecture)</code>를 하기 위해서는 어떻게 해야할까? 시스템의 진화를 고려해 최소한의 종속성으로 시스템을 변경하고 확장할 수 있는 기반을 마련하는 것이 좋다.</p><ul>  <li>이벤트 중심 아키텍처(EDA), MSA 등이 이러한 사례가 될 수 있겠다.</li>  <li>Amazon S3가 진화 가능한 아키텍처의 사례라고 한다. 결국 MSA 였는데, 몇 개의 마이크로서비스에서 시작해 현재는 300개 이상의 마이크로서비스로 관리된다고 한다.</li></ul><p><br /></p><p>하지만 그 과정 속에서 서비스 요구사항이 동일하고, 단일 팀에서 관리하는 서비스라면 결합해 아키텍처를 간소화하는 것이 좋다. 비용적이면에서나 관리측면에서나.</p><ul>  <li>개발자가 5명인 스타트업(소규모팀)에서 EDA/MSA가 적합할 수 있을까? 관리할 컴포넌트는 증가하고, 개발은 다 따로 해야하는 것이 번거로움이 될 수 있다는 것.</li></ul><p><br /></p><p>결론적으로 요약하자면,</p><ul>  <li>아키텍처에는 일방통행이 없다.</li>  <li>시스템을 정기적으로 평가하고, 상황에 맞게 리팩토링하는 것이 중요하다.</li></ul><p>한 팀에, 한 서비스에 오래 있다보면 새로운 것들에 대해 경계심이 생긴다. 이럴 때, 다른 것들을 무시하지말고 현재 자신의 상황에 적합한지도 살펴보고 어떤 게 어떨 때 적합한지도 생각해보고 할 필요가 있다고 생각한다.</p><p><br /></p><hr /><h1 id=\"오픈소스-개발자를-위한-프로젝트\">오픈소스 개발자를 위한 프로젝트</h1><p><a href=\"https://medium.com/teaxyz/tea-brew-478a9e736638\">(Link) Something new is brewing</a></p><p>Mac에서 개발 할 때, Brew를 사용해서 패키징 관리를 하곤 한다.보통 오픈소스 프로젝트/서비스를 사용할 때 기본적으로 활용하는데, 그 이유는 ‘편리함’이 크기 때문이다.</p><p>하지만 사용하면서 누가 만들었고, 어떻게 운영되는지는 관심이 별로 없었는데 이 글을 읽으면서 처음 알게되었다.</p><p>Brew를 만들었던 Max Howell은 현재는 Brew를 커뮤니티에 맡기고 tea라는 프로젝트를 시작했다.Brew에서 손을 땔 때는 Brew 자체가 훌륭하다고 생각해서 Brew2는 만들지 않을 것이라고 했는데, 어쩌다가 tea 프로젝트를 만들게 되었는지 설명하고 있다.</p><p><br /></p><p>최근 <a href=\"https://github.com/zloirock/core-js/blob/master/docs/2023-02-14-so-whats-next.md\">core-js 이야기</a>도 그렇고 오픈소스 개발자들이 오픈소스로만으로는 삶을 감당할 수 없다고 한다. core-js 같은 경우 정말 많은 프레임워크/서비스의 근간이 되는 오픈소스이지만, 막상 개발자는 경제적으로 홀대받고 있는 것이다.</p><p>결국엔 이렇게 되면 해당 오픈소스는 제대로 개발될 수 없게 되고 악영향이 발생할 수 있다(메인테이너는 그냥 자원봉사자가 되는 격). 이러한 문제가 커져 발생할 수 있는 문제를 <a href=\"https://www.researchgate.net/publication/364539939_The_Nebraska_problem_in_open_source_software_development\">The Nebraska Problem</a>라고 한다 (실제로 Log4J, NPM 등에서 발생한 문제들이 있다).</p><p>Brew에서도 마찬가지였다. Brew 또한 오픈소스였고, 이를 통해 여러 오픈소스를 다운로드/사용할 수 있었기 때문.</p><p><br /></p><p>Max Howell는 이러한 부정적인 고리를 어떻게 풀어낼까 고민하던 중 블록체인과 Web3에서 이 방법을 찾았고, 오픈소스 유지관리자가 마땅한 보상을 받을 수 있는 서비스인 tea를 개발하게 된 것이다.</p><p>사실 블록체인, Web3는 잘 알지 못해서 이와 관련된 내용은 이해하지 못했으나, 블록체인이라는 기술을 통해 긍정적인 영향을 만들어낼 수 있다는 것은 참 좋은 아이디어 같다.</p><p>개발자의 삶 속에서는 오픈소스를 빼놓지 못할텐데 사실 그 개발자(메인테이너)들에게 합당한 보상을 해주고 있는가? 라는 궁금증과 오픈소스인데 보상이 필요한가?라는 이기적인 생각도 들기도 한다.</p><p>어찌됬든, tea 같은 프로젝트를 통해 사용자들로 하여금 보상을 받으면 오픈소스 생태계가 더 활성화 될 것 이라는 건 자명한 것 같다. 이런 프로젝트들이 많이 나왔으면 좋겠다.</p><p><br /></p><hr /><h1 id=\"transactional-outboxing\">Transactional outboxing</h1><p><a href=\"https://medium.com/@lombos.monika/transactional-outboxing-with-postgres-push-notifications-5cebdad893fd\">(Link) Transactional outboxing with Postgres push notifications</a></p><p>위 글에서는 Transactional Outbox pattern을 PostgreSQL과 Spring boot 3.x에서 구현하는 법에 대해 설명한다.</p><p><br /></p><p>먼저 간단하게 <strong>Transactional Outbox pattern</strong>을 설명하고 있는데 간단히 설명하면 DB 변경과 이벤트 발행(Publishing)을 하나의 Transaction(트랜잭션) 안에서 동작하기 위한 방법이라고 볼 수 있다.</p><ul>  <li>이는 MSA 구조의 DDD 같은 곳에서 도메인 이벤트를 발생하여 다른 컴포넌트에서 해당 이벤트로 하여금 트리거시키고 싶은 경우 등에 활용할 수 있다.</li></ul><p><br /></p><p>그냥 <code class=\"language-plaintext highlighter-rouge\">@Trasnactional</code> 걸고, DB 데이터 넣으면서 이벤트 발생시키면 안돼? 라고 할 수 있지만, Message broker에는 Database transaction을 함께 사용하지 못한다는 문제가 있다.</p><p><strong>데이터 변경은 성공했지만 이벤트 발행은 실패하거나, 반대로 이벤트 발행은 성공했으나 데이터 변경은 실패하는 경우가 발생할 수 있다. 즉, 데이터의 일관성이 깨질 수 있다는 것.</strong></p><ul>  <li>이러한 문제를 해결하기 위한 방법으로 <strong>Transaction Outbox pattern이 사용</strong>된다. MQ의 역할로서 Database table을 이용하자는 것이다.</li>  <li>Message broker에 이벤트를 발행하는 대신 <code class=\"language-plaintext highlighter-rouge\">OUTBOX</code> DB table에 메시지 관련 데이터들을 저장한다. 별도의 Message Relay가 <code class=\"language-plaintext highlighter-rouge\">OUTBOX</code> table을 폴링하면서 이벤트 데이터를 읽어 Message broker로 발행한다.</li>  <li>얼마나 자주 폴링하는가에 따라 데이터 변경과 이벤트 발행의 시차가 발생할 수는 있지만, 결과적으로 일관성(Eventual Consistency)은 유지할 수 있다. (참조: <a href=\"https://www.popit.kr/msa%EC%97%90%EC%84%9C-%EB%A9%94%EC%8B%9C%EC%A7%95-%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98-%EC%B2%98%EB%A6%AC%ED%95%98%EA%B8%B0/\">MSA에서 메시징 트랜잭션 처리하기</a>)</li></ul><p><br /></p><p>PostgreSQL에서는 <code class=\"language-plaintext highlighter-rouge\">LISTEN</code>, <code class=\"language-plaintext highlighter-rouge\">NOTIFY</code> 매커니즘을 통해 데이터베이스 연결 전반에 비동기적으로 메시지를 전달할 수 있는 기능을 제공한다.</p><p>Spring integration에서 <code class=\"language-plaintext highlighter-rouge\">JdbcChannelMessageStore</code>, <code class=\"language-plaintext highlighter-rouge\">PostgresChannelMessageTableSubsriber</code>를 통해 이 푸시알림들을 받을 수 있도록 지원하는 것 같다.</p><p><img src=\"https://github.com/KimDoubleB/news/assets/37873745/e733059d-3f64-4b61-9892-7158e983570d\" alt=\"image\" /></p><p>이를 통해 번거롭게 특정 테이블을 폴링하는 로직을 작성하지 않아도, 손쉽게 Listener(Message Relay)를 구현하고, Transactional Outbox Pattern을 구현할 수 있다.</p><p><br /></p>",
            "url": "https://kimdoubleb.github.io/news/2023/05/14/4-news",
            
            
            
            "tags": ["monolith,","msa,","architecture,","aws,","opensource,","brew,","transactional-outboxing,","postgreSQL,","spring,","event,","message,","transaction"],
            
            "date_published": "2023-05-14T00:00:00+09:00",
            "date_modified": "2023-05-14T00:00:00+09:00",
            
                "author":  {
                "name": "KimDoubleB",
                "url": null,
                "avatar": null
                }
                
            
        },
    
        {
            "id": "https://kimdoubleb.github.io/news/2022/09/25/3-news",
            "title": "R2DBC Pagination / Stream 성능 / 비밀번호 암호화",
            "summary": "Spring data r2dbc pagination 구현, Java Stream vs for-loop 성능 비교, 비밀번호 Hash/Salt 암호화",
            "content_text": "가을이 오고 있다.올해도 어느덧 다 지나가고 있는 것 같다.더 뿌듯한, 자랑스러운 올해를 만들기 위해 노력해야지.그럼, 내 생일이기도 한 오늘의 뉴스도 시작.Spring data r2dbc pagination(Link) Spring data r2dbc pagination example최근 r2dbc, Spring data r2dbc를 사용하고 있다.JPA와 여러가지 차이가 있지만, 그래도 Spring data 측에서 Spring data jpa처럼 유사하게 제공을 하고 있어  사용하는 측면에서는 비슷하게 다룰 수 있다. (JPA와 차이에 대한 내용은 제 블로그 글 참조)근데 하나 차이가 있다면, Page 인터페이스이다.Spring data jpa를 사용한다면 Pageable 사용 시 다음과 같이 사용할 수 있다.public interface SomeRepository extends JpaRepository&lt;Some, Long&gt; {    Page&lt;Some&gt; findAllBy(Pageable pageable);}하지만 R2dbc의 경우, 이렇게 사용할 수 없다. Mono, Flux로 타입이 제한되기 때문이다.즉, 2개 이상의 데이터의 경우 Page, List가 아닌 Flux로 반환된다.public interface SomeRepository extends R2dbcRepository&lt;Some, Long&gt; {    Flux&lt;Some&gt; findAllBy(Pageable pageable);    Mono&lt;Page&lt;Some&gt;&gt; findAllBy(Pageable pageable); // 불가능    Flux&lt;Page&lt;Some&gt;&gt; findAllBy(Pageable pageable); // 불가능}위 R2dbc 예시에서 Parameter로 전달되는 Pageable 인터페이스(PageRequest 구현체)를 통해 Pagination은 구현은 잘 될 수 있다.근데 Page 타입을 사용한다는 것은 Page 정보(Page size, Page number 등)가 필요해 사용하는 경우가 많은데, 위에서는 그 정보를 받을 수 없다.그럼, 이 정보를 어떻게 얻을 수 있을까?그 해답은 count 쿼리를 수동으로 구성하고, 이를 사용해 PageImpl 인스턴스를 직접 만들어 반환하는 방법이다.@Servicepublic class ProductService {    @Autowired    private ProductRepository productRepository;    public Mono&lt;Page&lt;Product&gt;&gt; getProducts(PageRequest pageRequest){        return productRepository.findAllBy(pageRequest))                .collectList()                .zipWith(this.productRepository.count())                .map(t -&gt; new PageImpl&lt;&gt;(t.getT1(), pageRequest, t.getT2()));    }}  이렇게 구성하면, Mono&lt;Page&lt;Product&gt;&gt;를 반환할 수 있게 되어 Page 정보들을 반환할 수 있게 된다.참고로, 위 코드는 Transactional annotation이 붙지 않았다. 만약 붙이게 되면 오류가 발생할 수 있다.Transactional annotation이 붙으면 내부에서 하나의 Database connection을 사용하게 되고 zipWith는 병렬로 수행되기 때문에,  findAllBy 쿼리와 count 쿼리가 하나의 Connection에서 동시에 실행될 수 있기 때문이다.그러므로 Transactional 문제를 해결하기 위해서는 zipWith가 아닌 flatMap 같은 순차적으로 연산이 동작할 수 있게 구성하거나, 새로운 메서드로 만들어 Transacitonal propagation(전파) 속성을 이용해 새로운 Transaction 내에서 동작(REQUIRES_NEW)하도록 구성해야 한다. (새로운 메서드로 구성 시에는 self invocation 문제를 조심하자)Java Stream API는 왜 for-loop보다 느릴까?(Link) The Performance Model of Streams in Java 8(Link) 번역 및 해설 - Java Stream API는 왜 for-loop보다 느릴까?Java로 개발할 때, 거의 대부분 For loop 대신 Stream을 활용해 구성한다.선언식과 또 여러 함수형 메서드를 연결 지을 수 있다는 점, 코드가 간결해지고 사이드 이펙트를 방지할 수 있다는 점 등 장점이 엄청 많기 때문이다.근데 저 글에서 나와있듯 알고리즘 문제를 푸는 것에서는 손이 안가게 된다.나는 2가지 이유였다.  알고리즘 문제의 경우, loop 내에서 외부 값을 변경해야할 일이 많다. Stream Pipeline 상에서 값을 계속 주고받기에는 너무 복잡해진다.  for loop보다 느리게 동작한다. 결과 성공시간만 봐도 그렇다.2번째 이유에 대해 항상 궁금했었는데 찾아보다가 위 글을 보게 되었고, 엄청 재미있게 읽었다.처음에 primitive type int 배열 중 최대 값을 구하는 작업을 비교하는데 for loop가 Stream보다 15배 정도 빠르게 동작한다.  JIT compiler가 for loop에 대해 optimization이 잘되어 있기 때문 (즉, Compilation tier가 높게 잡혀 기계어로 동작하게 됨을 의미한다).Wrapped class인 Integer와 ArrayList를 사용하면 어떨까? for loop 성능이 엄청나게 느려진다. 그래도 Stream보다는 빠르다. 하지만 Stream과 차이가 1.27배 정도 밖에 나지 않는다.Integer class를 사용하면서 ArrayList를 활용하게 되었는데, 이를 순회하는 것은 매우 비싸기 때문이라고 한다. 어찌되었든 Wrapped class를 다루게되고, 이는 Stack이 아닌 Heap에 저장되게 된다.즉, Primitive type은 Stack에서 바로 접근해서 실제 내용을 가져올 수 있는 반면 Wrapped class는 Heap까지 가서 데이터를 찾아와야 하므로 성능에 영향을 주었다고 이야기한다.Loop 중 아주 비싼 연산(시간복잡도가 큰 작업)을 하게되면 어떻게 될까? 성능에 더 차이가 없게 된다.그 이유에 대해서는 자세히 나오지는 않는데, JIT Compiler의 최적화와 for loop을 구성하는데 부가적인 연산들이 들어가기 때문이라고 추측했다.결론적으로 '순회비용'과 '연산비용'이 큰 상황에서는 Stream과 For loop의 성능차이가 크지 않고, 만약 '순회비용'과 '연산비용'이 적다면 For loop 성능이 더 우수하다.  (사견) 성능이 중요한 애플리케이션이라면 이런 것들을 고려해야할 것이지만, 그런 것이 아니라면 사실 유지보수성을 위해 Stream을 활용하는 편이 좋지 않을까 싶다.병렬 스트림과 비교하는 부분도 있는데, 포크 조인 풀 및 어떤 상황에서 활용하는지 등에 대한 내용이 있는데 참고하면 좋을 것 같다.비밀번호 암호화 - Hash, Salt(Link) Adding Salt to Hashing: A Better Way to Store Passwords(Link) 패스워드의 암호화와 저장보안이라고는 학부 수준에서 학습했던 것 밖에 없어 계속 까먹게 된다.최근 Salt에 대한 이야기를 나눌 기회가 있었는데, ‘이전 프로젝트에서 다뤘었고 암호에 랜덤한 값을 추가한다’라는 이야기만 할 수 있었다.다시 볼 때가 되었구나 싶어 찾아보게 되었고, 잘 정리된 글이 있어서 보면서 다시 리마인드 했다.보통 비밀번호를 저장할 때 SHA-256 같은 단방향 해시함수를 통해 나온 결과를 저장한다. 이 때 이 결과를 다이제스트(digest)라고 한다.단방향 해시함수는 복호화가 불가능하기 때문에 추후 인증 과정에 들어온 값의 다이제스트과 저장한 다이제스트를 비교하여 인증 성공여부를 결정한다.그러면 이것만으로도 안전한 것 아닐까? 해시 값은 유출되더라도 복호화가 되지 않으니?라고 할 수 있지만, 실상은 그렇지 않다고 한다.왜냐하면 많이 사용되는 단방향 알고리즘에 대해서 다양한 문자열 비밀번호들에 대한 다이제스트를 모아놓는 ‘레인보우 테이블’들이 존재하고, 이를 활용해 비밀번호를 유추해볼 수 있기 때문이다.또한 이 뿐만 아니라 브루트포스 방식을 통해 비밀번호를 맞춰보려고 하는데, 단순한 해시함수를 사용한다면 적은 시간 내 더 많은 해시함수를 돌려서 비밀번호를 유추해볼 수 있으므로 해커에게 좋은 상황이 될 수 있다.그러면 이러한 문제를 해결하기 위해 어떠한 방법을 사용할까?글에서는 2가지 방법이 소개되었는데 Key stretching과 Salt이다. 또한, 이 둘을 혼합해 활용할 수도 있다.Key Stretching은 단방향 해시함수를 단 한 번 실행하는 것이 아니라 N번 수행하는 것이다.해시함수를 사용한 결과물에 대해 다시 해시함수를 적용하면서 기존 Plain 비밀번호를 더 숨키고자 하는 것이다.이를 사용하면 위에서 언급했던 레인보우 테이블에서 비밀번호를 유추하기 어려워지고, 해커 입장에서 브루트포스를 하는데 더 많은 연산이 들어가게 되어 많은 시간이 걸리게 만들 수 있다.하지만 레인보우 테이블에서도 특정 다이제스트에 대해 몇 번 해시함수를 수행하였는가까지 기록하고 있는 경우가 많다고 한다. 즉, N 번 실행하였어도 그 결과에 대한 원문을 유추해볼 수 있는 것이다.그리고 추가적인 문제가 있는데, 여러 사이트들이 다 같은 단방향 해시함수를 사용하고 있는 상황에서 유저가 여러 사이트에 대해 다 같은 비밀번호를 사용하고 있을 경우, 한 사이트에서 비밀번호가 유출되버리면 모든 사이트에 대해서도 유출된 것과 마찬가지가 되어버린다.이런 문제를 막기 위해 등장한 것이 Salt이다. 비밀번호에 특정 무작위한 문자열을 더해 기존 비밀번호에 복잡성/무작위성을 더하는 것이다 (음식에 소금치듯 말이다). Salt를 더한 비밀번호를 해시함수를 통해 암호화해서 저장하게 된다.특정 유저에 대해 Salt를 생성해 활용하는 과정에서 유저의 정보에 Salt도 저장해야만 한다. 추후 비밀번호 인증 시에도 Salt를 더해 인증해야하기 때문이다.결국, 이러한 Salt는 운영되는 사이트마다 다를 수 밖에 없고 한 사이트에서 다이제스트가 유출되어도 다른 사이트에서는 다 다르게 구성되어서 유추하기 더 어려워질 것이다. 또한 레인보우 테이블에서 원본 값이 찾아졌어도 Salt가 더해져있는 값이기에 Salt까지 알아내지 않는 한 비밀번호 원문을 유추하기 어려워진다.근데 당연히 Salt도 단순하게 만들거나 짧게 만들면 그렇게 효과적이지 못하다. 위 링크 글의 Generating a Good Random Salt을 참조하자.위에서 언급한 Key stretching 방식과 Salt 방식을 혼합해 활용하면 더 안전한 방식의 암호화가 가능해진다.근데 사실 위 링크 글에서는 이러한 과정을 직접 개발하는 것은 잘못 이해한 것을 바탕으로 만들어 질 수 있어서 오히려 위험이 될 수 있다고 이야기한다 (보안업체에서 작성한 글인 것을 감안할 것). 그러므로 원리를 이해하고 이미 잘 구현되어 있는 구현체들을 활용하는 편이 좋을 수도 있다는 생각이 들었다.  A misstep in your home-made security strategy may lead to extensive damage to your business, users, and reputation.",
            "content_html": "<p>가을이 오고 있다.</p><p>올해도 어느덧 다 지나가고 있는 것 같다.</p><p>더 뿌듯한, 자랑스러운 올해를 만들기 위해 노력해야지.</p><p>그럼, 내 생일이기도 한 오늘의 뉴스도 시작.</p><p><br /></p><hr /><h1 id=\"spring-data-r2dbc-pagination\">Spring data r2dbc pagination</h1><p><a href=\"https://prateek-ashtikar512.medium.com/r2dbc-pagination-example-1450a5dbdce8\">(Link) Spring data r2dbc pagination example</a></p><p>최근 r2dbc, Spring data r2dbc를 사용하고 있다.</p><p>JPA와 여러가지 차이가 있지만, 그래도 Spring data 측에서 Spring data jpa처럼 유사하게 제공을 하고 있어  사용하는 측면에서는 비슷하게 다룰 수 있다. (JPA와 차이에 대한 내용은 제 블로그 글 참조)</p><p><br /></p><p>근데 하나 차이가 있다면, <code class=\"language-plaintext highlighter-rouge\">Page</code> 인터페이스이다.</p><p>Spring data jpa를 사용한다면 Pageable 사용 시 다음과 같이 사용할 수 있다.</p><div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kd\">public</span> <span class=\"kd\">interface</span> <span class=\"nc\">SomeRepository</span> <span class=\"kd\">extends</span> <span class=\"nc\">JpaRepository</span><span class=\"o\">&lt;</span><span class=\"nc\">Some</span><span class=\"o\">,</span> <span class=\"nc\">Long</span><span class=\"o\">&gt;</span> <span class=\"o\">{</span>    <span class=\"nc\">Page</span><span class=\"o\">&lt;</span><span class=\"nc\">Some</span><span class=\"o\">&gt;</span> <span class=\"nf\">findAllBy</span><span class=\"o\">(</span><span class=\"nc\">Pageable</span> <span class=\"n\">pageable</span><span class=\"o\">);</span><span class=\"o\">}</span></code></pre></div></div><p><br /></p><p>하지만 R2dbc의 경우, 이렇게 사용할 수 없다. <code class=\"language-plaintext highlighter-rouge\">Mono</code>, <code class=\"language-plaintext highlighter-rouge\">Flux</code>로 타입이 제한되기 때문이다.</p><p>즉, 2개 이상의 데이터의 경우 <code class=\"language-plaintext highlighter-rouge\">Page</code>, <code class=\"language-plaintext highlighter-rouge\">List</code>가 아닌 <code class=\"language-plaintext highlighter-rouge\">Flux</code>로 반환된다.</p><div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kd\">public</span> <span class=\"kd\">interface</span> <span class=\"nc\">SomeRepository</span> <span class=\"kd\">extends</span> <span class=\"nc\">R2dbcRepository</span><span class=\"o\">&lt;</span><span class=\"nc\">Some</span><span class=\"o\">,</span> <span class=\"nc\">Long</span><span class=\"o\">&gt;</span> <span class=\"o\">{</span>    <span class=\"nc\">Flux</span><span class=\"o\">&lt;</span><span class=\"nc\">Some</span><span class=\"o\">&gt;</span> <span class=\"nf\">findAllBy</span><span class=\"o\">(</span><span class=\"nc\">Pageable</span> <span class=\"n\">pageable</span><span class=\"o\">);</span>    <span class=\"nc\">Mono</span><span class=\"o\">&lt;</span><span class=\"nc\">Page</span><span class=\"o\">&lt;</span><span class=\"nc\">Some</span><span class=\"o\">&gt;&gt;</span> <span class=\"nf\">findAllBy</span><span class=\"o\">(</span><span class=\"nc\">Pageable</span> <span class=\"n\">pageable</span><span class=\"o\">);</span> <span class=\"c1\">// 불가능</span>    <span class=\"nc\">Flux</span><span class=\"o\">&lt;</span><span class=\"nc\">Page</span><span class=\"o\">&lt;</span><span class=\"nc\">Some</span><span class=\"o\">&gt;&gt;</span> <span class=\"nf\">findAllBy</span><span class=\"o\">(</span><span class=\"nc\">Pageable</span> <span class=\"n\">pageable</span><span class=\"o\">);</span> <span class=\"c1\">// 불가능</span><span class=\"o\">}</span></code></pre></div></div><p>위 R2dbc 예시에서 Parameter로 전달되는 Pageable 인터페이스(PageRequest 구현체)를 통해 Pagination은 구현은 잘 될 수 있다.</p><p>근데 <code class=\"language-plaintext highlighter-rouge\">Page</code> 타입을 사용한다는 것은 Page 정보(Page size, Page number 등)가 필요해 사용하는 경우가 많은데, 위에서는 그 정보를 받을 수 없다.</p><p><br /></p><p>그럼, 이 정보를 어떻게 얻을 수 있을까?</p><p>그 해답은 count 쿼리를 수동으로 구성하고, 이를 사용해 <code class=\"language-plaintext highlighter-rouge\">PageImpl</code> 인스턴스를 직접 만들어 반환하는 방법이다.</p><div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"nd\">@Service</span><span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">ProductService</span> <span class=\"o\">{</span>    <span class=\"nd\">@Autowired</span>    <span class=\"kd\">private</span> <span class=\"nc\">ProductRepository</span> <span class=\"n\">productRepository</span><span class=\"o\">;</span>    <span class=\"kd\">public</span> <span class=\"nc\">Mono</span><span class=\"o\">&lt;</span><span class=\"nc\">Page</span><span class=\"o\">&lt;</span><span class=\"nc\">Product</span><span class=\"o\">&gt;&gt;</span> <span class=\"nf\">getProducts</span><span class=\"o\">(</span><span class=\"nc\">PageRequest</span> <span class=\"n\">pageRequest</span><span class=\"o\">){</span>        <span class=\"k\">return</span> <span class=\"n\">productRepository</span><span class=\"o\">.</span><span class=\"na\">findAllBy</span><span class=\"o\">(</span><span class=\"n\">pageRequest</span><span class=\"o\">))</span>                <span class=\"o\">.</span><span class=\"na\">collectList</span><span class=\"o\">()</span>                <span class=\"o\">.</span><span class=\"na\">zipWith</span><span class=\"o\">(</span><span class=\"k\">this</span><span class=\"o\">.</span><span class=\"na\">productRepository</span><span class=\"o\">.</span><span class=\"na\">count</span><span class=\"o\">())</span>                <span class=\"o\">.</span><span class=\"na\">map</span><span class=\"o\">(</span><span class=\"n\">t</span> <span class=\"o\">-&gt;</span> <span class=\"k\">new</span> <span class=\"nc\">PageImpl</span><span class=\"o\">&lt;&gt;(</span><span class=\"n\">t</span><span class=\"o\">.</span><span class=\"na\">getT1</span><span class=\"o\">(),</span> <span class=\"n\">pageRequest</span><span class=\"o\">,</span> <span class=\"n\">t</span><span class=\"o\">.</span><span class=\"na\">getT2</span><span class=\"o\">()));</span>    <span class=\"o\">}</span><span class=\"o\">}</span></code></pre></div></div><ul>  <li>이렇게 구성하면, <code class=\"language-plaintext highlighter-rouge\">Mono&lt;Page&lt;Product&gt;&gt;</code>를 반환할 수 있게 되어 Page 정보들을 반환할 수 있게 된다.</li></ul><p><br /></p><p>참고로, 위 코드는 <code class=\"language-plaintext highlighter-rouge\">Transactional</code> annotation이 붙지 않았다. 만약 붙이게 되면 오류가 발생할 수 있다.</p><p><code class=\"language-plaintext highlighter-rouge\">Transactional</code> annotation이 붙으면 내부에서 하나의 Database connection을 사용하게 되고 <code class=\"language-plaintext highlighter-rouge\">zipWith</code>는 병렬로 수행되기 때문에,  <code class=\"language-plaintext highlighter-rouge\">findAllBy</code> 쿼리와 <code class=\"language-plaintext highlighter-rouge\">count</code> 쿼리가 하나의 Connection에서 동시에 실행될 수 있기 때문이다.</p><p>그러므로 <code class=\"language-plaintext highlighter-rouge\">Transactional</code> 문제를 해결하기 위해서는 <code class=\"language-plaintext highlighter-rouge\">zipWith</code>가 아닌 <code class=\"language-plaintext highlighter-rouge\">flatMap</code> 같은 순차적으로 연산이 동작할 수 있게 구성하거나, 새로운 메서드로 만들어 Transacitonal propagation(전파) 속성을 이용해 새로운 Transaction 내에서 동작(<code class=\"language-plaintext highlighter-rouge\">REQUIRES_NEW</code>)하도록 구성해야 한다. (새로운 메서드로 구성 시에는 <code class=\"language-plaintext highlighter-rouge\">self invocation</code> 문제를 조심하자)</p><p><br /></p><hr /><h1 id=\"java-stream-api는-왜-for-loop보다-느릴까\">Java Stream API는 왜 for-loop보다 느릴까?</h1><p><a href=\"http://www.angelikalanger.com/Conferences/Videos/Conference-Video-GeeCon-2015-Performance-Model-of-Streams-in-Java-8-Angelika-Langer.html\">(Link) The Performance Model of Streams in Java 8</a></p><p><a href=\"https://jypthemiracle.medium.com/java-stream-api%EB%8A%94-%EC%99%9C-for-loop%EB%B3%B4%EB%8B%A4-%EB%8A%90%EB%A6%B4%EA%B9%8C-50dec4b9974b\">(Link) 번역 및 해설 - Java Stream API는 왜 for-loop보다 느릴까?</a></p><p>Java로 개발할 때, 거의 대부분 For loop 대신 Stream을 활용해 구성한다.</p><p>선언식과 또 여러 함수형 메서드를 연결 지을 수 있다는 점, 코드가 간결해지고 사이드 이펙트를 방지할 수 있다는 점 등 장점이 엄청 많기 때문이다.</p><p><br /></p><p>근데 저 글에서 나와있듯 알고리즘 문제를 푸는 것에서는 손이 안가게 된다.</p><p>나는 <strong>2가지 이유</strong>였다.</p><ol>  <li>알고리즘 문제의 경우, loop 내에서 외부 값을 변경해야할 일이 많다. Stream Pipeline 상에서 값을 계속 주고받기에는 너무 복잡해진다.</li>  <li>for loop보다 느리게 동작한다. 결과 성공시간만 봐도 그렇다.</li></ol><p>2번째 이유에 대해 항상 궁금했었는데 찾아보다가 위 글을 보게 되었고, 엄청 재미있게 읽었다.</p><p><br /></p><p>처음에 primitive type int 배열 중 최대 값을 구하는 작업을 비교하는데 for loop가 Stream보다 <strong>15배 정도 빠르게</strong> 동작한다.</p><ul>  <li>JIT compiler가 for loop에 대해 optimization이 잘되어 있기 때문 (즉, Compilation tier가 높게 잡혀 기계어로 동작하게 됨을 의미한다).</li></ul><p><br /></p><p><code class=\"language-plaintext highlighter-rouge\">Wrapped class인 Integer와 ArrayList를 사용하면 어떨까?</code> for loop 성능이 엄청나게 느려진다. 그래도 Stream보다는 빠르다. 하지만 Stream과 차이가 1.27배 정도 밖에 나지 않는다.</p><p>Integer class를 사용하면서 ArrayList를 활용하게 되었는데, 이를 순회하는 것은 매우 비싸기 때문이라고 한다. 어찌되었든 Wrapped class를 다루게되고, 이는 Stack이 아닌 Heap에 저장되게 된다.</p><p>즉, Primitive type은 Stack에서 바로 접근해서 실제 내용을 가져올 수 있는 반면 Wrapped class는 Heap까지 가서 데이터를 찾아와야 하므로 성능에 영향을 주었다고 이야기한다.</p><p><br /></p><p><code class=\"language-plaintext highlighter-rouge\">Loop 중 아주 비싼 연산(시간복잡도가 큰 작업)을 하게되면 어떻게 될까?</code> 성능에 더 차이가 없게 된다.</p><p>그 이유에 대해서는 자세히 나오지는 않는데, JIT Compiler의 최적화와 for loop을 구성하는데 부가적인 연산들이 들어가기 때문이라고 추측했다.</p><p><br /></p><p><code class=\"language-plaintext highlighter-rouge\">결론적으로 '순회비용'과 '연산비용'이 큰 상황에서는 Stream과 For loop의 성능차이가 크지 않고, 만약 '순회비용'과 '연산비용'이 적다면 For loop 성능이 더 우수하다.</code></p><ul>  <li>(사견) 성능이 중요한 애플리케이션이라면 이런 것들을 고려해야할 것이지만, 그런 것이 아니라면 사실 유지보수성을 위해 Stream을 활용하는 편이 좋지 않을까 싶다.</li></ul><p><br /></p><p>병렬 스트림과 비교하는 부분도 있는데, 포크 조인 풀 및 어떤 상황에서 활용하는지 등에 대한 내용이 있는데 참고하면 좋을 것 같다.</p><p><br /></p><hr /><h1 id=\"비밀번호-암호화---hash-salt\">비밀번호 암호화 - Hash, Salt</h1><p><a href=\"https://auth0.com/blog/adding-salt-to-hashing-a-better-way-to-store-passwords/\">(Link) Adding Salt to Hashing: A Better Way to Store Passwords</a></p><p><a href=\"https://st-lab.tistory.com/100\">(Link) 패스워드의 암호화와 저장</a></p><p>보안이라고는 학부 수준에서 학습했던 것 밖에 없어 계속 까먹게 된다.</p><p>최근 Salt에 대한 이야기를 나눌 기회가 있었는데, ‘이전 프로젝트에서 다뤘었고 암호에 랜덤한 값을 추가한다’라는 이야기만 할 수 있었다.</p><p>다시 볼 때가 되었구나 싶어 찾아보게 되었고, 잘 정리된 글이 있어서 보면서 다시 리마인드 했다.</p><p><br /></p><p>보통 비밀번호를 저장할 때 <code class=\"language-plaintext highlighter-rouge\">SHA-256</code> 같은 단방향 해시함수를 통해 나온 결과를 저장한다. 이 때 이 결과를 <code class=\"language-plaintext highlighter-rouge\">다이제스트(digest)</code>라고 한다.</p><p>단방향 해시함수는 복호화가 불가능하기 때문에 추후 인증 과정에 들어온 값의 다이제스트과 저장한 다이제스트를 비교하여 인증 성공여부를 결정한다.</p><p><br /></p><p>그러면 <code class=\"language-plaintext highlighter-rouge\">이것만으로도 안전한 것 아닐까? 해시 값은 유출되더라도 복호화가 되지 않으니?</code>라고 할 수 있지만, 실상은 그렇지 않다고 한다.</p><p>왜냐하면 많이 사용되는 단방향 알고리즘에 대해서 다양한 문자열 비밀번호들에 대한 다이제스트를 모아놓는 ‘레인보우 테이블’들이 존재하고, 이를 활용해 비밀번호를 유추해볼 수 있기 때문이다.</p><p>또한 이 뿐만 아니라 브루트포스 방식을 통해 비밀번호를 맞춰보려고 하는데, 단순한 해시함수를 사용한다면 적은 시간 내 더 많은 해시함수를 돌려서 비밀번호를 유추해볼 수 있으므로 해커에게 좋은 상황이 될 수 있다.</p><p><br /></p><p>그러면 이러한 문제를 해결하기 위해 어떠한 방법을 사용할까?</p><p>글에서는 2가지 방법이 소개되었는데 Key stretching과 Salt이다. 또한, 이 둘을 혼합해 활용할 수도 있다.</p><p><br /></p><p><strong>Key Stretching은 단방향 해시함수를 단 한 번 실행하는 것이 아니라 N번 수행하는 것이다.</strong></p><p>해시함수를 사용한 결과물에 대해 다시 해시함수를 적용하면서 기존 Plain 비밀번호를 더 숨키고자 하는 것이다.</p><p>이를 사용하면 위에서 언급했던 레인보우 테이블에서 비밀번호를 유추하기 어려워지고, 해커 입장에서 브루트포스를 하는데 더 많은 연산이 들어가게 되어 많은 시간이 걸리게 만들 수 있다.</p><p><br /></p><p>하지만 레인보우 테이블에서도 특정 다이제스트에 대해 몇 번 해시함수를 수행하였는가까지 기록하고 있는 경우가 많다고 한다. 즉, N 번 실행하였어도 그 결과에 대한 원문을 유추해볼 수 있는 것이다.</p><p>그리고 추가적인 문제가 있는데, 여러 사이트들이 다 같은 단방향 해시함수를 사용하고 있는 상황에서 유저가 여러 사이트에 대해 다 같은 비밀번호를 사용하고 있을 경우, 한 사이트에서 비밀번호가 유출되버리면 모든 사이트에 대해서도 유출된 것과 마찬가지가 되어버린다.</p><p><strong>이런 문제를 막기 위해 등장한 것이 Salt이다. 비밀번호에 특정 무작위한 문자열을 더해 기존 비밀번호에 복잡성/무작위성을 더하는 것이다 (음식에 소금치듯 말이다). Salt를 더한 비밀번호를 해시함수를 통해 암호화해서 저장하게 된다.</strong></p><p>특정 유저에 대해 Salt를 생성해 활용하는 과정에서 유저의 정보에 Salt도 저장해야만 한다. 추후 비밀번호 인증 시에도 Salt를 더해 인증해야하기 때문이다.</p><p>결국, 이러한 Salt는 운영되는 사이트마다 다를 수 밖에 없고 한 사이트에서 다이제스트가 유출되어도 다른 사이트에서는 다 다르게 구성되어서 유추하기 더 어려워질 것이다. 또한 레인보우 테이블에서 원본 값이 찾아졌어도 Salt가 더해져있는 값이기에 Salt까지 알아내지 않는 한 비밀번호 원문을 유추하기 어려워진다.</p><p>근데 당연히 Salt도 단순하게 만들거나 짧게 만들면 그렇게 효과적이지 못하다. 위 링크 글의 <code class=\"language-plaintext highlighter-rouge\">Generating a Good Random Salt</code>을 참조하자.</p><p><br /></p><p>위에서 언급한 Key stretching 방식과 Salt 방식을 혼합해 활용하면 더 안전한 방식의 암호화가 가능해진다.</p><p><img src=\"https://user-images.githubusercontent.com/37873745/192129075-133bc37d-d7cb-4c4f-a6e9-26d3ecd1b71e.png\" alt=\"hashsalt\" /></p><p>근데 사실 위 링크 글에서는 이러한 과정을 직접 개발하는 것은 잘못 이해한 것을 바탕으로 만들어 질 수 있어서 오히려 위험이 될 수 있다고 이야기한다 (보안업체에서 작성한 글인 것을 감안할 것). 그러므로 원리를 이해하고 이미 잘 구현되어 있는 구현체들을 활용하는 편이 좋을 수도 있다는 생각이 들었다.</p><blockquote>  <p>A misstep in your home-made security strategy may lead to extensive damage to your business, users, and reputation.</p></blockquote><p><br /></p>",
            "url": "https://kimdoubleb.github.io/news/2022/09/25/3-news",
            
            
            
            "tags": ["r2dbc,","pagination,","java,","stream,","encryption,","salt,","security"],
            
            "date_published": "2022-09-25T00:00:00+09:00",
            "date_modified": "2022-09-25T00:00:00+09:00",
            
                "author":  {
                "name": "KimDoubleB",
                "url": null,
                "avatar": null
                }
                
            
        },
    
        {
            "id": "https://kimdoubleb.github.io/news/2022/09/11/2-news",
            "title": "MySQL Spatial 쿼리 / 개발자가 믿는 거짓들 / iPhone 14 Pro",
            "summary": "MySQL 공간 데이터 처리, 프로그래머가 이메일에 대해 믿는 거짓들, iPhone 14 Pro Dynamic Island",
            "content_text": "요즘 개발 기본 원리들을 다시 학습하고 있는데, 오히려 새로운 것(Application 사용법 등)을 익힐 때보다 더 성장하고 있다는 느낌이 든다.원리에 대해 파악하니 A 기술이 이렇게 구현됬었겠구나하며 일종의 지식적 쾌락(?)을 느끼고 있다. 회사에서 하던 작업들에 대해 아이디어가 떠오르기도 하고 말이다.그럼, 이번 주의 뉴스 시작!Spatial queries with MySQL(Link) Spatial queries with MySQLMySQL에서는 공간 데이터, 연산을 지원하고 있다.  포인트(좌표)/라인/폴리곤 등의 데이터들을 정의하고 저장할 수 있다.중요한 것이 저장 뿐 아니라 Query를 통해 연산을 지원한다는 것이다.공간 관계(Relation)함수와 연산(Operator)함수로 나뉜다.  공간 관계함수: 두 공간 데이터 간의 관계를 연산해 반환한다.          동일한지?(ST_Equals), 겹치는 곳이 있는지?(ST_Disjoint, …), 안에 속하는지?(ST_Within), 접점이 있는지?(ST_Touches) 등        공간 연산함수: 두 공간 데이터 간의 연산을 통해 새로운 공간 데이터를 반환한다.          교집합 공간 구하기(ST_Intersection), 합집합 공간 구하기(ST_Union), 차집합 공간 구하기(ST_Difference), 최소 MBR(Minimum Bounding Rectangle) 폴리곤 구하기(ST_Envelope) 등      이 타입과 함수들을 사용하면 GPS 상의 데이터들로 여러 로직을 구성할 수 있다. 이번에 해커톤에서 GPS 좌표 데이터를 이용해 폴리곤을 구성했고, ST_Within 연산을 통해 특정 폴리곤에 속하는 폴리곤들의 목록을 반환해주는 작업을 진행했었다.속도 측면에서 모르겠지만, 만약 고성능/복잡한 연산이 필요하다면 PostgreSQL의 PostGIS가 더 적합할 수 있다고 한다. 만약 MySQL을 사용하고 있고, Spatial data 저장 및 연산이 필요하다면 활용해보는 것도 좋을 것 같다.INFCON 2022(Link) INFCON 2022 보기인프런 Inflearn에서 주최한 컨퍼런스인 INFCON 2022가 코엑스에서 열렸다.단순히 개발 언어/프레임워크에 초점을 맞춘 것이 아니라 ‘성장’에 초점을 맞춘 듯 했다. 그래서 그런지 가볍게 볼 수 있는? 또 다른 컨퍼런스에서 볼 수 없던? 강연들이 있어서 보기 좋았다.      성공하는 스터디를 만드는 10가지 방법, 나와 팀을 성장시키는 리뷰들, 어느 날 고민 많은 주니어 개발자가 찾아왔다 등 성장에 초점을 맞춘 강연들이 있기도 하고,        서버비 0원 클라우드 큐 도입으로 해냈습니다!, 이 이력서 누구 거에요? 등 제목으로 관심이 쏠리는 강연들도 있다.  아직 거의 보진 못했는데, 시간날 때마다 차차 보면 좋을 것 같다.프로그래머가 이메일에 대해 믿는 거짓들(Link) 프로그래머가 이메일에 대해 믿는 거짓들GeekNews에 소개된 글이다. 원본은 여기이다. 개발자가 이메일을 활용한 로직을 구성할 때, 이러한 거짓들을 바탕으로 개발해서는 안된다를 염두에 두고 작성한 글이다.엄청나게 많은 거짓들?이 존재하는데, ‘엥, 이건 당연히 믿으면 안되는거 아니야?’라는 생각이 들다가도, ‘엥? 이건 맞는거 아니였어?’라는 생각도 든다.웃겼던 항목이 사용자들이 자신이 이메일 주소를 알고 있다 였다. 당연히 알 것이라고 생각하고 로직을 구성하지는 말자. (이메일 찾기라도 구성해놓자)Awesome Falsehood(Link) Github Awesome Falsehood위에서 언급한 이메일에 대해 믿는 거짓들 처럼, 여러 개발 항목들에 대해 믿는 거짓들을 큐레이팅하고 있는 Github 저장소이다.Email 부터 Date/Time, Phone Numbers, Geography, Networks 등 항목들이 있다.만약 해당 도메인을 다룬다거나 한다면, 개발 전에 한번 읽어보고 믿지 말아야 하는 것들을 리마인드 해보는 것도 좋겠다.iPhone 14 Pro 및 iPhone 14 Pro Max(Link) Apple, iPhone 14 Pro 및 iPhone 14 Pro Max 첫 공개IPhone 14 Pro, IPhone 14 Pro Max가 공개되었다 (IPhone 14, AirPods Pro2, … 등도 함께 공되었다).제일 인상 깊었던 것은 Dynamic Island이다.  기본적인 외형(폼팩터)은 차이가 별로 없지만, 펀치홀 디스플레이가 들어갔다. 근데 Apple은 이를 Dynamic Island로 정의하고, 이 펀치홀 디자인을 적극적으로 활용한 UI를 추가했다.이전 안드로이드 진영에서도 전면 카메라를 최대한 숨기기 위한 방식으로 펀치홀 디스플레이를 많이 사용했으나, 이를 활용한 기능적 요소는 존재하지 않았다. 오히려 하드웨어 방면에서 더 나아가 펀치홀을 아예 없애는 기술들을 사용해왔다.하지만 Apple은 Apple인가보다. 사람들에게 어색할 수 있는? 아름답게 느껴지지 않는 펀치홀 디자인을 UI요소로, 사용자와의 Interaction요소로 추가해 활용하고, 또 이에 맞는 완벽한 단어인 Dynamic Island 로 마케팅을 한다니. 존경스럽다.Kubernetes Security Checklist(Link) Security Checklist쿠버네티스 공식문서에서 제공하고 있는 보안 체크리스트이다.어느정도 쿠버네티스를 활용할 줄 알고 사용하고 있다면, 해당 체크리스트를 통해 얼마나 잘 지키고 있는지 확인해보자.  이 문서의 Caution에서 설명하고 있듯 이 보안 체크리스트를 완벽히 했다고 보안적으로 완벽한 것은 아니다. 보안은 계속적인 관심(attention)과 향상(imporovement)가 중요하기 때문에 오히려 이 보안 체크리스트는 우수한 보안을 위한 첫 번째 스텝일 수 있다고 설명하고 있다.Authentication &amp; Authorization, Network Security, Pod Security, Secrets 등의 항목으로 체크리스트를 제공하고 있고, 하위에 그 항목에 대한 설명도 제공한다.예를 들어, 아래와 같은 항목들이 있다.  ConfigMaps 는 Confidential data를 가지고 있어서는 안된다.  Ingress, egress network policy가 클러스터의 모든 workload들에 적용되어져 있다.  컨테이너 이미지들은 불필요한 컨텐츠를 최소화한다.  컨테이너 이미지는 생성 및 배포 중에 정기적으로 스캔되며 취약하다고 알려진 소프트웨어는 패치된다.Architecture Notes(Link) Architecture Notes - System Design &amp; Software Architectures Explained여러 기술의 아키텍처를 설명하는 사이트이다.그림을 통해 Overview를 제공하고 글로 설명하는데, 엄청 깔끔하고 중요한 부분만 딱 적어놓았다.메모리 타입, 암호화 방식 같은 기본적 요소에 대한 설명부터 데이터베이스에 대해 알아야하는 것들, 레디스 구조 등 많이 활용되는 애플리케이션에 대한 내용도 있다.이것도 시간 날 때(심심할 때), 한번 씩 읽어보면 좋을 것 같다. 재밌는 내용이 많아 보인다.",
            "content_html": "<p>요즘 개발 기본 원리들을 다시 학습하고 있는데, 오히려 새로운 것(Application 사용법 등)을 익힐 때보다 더 성장하고 있다는 느낌이 든다.</p><p>원리에 대해 파악하니 <code class=\"language-plaintext highlighter-rouge\">A 기술이 이렇게 구현됬었겠구나</code>하며 일종의 지식적 쾌락(?)을 느끼고 있다. 회사에서 하던 작업들에 대해 아이디어가 떠오르기도 하고 말이다.</p><p>그럼, 이번 주의 뉴스 시작!</p><p><br /></p><hr /><h1 id=\"spatial-queries-with-mysql\">Spatial queries with MySQL</h1><p><a href=\"https://www.endpointdev.com/blog/2021/03/spatial-queries-with-mysql/\">(Link) Spatial queries with MySQL</a></p><p>MySQL에서는 공간 데이터, 연산을 지원하고 있다.</p><ul>  <li>포인트(좌표)/라인/폴리곤 등의 데이터들을 정의하고 저장할 수 있다.</li></ul><p><br /></p><p>중요한 것이 저장 뿐 아니라 Query를 통해 연산을 지원한다는 것이다.</p><p>공간 관계(Relation)함수와 연산(Operator)함수로 나뉜다.</p><ul>  <li>공간 관계함수: 두 공간 데이터 간의 관계를 연산해 반환한다.    <ul>      <li>동일한지?(<code class=\"language-plaintext highlighter-rouge\">ST_Equals</code>), 겹치는 곳이 있는지?(<code class=\"language-plaintext highlighter-rouge\">ST_Disjoint</code>, …), 안에 속하는지?(<code class=\"language-plaintext highlighter-rouge\">ST_Within</code>), 접점이 있는지?(<code class=\"language-plaintext highlighter-rouge\">ST_Touches</code>) 등</li>    </ul>  </li>  <li>공간 연산함수: 두 공간 데이터 간의 연산을 통해 새로운 공간 데이터를 반환한다.    <ul>      <li>교집합 공간 구하기(<code class=\"language-plaintext highlighter-rouge\">ST_Intersection</code>), 합집합 공간 구하기(<code class=\"language-plaintext highlighter-rouge\">ST_Union</code>), 차집합 공간 구하기(<code class=\"language-plaintext highlighter-rouge\">ST_Difference</code>), 최소 MBR(Minimum Bounding Rectangle) 폴리곤 구하기(<code class=\"language-plaintext highlighter-rouge\">ST_Envelope</code>) 등</li>    </ul>  </li></ul><p><br /></p><p>이 타입과 함수들을 사용하면 GPS 상의 데이터들로 여러 로직을 구성할 수 있다. 이번에 해커톤에서 GPS 좌표 데이터를 이용해 폴리곤을 구성했고, <code class=\"language-plaintext highlighter-rouge\">ST_Within</code> 연산을 통해 <a href=\"https://github.com/Hurry-Pizza/Mine-Server/blob/master/src/main/java/com/hurrypizza/mine/domain/path/PathRouteRepository.java#L35\">특정 폴리곤에 속하는 폴리곤들의 목록을 반환해주는 작업</a>을 진행했었다.</p><p>속도 측면에서 모르겠지만, 만약 고성능/복잡한 연산이 필요하다면 PostgreSQL의 PostGIS가 더 적합할 수 있다고 한다. 만약 MySQL을 사용하고 있고, Spatial data 저장 및 연산이 필요하다면 활용해보는 것도 좋을 것 같다.</p><p><br /></p><hr /><h1 id=\"infcon-2022\">INFCON 2022</h1><p><a href=\"https://www.inflearn.com/course/infcon2022\">(Link) INFCON 2022 보기</a></p><p><a href=\"https://www.inflearn.com/\">인프런 Inflearn</a>에서 주최한 컨퍼런스인 INFCON 2022가 코엑스에서 열렸다.</p><p>단순히 개발 언어/프레임워크에 초점을 맞춘 것이 아니라 ‘성장’에 초점을 맞춘 듯 했다. 그래서 그런지 가볍게 볼 수 있는? 또 다른 컨퍼런스에서 볼 수 없던? 강연들이 있어서 보기 좋았다.</p><ul>  <li>    <p>성공하는 스터디를 만드는 10가지 방법, 나와 팀을 성장시키는 리뷰들, 어느 날 고민 많은 주니어 개발자가 찾아왔다 등 성장에 초점을 맞춘 강연들이 있기도 하고,</p>  </li>  <li>    <p>서버비 0원 클라우드 큐 도입으로 해냈습니다!, 이 이력서 누구 거에요? 등 제목으로 관심이 쏠리는 강연들도 있다.</p>  </li></ul><p>아직 거의 보진 못했는데, 시간날 때마다 차차 보면 좋을 것 같다.</p><p><br /></p><hr /><h1 id=\"프로그래머가-이메일에-대해-믿는-거짓들\">프로그래머가 이메일에 대해 믿는 거짓들</h1><p><a href=\"https://news.hada.io/topic?id=7332&amp;utm_source=slack&amp;utm_medium=bot&amp;utm_campaign=T012P6ABDHQ\">(Link) 프로그래머가 이메일에 대해 믿는 거짓들</a></p><p>GeekNews에 소개된 글이다. 원본은 <a href=\"https://beesbuzz.biz/code/439-Falsehoods-programmers-believe-about-email\">여기</a>이다. <code class=\"language-plaintext highlighter-rouge\">개발자가 이메일을 활용한 로직을 구성할 때, 이러한 거짓들을 바탕으로 개발해서는 안된다</code>를 염두에 두고 작성한 글이다.</p><p>엄청나게 많은 거짓들?이 존재하는데, ‘엥, 이건 당연히 믿으면 안되는거 아니야?’라는 생각이 들다가도, ‘엥? 이건 맞는거 아니였어?’라는 생각도 든다.</p><p>웃겼던 항목이 <code class=\"language-plaintext highlighter-rouge\">사용자들이 자신이 이메일 주소를 알고 있다</code> 였다. 당연히 알 것이라고 생각하고 로직을 구성하지는 말자. (이메일 찾기라도 구성해놓자)</p><p><br /></p><hr /><h1 id=\"awesome-falsehood\">Awesome Falsehood</h1><p><a href=\"https://github.com/kdeldycke/awesome-falsehood\">(Link) Github Awesome Falsehood</a></p><p>위에서 언급한 이메일에 대해 믿는 거짓들 처럼, 여러 개발 항목들에 대해 믿는 거짓들을 큐레이팅하고 있는 Github 저장소이다.</p><p>Email 부터 Date/Time, Phone Numbers, Geography, Networks 등 항목들이 있다.</p><p>만약 해당 도메인을 다룬다거나 한다면, 개발 전에 한번 읽어보고 믿지 말아야 하는 것들을 리마인드 해보는 것도 좋겠다.</p><p><br /></p><hr /><h1 id=\"iphone-14-pro-및-iphone-14-pro-max\">iPhone 14 Pro 및 iPhone 14 Pro Max</h1><p><a href=\"https://www.apple.com/kr/newsroom/2022/09/apple-debuts-iphone-14-pro-and-iphone-14-pro-max/\">(Link) Apple, iPhone 14 Pro 및 iPhone 14 Pro Max 첫 공개</a></p><p>IPhone 14 Pro, IPhone 14 Pro Max가 공개되었다 (IPhone 14, AirPods Pro2, … 등도 함께 공되었다).</p><p>제일 인상 깊었던 것은 <code class=\"language-plaintext highlighter-rouge\">Dynamic Island</code>이다.</p><ul>  <li>기본적인 외형(폼팩터)은 차이가 별로 없지만, 펀치홀 디스플레이가 들어갔다. 근데 Apple은 이를 <code class=\"language-plaintext highlighter-rouge\">Dynamic Island</code>로 정의하고, 이 펀치홀 디자인을 적극적으로 활용한 UI를 추가했다.</li></ul><p>이전 안드로이드 진영에서도 전면 카메라를 최대한 숨기기 위한 방식으로 펀치홀 디스플레이를 많이 사용했으나, 이를 활용한 기능적 요소는 존재하지 않았다. 오히려 하드웨어 방면에서 더 나아가 펀치홀을 아예 없애는 기술들을 사용해왔다.</p><p>하지만 Apple은 Apple인가보다. 사람들에게 어색할 수 있는? 아름답게 느껴지지 않는 펀치홀 디자인을 UI요소로, 사용자와의 Interaction요소로 추가해 활용하고, 또 이에 맞는 완벽한 단어인 <code class=\"language-plaintext highlighter-rouge\">Dynamic Island</code> 로 마케팅을 한다니. 존경스럽다.</p><p><br /></p><hr /><h1 id=\"kubernetes-security-checklist\">Kubernetes Security Checklist</h1><p><a href=\"https://kubernetes.io/docs/concepts/security/security-checklist/\">(Link) Security Checklist</a></p><p>쿠버네티스 공식문서에서 제공하고 있는 보안 체크리스트이다.</p><p>어느정도 쿠버네티스를 활용할 줄 알고 사용하고 있다면, 해당 체크리스트를 통해 얼마나 잘 지키고 있는지 확인해보자.</p><ul>  <li>이 문서의 <code class=\"language-plaintext highlighter-rouge\">Caution</code>에서 설명하고 있듯 이 보안 체크리스트를 완벽히 했다고 보안적으로 완벽한 것은 아니다. 보안은 계속적인 관심(attention)과 향상(imporovement)가 중요하기 때문에 오히려 이 보안 체크리스트는 우수한 보안을 위한 첫 번째 스텝일 수 있다고 설명하고 있다.</li></ul><p><br /></p><p><code class=\"language-plaintext highlighter-rouge\">Authentication &amp; Authorization</code>, <code class=\"language-plaintext highlighter-rouge\">Network Security</code>, <code class=\"language-plaintext highlighter-rouge\">Pod Security</code>, <code class=\"language-plaintext highlighter-rouge\">Secrets</code> 등의 항목으로 체크리스트를 제공하고 있고, 하위에 그 항목에 대한 설명도 제공한다.</p><p>예를 들어, 아래와 같은 항목들이 있다.</p><ul>  <li><code class=\"language-plaintext highlighter-rouge\">ConfigMaps</code> 는 Confidential data를 가지고 있어서는 안된다.</li>  <li>Ingress, egress network policy가 클러스터의 모든 workload들에 적용되어져 있다.</li>  <li>컨테이너 이미지들은 불필요한 컨텐츠를 최소화한다.</li>  <li>컨테이너 이미지는 생성 및 배포 중에 정기적으로 스캔되며 취약하다고 알려진 소프트웨어는 패치된다.</li></ul><p><br /></p><hr /><h1 id=\"architecture-notes\">Architecture Notes</h1><p><a href=\"https://architecturenotes.co/\">(Link) Architecture Notes - System Design &amp; Software Architectures Explained</a></p><p>여러 기술의 아키텍처를 설명하는 사이트이다.</p><p>그림을 통해 Overview를 제공하고 글로 설명하는데, 엄청 깔끔하고 중요한 부분만 딱 적어놓았다.</p><p>메모리 타입, 암호화 방식 같은 기본적 요소에 대한 설명부터 데이터베이스에 대해 알아야하는 것들, 레디스 구조 등 많이 활용되는 애플리케이션에 대한 내용도 있다.</p><p>이것도 시간 날 때(심심할 때), 한번 씩 읽어보면 좋을 것 같다. 재밌는 내용이 많아 보인다.</p><p><br /></p>",
            "url": "https://kimdoubleb.github.io/news/2022/09/11/2-news",
            
            
            
            "tags": ["spatial","mysql","kubernetes","falsehood","iphone","architecture"],
            
            "date_published": "2022-09-11T00:00:00+09:00",
            "date_modified": "2022-09-11T00:00:00+09:00",
            
                "author":  {
                "name": "KimDoubleB",
                "url": null,
                "avatar": null
                }
                
            
        },
    
        {
            "id": "https://kimdoubleb.github.io/news/2022/09/04/1-news",
            "title": "Reactor Pagination / 오픈소스 / Java 17 신기능 정리",
            "summary": "Reactor expand를 활용한 Pagination, 오픈소스 대체제 등장 시간, Java 17 주요 기능들",
            "content_text": "첫 News !여러가지 일로 갑자기 바빠져서 많이는 정리하지 못했다.다음엔 개발 뿐 아니라 여러 방면으로 더 넓혀가봐야겠다.Reactor expand와 Pagination(Link) Pagination in a reactive applicationReactor type(Mono, Flux)에서 expand method를 사용해 Pagination을 구현한 방법에 대해 설명한 글이다.사실 이번 글을 통해 expand method를 처음 알았다. BFS를 지원하는 메서드이며, 재귀적으로 data를 쌓아 조회할 수 있다. DFS를 위해서는 expandDeep method를 사용할 수 있다. 사용하는 법에 대해 잘 모르면 이 글을 참조하자.expand를 사용하면 특수한 경우의 Pagination를 구현할 수 있다. 위 글에서는 특정 조건의 모든 비디오를 조회하고 싶은 경우인데, Pagination이 구현되어있어 조건을 붙여서 조회하면 특정 페이지에 대해서만 결과물이 나와 문제가 있는 경우를 제시한다.이런 경우 따로 모든 비디오에 대해 특정 조건으로 검색하는 method를 만들거나 지원해야한다. 하지만 expand를 사용하면 여러 페이지를 재귀적으로 조회하며 조건에 맞는 모든 비디오를 찾을 수 있다.Flux&lt;Video&gt; getAllVideosByPlaylist(String playlistId) {    Flux&lt;PlaylistVideos&gt; expanded = getVideosByPlaylist(playlistId, null)        .expand(playlistVideos -&gt; {            var nextPageToken = playlistVideos.nextPageToken();            if (!StringUtils.hasText(nextPageToken)) {                // 마지막 페이지인 경우, empty를 반환해서 종료.                return Mono.empty();            }            else {                // 재귀적으로 데이터를 쌓을 수 있게 설정.                return getVideosByPlaylist(playlistId, nextPageToken);             }        });    return expanded        .flatMap(plv-&gt;Flux.fromIterable(plv.videos()));}이에 대해 직접 코드를 구성해 테스트 해보았는데, 필요한 상황에 활용하면 가독성을 향상 시키면서 깔끔하게 코드를 작성할 수 있을 것 같다.  근데 직접 Persistent Layer에서 이를 사용해 직접 쿼리를 DB로 날리게 구성하면, 재귀 횟수에 따라 특정 횟수 이상의 쿼리를 전송할 것 같다. 그런 것은 유의해야 되지 않을까?오픈소스 대체제가 나오는 데까지 걸리는 시간(Link) TIME TILL OPEN SOURCE ALTERNATIVEGeekNews에서 소개 된 글이다.상용 소프트웨어에 대한 오픈소스 대체제가 만들어지는데 평균적으로 7년이 걸린다고 한다.상용 소프트웨어의 오픈소스 대체제의 예시는 다음과 같다.  Unix -&gt; GNU/Linux  Photoshop -&gt; GIMP  1Password -&gt; Bitwarden  Slack -&gt; Mattermost7년이면 엄청 짧다고 생각했는데, 글에 의하면 독점 소프트웨어가 수익을 내기에는 충분한 시간이라고 한다.상용 서비스를 이미 도입한 업체에서는 다른 서비스(오픈소스…)로 변경하기 어렵다는 점도 생각해야할 것 같고, 오픈소스로 만들어진 대체제가 완벽히 모든 기능을 대체할 수 있는가도 고려해야할 것 같다.또 중요한게 오픈소스 대체제들은 거의 self hosted로 운영될 것 같은데, 이걸 고려하면 관리해야 할 담당자가 있어야 한다는 것을 의미하고, 그 대체제로부터 발생하는 문제의 책임은 누가 질 것인가도 생각해야 할 것 같다.  Slack 대신 Mattermost로 전환했다가 Server/DB가 날라가면 어떻게 될까…? (거의 그럴 일 없겠지만)기술이 발달되고 오픈소스 생태계가 확장됨에 따라 이런 7년이라는 시간도 점점 짧아지고 있다고 한다.  소프트웨어가 만들어지기 쉬워지기도 했고, 어느정도 유명한 오픈소스가 되면 많은 기여자들이 생겨 개발에 속도가 붙는 것도 영향이 있을 것 같다.옛날에도 소프트웨어를 만들어 돈을 번다는게 어렵다고 생각했는데, 이런 걸 보면 정말 독보적인게 아닌 이상 소프트웨어로 돈 벌기는 더 어려워지는 것 같다. 대신 다른 부분에서 돈을 벌 수 있는 방향이나 긍정적 영향이 늘어나겠지만 말이다.CountDownLatch 이용하기(Link) CountDownLatch 사용방법최근에 이전에 작성했던 코드를 보던 중 CountDownLatch를 사용해 테스트를 구성했던 것을 보게 되었다.작성할 땐, 찾아보면서 학습해 적용했던 것 같은데 (선배 개발자 분이 사용법을 설명해주시기도 했고) 오랫동안 활용을 안했더니 오랜만에 본 코드를 깔끔하게 이해할 수가 없었다 🥲. 그래서 이에 대해 다시 한 번 학습했다.CountDownLatch는 Concurrency (병행성)에 관련되어 Java에서 제공하는 기능이다 (java.util.concurrent 패키지 내 존재).큰 기능만 소개하면 여러 Thread를 관리할 때 다른 Thread 작업이 완료될 때까지 기다리게 만들 수 있다. 즉, Thread 간의 순서를 조작하는데 사용할 수 있다.간략히 설명하면 지원하는 기능은 다음과 같다.// CountDownLatch 선언 - 5개의 CountDown 설정CountDownLatch countDownLatch = new CountDownLatch(5);// Latch의 숫자가 1개씩 내려간다.countDownLatch.countDown();// Latch가 0이 될 때까지 기다린다.countDownLatch.await();// Latch가 0이 될 때까지 기다린다. 하지만 5초가 지나면, 그냥 다음 코드를 진행한다.countDownLatch.await(5, TimeUnit.SECONDS);코드에서 볼 수 있듯 await을 통해 Thread 작업을 묶어둘 수 있다.코드 흐름이 가끔 헷갈릴 수 있는데 Latch는 ‘자물쇠’라는 뜻으로 CountDownLatch는 ‘카운트 다운이 끝나면 열리는 자물쇠’라고 해석하면 이해하기 쉽다 (개인적인 의견).CountDownLatch를 활용해 아래와 같이 Test code를 구성했었다. (Code Link)@Testpublic void testWithSynchronousQueue() {    ThreadPoolBulkhead bulkhead = ThreadPoolBulkhead        .of(\"test\", ThreadPoolBulkheadConfig.custom()            .maxThreadPoolSize(2)            .coreThreadPoolSize(1)            .queueCapacity(0)            .build());    given(helloWorldService.returnHelloWorld()).willReturn(\"Hello world\");    CountDownLatch latch = new CountDownLatch(1);    bulkhead.executeRunnable(CheckedRunnable.of(latch::await).unchecked());    bulkhead.executeRunnable(CheckedRunnable.of(latch::await).unchecked());    assertThatThrownBy(() -&gt;         bulkhead.executeCallable(helloWorldService::returnHelloWorld))        .isInstanceOf(BulkheadFullException.class);    assertThat(bulkhead.getMetrics().getQueueDepth()).isZero();    assertThat(bulkhead.getMetrics().getRemainingQueueCapacity()).isZero();    assertThat(bulkhead.getMetrics().getQueueCapacity()).isZero();    assertThat(bulkhead.getMetrics().getActiveThreadCount()).isEqualTo(2);    assertThat(bulkhead.getMetrics().getThreadPoolSize()).isEqualTo(2);    latch.countDown();}  2개의 쓰레드를 멈춰놓고, Resilience4j bulkhead ThreadPool 값이 올바른가 확인하는 테스트 코드etc 디렉터리(Link) etc 디렉터리에 있는 소중한 아이들넷마블의 보안개발팀에서 작성한 기술 블로그이다. Linux /etc 디렉터리 내 보안적으로 중요한 설정파일들에 대해 이야기한다.사실 회사에서는 보안팀에서 관리 및 설정 해주셔서 직접 신경 쓸 생각을 못했는데, 간단하게 보기 좋았던 것 같다.  /etc/hosts 같은 경우 사내 사이트를 도메인으로 접속하기 위해 로컬에서 설정을 바꿔 활용하는 경우가 있는데, 이걸 이용해 불법적인 행위(해킹 등)을 할 수 있다는 것이 리마인드 됬다.위 글 말고도, 넷마블 보안팀에서 작성하는 것 같은데 관련 보안 시리즈 글들이 있다. Linux의 보안을 생각해야할 때 적혀있는 팁들이여서 필요할 때 훑어봐도 좋을 것 같다.Java 17 기능들(Link) 자바 17의 새로운 기능들, 3년 만에 LTS 버전 릴리즈!회사/혼자 개발할 때, 거의 Java 17을 사용하고 있다. LTS 버전이기도 하고, 버전이 올라갈 수록 편한 기능들과 성능적으로도 향상되었다고 알고 있기에 사용하고 있다.회사 내에서 Java 17을 도입할 때, 팀 내 리서치 공유 해주셨었는데 좀 써오다보니 맨날 쓰던 기능만 사용해서 어떤 기능들이 새로 생겼는지 맨날 까먹어서 이번에 다시 정리했다.  (주의) Java 17에서 새롭게 나온 기능이라기보다 Java 11과 비교했을 때 새로운 기능이다. Java 11 후의 버전에서 나온 기능들이라고 생각하면 된다.앗, 내가 맨날 사용한 Java 17 기능 (Java 11과 비교해)은 다음과 같다.  record 사용  String block 사용 (Query, Test code 때 사용하면 좋다)  Collectors.toList() 대신 Stream.toList() 사용위 기능들을 제외하고, 다른 새로운 기능들 중 살펴볼 만한 것은 다음과 같다.Pattern Matchinginstanceof를 통해 type conversion을 하며 사용했었는데, type conversion을 따로 수동으로 작성해주지 않아도 뒤에 변환 할 변수명을 선언해줌으로써 바로 사용할 수 있다.// AS-ISif (user instanceof OAuthUser) {    // type conversion 필요    OAuthUser oauthUser = (OAuthUser) user;     // ... }// TO-BEif (user instanceof OAuthUser oauthUser) {    // type conversion 불필욘    // ...}switch문에서도 이를 활용할 수 있다 (Preview여서 설정 따로 필요).// AS-ISstatic double getDoubleUsingIf(Object o) {    double result;    if (o instanceof Integer) {        result = ((Integer) o).doubleValue();    } else if (o instanceof Float) {        result = ((Float) o).doubleValue();    } else if (o instanceof String) {        result = Double.parseDouble(((String) o));    } else {        result = 0d;    }    return result;}// TO-BEstatic double getDoubleUsingSwitch(Object o) {    return switch (o) {        case Integer i -&gt; i.doubleValue();        case Float f -&gt; f.doubleValue();        case String s -&gt; Double.parseDouble(s);        default -&gt; 0d;    };}Sealed classes말 그대로 클래스를 봉인하는 기능. ‘엥 그럼 final과 뭐가 다르지?’ 할 수 있는데, final class는 절대 상속이 불가능하지만 sealed class는 허용할 class만이 상속해 확장할 수 있다.  봉인(sealed), 허용(permit), 봉인해제(non-sealed) 키워드들이 사용된다.아래 코드는 위 참조 링크에서 나온 예시.// `Person`는 허용된(permits) 서브 클래스만 확장할 수 있다.sealed class Person    permits Developer, Designer {}// `Developer` 클래스는 봉인이 해제되었다.non-sealed class Developer extends Person {}// 봉인이 해제된 `Student` 클래스는 다른 서브 클래스에서 확장 가능하다.// 그리고 자기 자신을 Developer 봉인(sealed)할 수 있다. sealed class Student extends Developer     permits HighSchoolStudent, MiddleSchoolStudent {    // 이 클래스는 `HighSchoolStudent`, `MiddleSchoolStudent` 클래스만 확장 가능하다.}// permitted 서브 클래스는 확장을 못하게 하거나(final),// 서브 클래스를 가진채로 자신을 봉인하거나(sealed), 봉인을 해제(non-sealed)해야만 한다.final class HighSchoolStudent extends Student {}non-sealed class MiddleSchoolStudent extends Student {}Stable Diffusion(Link) Stable Diffusion Is the Most Important AI Art Model Ever요즘 딥러닝, 더 자세히 말하면 Computer vision 쪽에서는 이미지를 만들어내는 기술들이 핫한 것 같다.얼마 전까지 DALL·E 2를 접하고 정말 딥러닝이 갈수록 대단하구나 하는 생각이 들었다. 역시 미래는 여긴가… 이런 생각도 하고….  DALL·E 2는 특정 Sentence를 입력하면 그에 대한 이미지를 생성하는 학습 모델이다.이번엔 오픈소스로 나온 Stable Diffusion도 DALL·E 2보다 우수한 품질의 이미지를 생성하는 모델이라고 한다.직접 Dreamstudio에서 문장을 통해 생성할 수 있다. 직접 해봤는데, 어느정도 정확한?(상상했던?) 이미지가 나온다.이러한 모델, 서비스를 보면 이미지 생성이라는 핵심을 통해 여러 서비스로 전파가 될 수 있지 않을까 싶다.  게임? 예술 교육? Getty images 같은 이미지 판매?이런 트렌드를 놓치고 있지 않아야 겠다는 생각이 든다.",
            "content_html": "<p>첫 News !</p><p>여러가지 일로 갑자기 바빠져서 많이는 정리하지 못했다.</p><p>다음엔 개발 뿐 아니라 여러 방면으로 더 넓혀가봐야겠다.</p><p><br /></p><hr /><h1 id=\"reactor-expand와-pagination\">Reactor expand와 Pagination</h1><p><a href=\"https://joshlong.com/jl/blogpost/pagination_in_a_reactive_application.html\">(Link) Pagination in a reactive application</a></p><p>Reactor type(Mono, Flux)에서 <code class=\"language-plaintext highlighter-rouge\">expand</code> method를 사용해 Pagination을 구현한 방법에 대해 설명한 글이다.</p><p>사실 이번 글을 통해 <code class=\"language-plaintext highlighter-rouge\">expand</code> method를 처음 알았다. BFS를 지원하는 메서드이며, 재귀적으로 data를 쌓아 조회할 수 있다. DFS를 위해서는 <code class=\"language-plaintext highlighter-rouge\">expandDeep</code> method를 사용할 수 있다. 사용하는 법에 대해 잘 모르면 <a href=\"https://www.vinsguru.com/flux-expand-vs-expanddeep/\">이 글을 참조</a>하자.</p><p><code class=\"language-plaintext highlighter-rouge\">expand</code>를 사용하면 특수한 경우의 Pagination를 구현할 수 있다. 위 글에서는 특정 조건의 모든 비디오를 조회하고 싶은 경우인데, Pagination이 구현되어있어 조건을 붙여서 조회하면 특정 페이지에 대해서만 결과물이 나와 문제가 있는 경우를 제시한다.</p><p>이런 경우 따로 모든 비디오에 대해 특정 조건으로 검색하는 method를 만들거나 지원해야한다. 하지만 <code class=\"language-plaintext highlighter-rouge\">expand</code>를 사용하면 여러 페이지를 재귀적으로 조회하며 조건에 맞는 모든 비디오를 찾을 수 있다.</p><div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"nc\">Flux</span><span class=\"o\">&lt;</span><span class=\"nc\">Video</span><span class=\"o\">&gt;</span> <span class=\"nf\">getAllVideosByPlaylist</span><span class=\"o\">(</span><span class=\"nc\">String</span> <span class=\"n\">playlistId</span><span class=\"o\">)</span> <span class=\"o\">{</span>    <span class=\"nc\">Flux</span><span class=\"o\">&lt;</span><span class=\"nc\">PlaylistVideos</span><span class=\"o\">&gt;</span> <span class=\"n\">expanded</span> <span class=\"o\">=</span> <span class=\"n\">getVideosByPlaylist</span><span class=\"o\">(</span><span class=\"n\">playlistId</span><span class=\"o\">,</span> <span class=\"kc\">null</span><span class=\"o\">)</span>        <span class=\"o\">.</span><span class=\"na\">expand</span><span class=\"o\">(</span><span class=\"n\">playlistVideos</span> <span class=\"o\">-&gt;</span> <span class=\"o\">{</span>            <span class=\"kt\">var</span> <span class=\"n\">nextPageToken</span> <span class=\"o\">=</span> <span class=\"n\">playlistVideos</span><span class=\"o\">.</span><span class=\"na\">nextPageToken</span><span class=\"o\">();</span>            <span class=\"k\">if</span> <span class=\"o\">(!</span><span class=\"nc\">StringUtils</span><span class=\"o\">.</span><span class=\"na\">hasText</span><span class=\"o\">(</span><span class=\"n\">nextPageToken</span><span class=\"o\">))</span> <span class=\"o\">{</span>                <span class=\"c1\">// 마지막 페이지인 경우, empty를 반환해서 종료.</span>                <span class=\"k\">return</span> <span class=\"nc\">Mono</span><span class=\"o\">.</span><span class=\"na\">empty</span><span class=\"o\">();</span>            <span class=\"o\">}</span>            <span class=\"k\">else</span> <span class=\"o\">{</span>                <span class=\"c1\">// 재귀적으로 데이터를 쌓을 수 있게 설정.</span>                <span class=\"k\">return</span> <span class=\"nf\">getVideosByPlaylist</span><span class=\"o\">(</span><span class=\"n\">playlistId</span><span class=\"o\">,</span> <span class=\"n\">nextPageToken</span><span class=\"o\">);</span>             <span class=\"o\">}</span>        <span class=\"o\">});</span>    <span class=\"k\">return</span> <span class=\"n\">expanded</span>        <span class=\"o\">.</span><span class=\"na\">flatMap</span><span class=\"o\">(</span><span class=\"n\">plv</span><span class=\"o\">-&gt;</span><span class=\"nc\">Flux</span><span class=\"o\">.</span><span class=\"na\">fromIterable</span><span class=\"o\">(</span><span class=\"n\">plv</span><span class=\"o\">.</span><span class=\"na\">videos</span><span class=\"o\">()));</span><span class=\"o\">}</span></code></pre></div></div><p>이에 대해 <a href=\"https://github.com/KimDoubleB/spring-learning/blob/master/reactor-exapnd/src/main/java/com/example/reactorexapnd/ReactorExapndTest.java#L27-L33\">직접 코드를 구성해 테스트</a> 해보았는데, 필요한 상황에 활용하면 가독성을 향상 시키면서 깔끔하게 코드를 작성할 수 있을 것 같다.</p><blockquote>  <p>근데 직접 Persistent Layer에서 이를 사용해 직접 쿼리를 DB로 날리게 구성하면, 재귀 횟수에 따라 특정 횟수 이상의 쿼리를 전송할 것 같다. 그런 것은 유의해야 되지 않을까?</p></blockquote><p><br /></p><hr /><h1 id=\"오픈소스-대체제가-나오는-데까지-걸리는-시간\">오픈소스 대체제가 나오는 데까지 걸리는 시간</h1><p><a href=\"https://staltz.com/time-till-open-source-alternative.html\">(Link) TIME TILL OPEN SOURCE ALTERNATIVE</a></p><p><a href=\"https://news.hada.io/topic?id=7281&amp;utm_source=slack&amp;utm_medium=bot&amp;utm_campaign=T012P6ABDHQ\">GeekNews에서 소개 된 글</a>이다.</p><p>상용 소프트웨어에 대한 오픈소스 대체제가 만들어지는데 평균적으로 7년이 걸린다고 한다.</p><p><code class=\"language-plaintext highlighter-rouge\">상용 소프트웨어의 오픈소스 대체제</code>의 예시는 다음과 같다.</p><ul>  <li>Unix -&gt; GNU/Linux</li>  <li>Photoshop -&gt; GIMP</li>  <li>1Password -&gt; Bitwarden</li>  <li>Slack -&gt; Mattermost</li></ul><p>7년이면 엄청 짧다고 생각했는데, 글에 의하면 <em>독점 소프트웨어가 수익을 내기에는 충분한 시간</em>이라고 한다.</p><p>상용 서비스를 이미 도입한 업체에서는 다른 서비스(오픈소스…)로 변경하기 어렵다는 점도 생각해야할 것 같고, 오픈소스로 만들어진 대체제가 완벽히 모든 기능을 대체할 수 있는가도 고려해야할 것 같다.</p><p>또 중요한게 오픈소스 대체제들은 거의 self hosted로 운영될 것 같은데, 이걸 고려하면 관리해야 할 담당자가 있어야 한다는 것을 의미하고, 그 대체제로부터 발생하는 문제의 책임은 누가 질 것인가도 생각해야 할 것 같다.</p><blockquote>  <p>Slack 대신 Mattermost로 전환했다가 Server/DB가 날라가면 어떻게 될까…? (거의 그럴 일 없겠지만)</p></blockquote><p><br /></p><p>기술이 발달되고 오픈소스 생태계가 확장됨에 따라 이런 7년이라는 시간도 점점 짧아지고 있다고 한다.</p><ul>  <li>소프트웨어가 만들어지기 쉬워지기도 했고, 어느정도 유명한 오픈소스가 되면 많은 기여자들이 생겨 개발에 속도가 붙는 것도 영향이 있을 것 같다.</li></ul><p>옛날에도 소프트웨어를 만들어 돈을 번다는게 어렵다고 생각했는데, 이런 걸 보면 정말 독보적인게 아닌 이상 소프트웨어로 돈 벌기는 더 어려워지는 것 같다. 대신 다른 부분에서 돈을 벌 수 있는 방향이나 긍정적 영향이 늘어나겠지만 말이다.</p><p><br /></p><hr /><h1 id=\"countdownlatch-이용하기\">CountDownLatch 이용하기</h1><p><a href=\"https://codechacha.com/ko/java-countdownlatch/\">(Link) CountDownLatch 사용방법</a></p><p>최근에 이전에 작성했던 코드를 보던 중 <code class=\"language-plaintext highlighter-rouge\">CountDownLatch</code>를 사용해 테스트를 구성했던 것을 보게 되었다.</p><p>작성할 땐, 찾아보면서 학습해 적용했던 것 같은데 (선배 개발자 분이 사용법을 설명해주시기도 했고) 오랫동안 활용을 안했더니 오랜만에 본 코드를 깔끔하게 이해할 수가 없었다 🥲. 그래서 이에 대해 다시 한 번 학습했다.</p><p><code class=\"language-plaintext highlighter-rouge\">CountDownLatch</code>는 Concurrency (병행성)에 관련되어 Java에서 제공하는 기능이다 (<code class=\"language-plaintext highlighter-rouge\">java.util.concurrent</code> 패키지 내 존재).</p><p>큰 기능만 소개하면 여러 Thread를 관리할 때 다른 Thread 작업이 완료될 때까지 기다리게 만들 수 있다. 즉, Thread 간의 순서를 조작하는데 사용할 수 있다.</p><p>간략히 설명하면 지원하는 기능은 다음과 같다.</p><div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"c1\">// CountDownLatch 선언 - 5개의 CountDown 설정</span><span class=\"nc\">CountDownLatch</span> <span class=\"n\">countDownLatch</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"nc\">CountDownLatch</span><span class=\"o\">(</span><span class=\"mi\">5</span><span class=\"o\">);</span><span class=\"c1\">// Latch의 숫자가 1개씩 내려간다.</span><span class=\"n\">countDownLatch</span><span class=\"o\">.</span><span class=\"na\">countDown</span><span class=\"o\">();</span><span class=\"c1\">// Latch가 0이 될 때까지 기다린다.</span><span class=\"n\">countDownLatch</span><span class=\"o\">.</span><span class=\"na\">await</span><span class=\"o\">();</span><span class=\"c1\">// Latch가 0이 될 때까지 기다린다. 하지만 5초가 지나면, 그냥 다음 코드를 진행한다.</span><span class=\"n\">countDownLatch</span><span class=\"o\">.</span><span class=\"na\">await</span><span class=\"o\">(</span><span class=\"mi\">5</span><span class=\"o\">,</span> <span class=\"nc\">TimeUnit</span><span class=\"o\">.</span><span class=\"na\">SECONDS</span><span class=\"o\">);</span></code></pre></div></div><p>코드에서 볼 수 있듯 <code class=\"language-plaintext highlighter-rouge\">await</code>을 통해 Thread 작업을 묶어둘 수 있다.</p><p>코드 흐름이 가끔 헷갈릴 수 있는데 <code class=\"language-plaintext highlighter-rouge\">Latch</code>는 ‘자물쇠’라는 뜻으로 <code class=\"language-plaintext highlighter-rouge\">CountDownLatch</code>는 ‘카운트 다운이 끝나면 열리는 자물쇠’라고 해석하면 이해하기 쉽다 (개인적인 의견).</p><p><code class=\"language-plaintext highlighter-rouge\">CountDownLatch</code>를 활용해 아래와 같이 Test code를 구성했었다. (<a href=\"https://github.com/resilience4j/resilience4j/blob/19e8b5e5835b219938ae7a787583ed0b08ee1956/resilience4j-bulkhead/src/test/java/io/github/resilience4j/bulkhead/ThreadPoolBulkheadTest.java#L213-L235\">Code Link</a>)</p><div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"nd\">@Test</span><span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">testWithSynchronousQueue</span><span class=\"o\">()</span> <span class=\"o\">{</span>    <span class=\"nc\">ThreadPoolBulkhead</span> <span class=\"n\">bulkhead</span> <span class=\"o\">=</span> <span class=\"nc\">ThreadPoolBulkhead</span>        <span class=\"o\">.</span><span class=\"na\">of</span><span class=\"o\">(</span><span class=\"s\">\"test\"</span><span class=\"o\">,</span> <span class=\"nc\">ThreadPoolBulkheadConfig</span><span class=\"o\">.</span><span class=\"na\">custom</span><span class=\"o\">()</span>            <span class=\"o\">.</span><span class=\"na\">maxThreadPoolSize</span><span class=\"o\">(</span><span class=\"mi\">2</span><span class=\"o\">)</span>            <span class=\"o\">.</span><span class=\"na\">coreThreadPoolSize</span><span class=\"o\">(</span><span class=\"mi\">1</span><span class=\"o\">)</span>            <span class=\"o\">.</span><span class=\"na\">queueCapacity</span><span class=\"o\">(</span><span class=\"mi\">0</span><span class=\"o\">)</span>            <span class=\"o\">.</span><span class=\"na\">build</span><span class=\"o\">());</span>    <span class=\"n\">given</span><span class=\"o\">(</span><span class=\"n\">helloWorldService</span><span class=\"o\">.</span><span class=\"na\">returnHelloWorld</span><span class=\"o\">()).</span><span class=\"na\">willReturn</span><span class=\"o\">(</span><span class=\"s\">\"Hello world\"</span><span class=\"o\">);</span>    <span class=\"nc\">CountDownLatch</span> <span class=\"n\">latch</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"nc\">CountDownLatch</span><span class=\"o\">(</span><span class=\"mi\">1</span><span class=\"o\">);</span>    <span class=\"n\">bulkhead</span><span class=\"o\">.</span><span class=\"na\">executeRunnable</span><span class=\"o\">(</span><span class=\"nc\">CheckedRunnable</span><span class=\"o\">.</span><span class=\"na\">of</span><span class=\"o\">(</span><span class=\"nl\">latch:</span><span class=\"o\">:</span><span class=\"n\">await</span><span class=\"o\">).</span><span class=\"na\">unchecked</span><span class=\"o\">());</span>    <span class=\"n\">bulkhead</span><span class=\"o\">.</span><span class=\"na\">executeRunnable</span><span class=\"o\">(</span><span class=\"nc\">CheckedRunnable</span><span class=\"o\">.</span><span class=\"na\">of</span><span class=\"o\">(</span><span class=\"nl\">latch:</span><span class=\"o\">:</span><span class=\"n\">await</span><span class=\"o\">).</span><span class=\"na\">unchecked</span><span class=\"o\">());</span>    <span class=\"n\">assertThatThrownBy</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span>         <span class=\"n\">bulkhead</span><span class=\"o\">.</span><span class=\"na\">executeCallable</span><span class=\"o\">(</span><span class=\"nl\">helloWorldService:</span><span class=\"o\">:</span><span class=\"n\">returnHelloWorld</span><span class=\"o\">))</span>        <span class=\"o\">.</span><span class=\"na\">isInstanceOf</span><span class=\"o\">(</span><span class=\"nc\">BulkheadFullException</span><span class=\"o\">.</span><span class=\"na\">class</span><span class=\"o\">);</span>    <span class=\"n\">assertThat</span><span class=\"o\">(</span><span class=\"n\">bulkhead</span><span class=\"o\">.</span><span class=\"na\">getMetrics</span><span class=\"o\">().</span><span class=\"na\">getQueueDepth</span><span class=\"o\">()).</span><span class=\"na\">isZero</span><span class=\"o\">();</span>    <span class=\"n\">assertThat</span><span class=\"o\">(</span><span class=\"n\">bulkhead</span><span class=\"o\">.</span><span class=\"na\">getMetrics</span><span class=\"o\">().</span><span class=\"na\">getRemainingQueueCapacity</span><span class=\"o\">()).</span><span class=\"na\">isZero</span><span class=\"o\">();</span>    <span class=\"n\">assertThat</span><span class=\"o\">(</span><span class=\"n\">bulkhead</span><span class=\"o\">.</span><span class=\"na\">getMetrics</span><span class=\"o\">().</span><span class=\"na\">getQueueCapacity</span><span class=\"o\">()).</span><span class=\"na\">isZero</span><span class=\"o\">();</span>    <span class=\"n\">assertThat</span><span class=\"o\">(</span><span class=\"n\">bulkhead</span><span class=\"o\">.</span><span class=\"na\">getMetrics</span><span class=\"o\">().</span><span class=\"na\">getActiveThreadCount</span><span class=\"o\">()).</span><span class=\"na\">isEqualTo</span><span class=\"o\">(</span><span class=\"mi\">2</span><span class=\"o\">);</span>    <span class=\"n\">assertThat</span><span class=\"o\">(</span><span class=\"n\">bulkhead</span><span class=\"o\">.</span><span class=\"na\">getMetrics</span><span class=\"o\">().</span><span class=\"na\">getThreadPoolSize</span><span class=\"o\">()).</span><span class=\"na\">isEqualTo</span><span class=\"o\">(</span><span class=\"mi\">2</span><span class=\"o\">);</span>    <span class=\"n\">latch</span><span class=\"o\">.</span><span class=\"na\">countDown</span><span class=\"o\">();</span><span class=\"o\">}</span></code></pre></div></div><ul>  <li>2개의 쓰레드를 멈춰놓고, Resilience4j bulkhead ThreadPool 값이 올바른가 확인하는 테스트 코드</li></ul><p><br /></p><hr /><h1 id=\"etc-디렉터리\">etc 디렉터리</h1><p><a href=\"https://netmarble.engineering/watch-out-important-files-in-etc-directory/?fbclid=IwAR3oCtQmWQDCHEEIazydZJ3k4zDAVD_TLTeJCULCBsUMGxWg8VBC7qGJYEw\">(Link) etc 디렉터리에 있는 소중한 아이들</a></p><p>넷마블의 보안개발팀에서 작성한 기술 블로그이다. Linux <code class=\"language-plaintext highlighter-rouge\">/etc</code> 디렉터리 내 보안적으로 중요한 설정파일들에 대해 이야기한다.</p><p>사실 회사에서는 보안팀에서 관리 및 설정 해주셔서 직접 신경 쓸 생각을 못했는데, 간단하게 보기 좋았던 것 같다.</p><ul>  <li><code class=\"language-plaintext highlighter-rouge\">/etc/hosts</code> 같은 경우 사내 사이트를 도메인으로 접속하기 위해 로컬에서 설정을 바꿔 활용하는 경우가 있는데, 이걸 이용해 불법적인 행위(해킹 등)을 할 수 있다는 것이 리마인드 됬다.</li></ul><p>위 글 말고도, 넷마블 보안팀에서 작성하는 것 같은데 <a href=\"https://netmarble.engineering/tag/%ec%97%ac%ea%b8%b0%eb%b3%b4%ea%b8%b0/\">관련 보안 시리즈 글들</a>이 있다. Linux의 보안을 생각해야할 때 적혀있는 팁들이여서 필요할 때 훑어봐도 좋을 것 같다.</p><p><br /></p><hr /><h1 id=\"java-17-기능들\">Java 17 기능들</h1><p><a href=\"https://madplay.github.io/post/what-is-new-java-17\">(Link) 자바 17의 새로운 기능들, 3년 만에 LTS 버전 릴리즈!</a></p><p>회사/혼자 개발할 때, 거의 Java 17을 사용하고 있다. LTS 버전이기도 하고, 버전이 올라갈 수록 편한 기능들과 성능적으로도 향상되었다고 알고 있기에 사용하고 있다.</p><p>회사 내에서 Java 17을 도입할 때, 팀 내 리서치 공유 해주셨었는데 좀 써오다보니 맨날 쓰던 기능만 사용해서 어떤 기능들이 새로 생겼는지 맨날 까먹어서 이번에 다시 정리했다.</p><blockquote>  <p>(주의) Java 17에서 새롭게 나온 기능이라기보다 Java 11과 비교했을 때 새로운 기능이다. Java 11 후의 버전에서 나온 기능들이라고 생각하면 된다.</p></blockquote><p>앗, 내가 맨날 사용한 Java 17 기능 (Java 11과 비교해)은 다음과 같다.</p><ul>  <li><code class=\"language-plaintext highlighter-rouge\">record</code> 사용</li>  <li>String block 사용 (Query, Test code 때 사용하면 좋다)</li>  <li><code class=\"language-plaintext highlighter-rouge\">Collectors.toList()</code> 대신 <code class=\"language-plaintext highlighter-rouge\">Stream.toList()</code> 사용</li></ul><p>위 기능들을 제외하고, 다른 새로운 기능들 중 살펴볼 만한 것은 다음과 같다.</p><h3 id=\"pattern-matching\">Pattern Matching</h3><p><code class=\"language-plaintext highlighter-rouge\">instanceof</code>를 통해 type conversion을 하며 사용했었는데, type conversion을 따로 수동으로 작성해주지 않아도 뒤에 변환 할 변수명을 선언해줌으로써 바로 사용할 수 있다.</p><div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"c1\">// AS-IS</span><span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">user</span> <span class=\"k\">instanceof</span> <span class=\"nc\">OAuthUser</span><span class=\"o\">)</span> <span class=\"o\">{</span>    <span class=\"c1\">// type conversion 필요</span>    <span class=\"nc\">OAuthUser</span> <span class=\"n\">oauthUser</span> <span class=\"o\">=</span> <span class=\"o\">(</span><span class=\"nc\">OAuthUser</span><span class=\"o\">)</span> <span class=\"n\">user</span><span class=\"o\">;</span>     <span class=\"c1\">// ... </span><span class=\"o\">}</span><span class=\"c1\">// TO-BE</span><span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">user</span> <span class=\"k\">instanceof</span> <span class=\"nc\">OAuthUser</span> <span class=\"n\">oauthUser</span><span class=\"o\">)</span> <span class=\"o\">{</span>    <span class=\"c1\">// type conversion 불필욘</span>    <span class=\"c1\">// ...</span><span class=\"o\">}</span></code></pre></div></div><p><code class=\"language-plaintext highlighter-rouge\">switch</code>문에서도 이를 활용할 수 있다 (Preview여서 설정 따로 필요).</p><div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"c1\">// AS-IS</span><span class=\"kd\">static</span> <span class=\"kt\">double</span> <span class=\"nf\">getDoubleUsingIf</span><span class=\"o\">(</span><span class=\"nc\">Object</span> <span class=\"n\">o</span><span class=\"o\">)</span> <span class=\"o\">{</span>    <span class=\"kt\">double</span> <span class=\"n\">result</span><span class=\"o\">;</span>    <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">o</span> <span class=\"k\">instanceof</span> <span class=\"nc\">Integer</span><span class=\"o\">)</span> <span class=\"o\">{</span>        <span class=\"n\">result</span> <span class=\"o\">=</span> <span class=\"o\">((</span><span class=\"nc\">Integer</span><span class=\"o\">)</span> <span class=\"n\">o</span><span class=\"o\">).</span><span class=\"na\">doubleValue</span><span class=\"o\">();</span>    <span class=\"o\">}</span> <span class=\"k\">else</span> <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">o</span> <span class=\"k\">instanceof</span> <span class=\"nc\">Float</span><span class=\"o\">)</span> <span class=\"o\">{</span>        <span class=\"n\">result</span> <span class=\"o\">=</span> <span class=\"o\">((</span><span class=\"nc\">Float</span><span class=\"o\">)</span> <span class=\"n\">o</span><span class=\"o\">).</span><span class=\"na\">doubleValue</span><span class=\"o\">();</span>    <span class=\"o\">}</span> <span class=\"k\">else</span> <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">o</span> <span class=\"k\">instanceof</span> <span class=\"nc\">String</span><span class=\"o\">)</span> <span class=\"o\">{</span>        <span class=\"n\">result</span> <span class=\"o\">=</span> <span class=\"nc\">Double</span><span class=\"o\">.</span><span class=\"na\">parseDouble</span><span class=\"o\">(((</span><span class=\"nc\">String</span><span class=\"o\">)</span> <span class=\"n\">o</span><span class=\"o\">));</span>    <span class=\"o\">}</span> <span class=\"k\">else</span> <span class=\"o\">{</span>        <span class=\"n\">result</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"n\">d</span><span class=\"o\">;</span>    <span class=\"o\">}</span>    <span class=\"k\">return</span> <span class=\"n\">result</span><span class=\"o\">;</span><span class=\"o\">}</span><span class=\"c1\">// TO-BE</span><span class=\"kd\">static</span> <span class=\"kt\">double</span> <span class=\"nf\">getDoubleUsingSwitch</span><span class=\"o\">(</span><span class=\"nc\">Object</span> <span class=\"n\">o</span><span class=\"o\">)</span> <span class=\"o\">{</span>    <span class=\"k\">return</span> <span class=\"nf\">switch</span> <span class=\"o\">(</span><span class=\"n\">o</span><span class=\"o\">)</span> <span class=\"o\">{</span>        <span class=\"k\">case</span> <span class=\"nc\">Integer</span> <span class=\"n\">i</span> <span class=\"o\">-&gt;</span> <span class=\"n\">i</span><span class=\"o\">.</span><span class=\"na\">doubleValue</span><span class=\"o\">();</span>        <span class=\"k\">case</span> <span class=\"nc\">Float</span> <span class=\"n\">f</span> <span class=\"o\">-&gt;</span> <span class=\"n\">f</span><span class=\"o\">.</span><span class=\"na\">doubleValue</span><span class=\"o\">();</span>        <span class=\"k\">case</span> <span class=\"nc\">String</span> <span class=\"n\">s</span> <span class=\"o\">-&gt;</span> <span class=\"nc\">Double</span><span class=\"o\">.</span><span class=\"na\">parseDouble</span><span class=\"o\">(</span><span class=\"n\">s</span><span class=\"o\">);</span>        <span class=\"k\">default</span> <span class=\"o\">-&gt;</span> <span class=\"mi\">0</span><span class=\"n\">d</span><span class=\"o\">;</span>    <span class=\"o\">};</span><span class=\"o\">}</span></code></pre></div></div><h3 id=\"sealed-classes\">Sealed classes</h3><p>말 그대로 클래스를 봉인하는 기능. ‘엥 그럼 <code class=\"language-plaintext highlighter-rouge\">final</code>과 뭐가 다르지?’ 할 수 있는데, <code class=\"language-plaintext highlighter-rouge\">final</code> class는 절대 상속이 불가능하지만 <code class=\"language-plaintext highlighter-rouge\">sealed</code> class는 허용할 class만이 상속해 확장할 수 있다.</p><ul>  <li>봉인(<code class=\"language-plaintext highlighter-rouge\">sealed</code>), 허용(<code class=\"language-plaintext highlighter-rouge\">permit</code>), 봉인해제(<code class=\"language-plaintext highlighter-rouge\">non-sealed</code>) 키워드들이 사용된다.</li></ul><p>아래 코드는 <a href=\"https://madplay.github.io/post/what-is-new-java-17\">위 참조 링크</a>에서 나온 예시.</p><div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"c1\">// `Person`는 허용된(permits) 서브 클래스만 확장할 수 있다.</span><span class=\"n\">sealed</span> <span class=\"kd\">class</span> <span class=\"nc\">Person</span>    <span class=\"n\">permits</span> <span class=\"nc\">Developer</span><span class=\"o\">,</span> <span class=\"nc\">Designer</span> <span class=\"o\">{</span><span class=\"o\">}</span><span class=\"c1\">// `Developer` 클래스는 봉인이 해제되었다.</span><span class=\"n\">non</span><span class=\"o\">-</span><span class=\"n\">sealed</span> <span class=\"kd\">class</span> <span class=\"nc\">Developer</span> <span class=\"kd\">extends</span> <span class=\"nc\">Person</span> <span class=\"o\">{</span><span class=\"o\">}</span><span class=\"c1\">// 봉인이 해제된 `Student` 클래스는 다른 서브 클래스에서 확장 가능하다.</span><span class=\"c1\">// 그리고 자기 자신을 Developer 봉인(sealed)할 수 있다. </span><span class=\"n\">sealed</span> <span class=\"kd\">class</span> <span class=\"nc\">Student</span> <span class=\"kd\">extends</span> <span class=\"nc\">Developer</span>     <span class=\"n\">permits</span> <span class=\"nc\">HighSchoolStudent</span><span class=\"o\">,</span> <span class=\"nc\">MiddleSchoolStudent</span> <span class=\"o\">{</span>    <span class=\"c1\">// 이 클래스는 `HighSchoolStudent`, `MiddleSchoolStudent` 클래스만 확장 가능하다.</span><span class=\"o\">}</span><span class=\"c1\">// permitted 서브 클래스는 확장을 못하게 하거나(final),</span><span class=\"c1\">// 서브 클래스를 가진채로 자신을 봉인하거나(sealed), 봉인을 해제(non-sealed)해야만 한다.</span><span class=\"kd\">final</span> <span class=\"kd\">class</span> <span class=\"nc\">HighSchoolStudent</span> <span class=\"kd\">extends</span> <span class=\"nc\">Student</span> <span class=\"o\">{</span><span class=\"o\">}</span><span class=\"n\">non</span><span class=\"o\">-</span><span class=\"n\">sealed</span> <span class=\"kd\">class</span> <span class=\"nc\">MiddleSchoolStudent</span> <span class=\"kd\">extends</span> <span class=\"nc\">Student</span> <span class=\"o\">{</span><span class=\"o\">}</span></code></pre></div></div><p><br /></p><hr /><h1 id=\"stable-diffusion\">Stable Diffusion</h1><p><a href=\"https://thealgorithmicbridge.substack.com/p/stable-diffusion-is-the-most-important\">(Link) Stable Diffusion Is the Most Important AI Art Model Ever</a></p><p>요즘 딥러닝, 더 자세히 말하면 Computer vision 쪽에서는 이미지를 만들어내는 기술들이 핫한 것 같다.</p><p>얼마 전까지 <a href=\"https://openai.com/dall-e-2/\">DALL·E 2</a>를 접하고 정말 딥러닝이 갈수록 대단하구나 하는 생각이 들었다. 역시 미래는 여긴가… 이런 생각도 하고….</p><ul>  <li>DALL·E 2는 특정 Sentence를 입력하면 그에 대한 이미지를 생성하는 학습 모델이다.</li></ul><p>이번엔 오픈소스로 나온 <code class=\"language-plaintext highlighter-rouge\">Stable Diffusion</code>도 DALL·E 2보다 우수한 품질의 이미지를 생성하는 모델이라고 한다.직접 <a href=\"https://beta.dreamstudio.ai/dream\">Dreamstudio</a>에서 문장을 통해 생성할 수 있다. 직접 해봤는데, 어느정도 정확한?(상상했던?) 이미지가 나온다.</p><p>이러한 모델, 서비스를 보면 <code class=\"language-plaintext highlighter-rouge\">이미지 생성</code>이라는 핵심을 통해 여러 서비스로 전파가 될 수 있지 않을까 싶다.</p><ul>  <li>게임? 예술 교육? Getty images 같은 이미지 판매?</li></ul><p>이런 트렌드를 놓치고 있지 않아야 겠다는 생각이 든다.</p><p><br /></p>",
            "url": "https://kimdoubleb.github.io/news/2022/09/04/1-news",
            
            
            
            "tags": ["reactor","opensource","java"],
            
            "date_published": "2022-09-04T00:00:00+09:00",
            "date_modified": "2022-09-04T00:00:00+09:00",
            
                "author":  {
                "name": "KimDoubleB",
                "url": null,
                "avatar": null
                }
                
            
        },
    
        {
            "id": "https://kimdoubleb.github.io/news/2022/08/28/weekly-tech-news",
            "title": "Weekly Tech News 시작",
            "summary": "배운 것들을 가볍게 정리하는 Weekly tech news 시작",
            "content_text": "배우는 것을 정리하며 블로그 글을 작성하고 있지만, 글을 작성하는 시간이 꽤 걸리다보니 배운 것들을 다 정리하지 못하고 노션에 기록만 해두는 것이 많다.근데 이런 것들을 혼자 기록해두면 볼 일이 없기도 하고 까먹는 경우도 많고, 언제 어떤 것을 학습했고, 조사했고, 고심했는지 기록이 남지 않았다.그래서 이런 것들을 아주 가볍게 정리라도 하고자 Weekly tech news를 작성해보고자 한다.  이 방식은 Outsider님의 블로그의 기술뉴스에서 영감받았다.한 주에 배운 것들, 영감받은 것들, 흥미로웠던 것들 등 아주 가볍게 주제와 참고 링크만이라도 정리하자.",
            "content_html": "<p>배우는 것을 정리하며 <a href=\"https://binux.tistory.com/\">블로그 글</a>을 작성하고 있지만, 글을 작성하는 시간이 꽤 걸리다보니 배운 것들을 다 정리하지 못하고 노션에 기록만 해두는 것이 많다.</p><p>근데 이런 것들을 혼자 기록해두면 볼 일이 없기도 하고 까먹는 경우도 많고, 언제 어떤 것을 학습했고, 조사했고, 고심했는지 기록이 남지 않았다.</p><p>그래서 이런 것들을 아주 가볍게 정리라도 하고자 <code class=\"language-plaintext highlighter-rouge\">Weekly tech news</code>를 작성해보고자 한다.</p><ul>  <li>이 방식은 <a href=\"https://blog.outsider.ne.kr/\">Outsider님의 블로그</a>의 <code class=\"language-plaintext highlighter-rouge\">기술뉴스</code>에서 영감받았다.</li></ul><p><br /></p><p>한 주에 배운 것들, 영감받은 것들, 흥미로웠던 것들 등 아주 가볍게 주제와 참고 링크만이라도 정리하자.</p>",
            "url": "https://kimdoubleb.github.io/news/2022/08/28/weekly-tech-news",
            
            
            
            "tags": ["blog","tech"],
            
            "date_published": "2022-08-28T00:00:00+09:00",
            "date_modified": "2022-08-28T00:00:00+09:00",
            
                "author":  {
                "name": "KimDoubleB",
                "url": null,
                "avatar": null
                }
                
            
        }
    
    ]
}