{
    "version": "https://jsonfeed.org/version/1",
    "title": "KimDoubleB",
    "home_page_url": "https://kimdoubleb.github.io/news/",
    "feed_url": "https://kimdoubleb.github.io/news/feed.json",
    "description": "Code never lies",
    "icon": "https://kimdoubleb.github.io/news/apple-touch-icon.png",
    "favicon": "https://kimdoubleb.github.io/news/favicon.ico",
    "expired": false,
    
    "author":  {
        "name": "KimDoubleB",
        "url": null,
        "avatar": null
    },
    
"items": [
    
        {
            "id": "https://kimdoubleb.github.io/news/2024/10/29/4-sample-publish",
            "title": "한번 해봅시다",
            "summary": "테스트 용도에요",
            "content_text": "테스트 용도로 publish 해봅니다.Last updated: 2024-10-29 15:56:39 UTC",
            "content_html": "<p>테스트 용도로 publish 해봅니다.</p><p>Last updated: 2024-10-29 15:56:39 UTC</p>",
            "url": "https://kimdoubleb.github.io/news/2024/10/29/4-sample-publish",
            
            
            
            
            
            "date_published": "2024-10-29T00:00:00+09:00",
            "date_modified": "2024-10-29T00:00:00+09:00",
            
                "author":  {
                "name": "KimDoubleB",
                "url": null,
                "avatar": null
                }
                
            
        },
    
        {
            "id": "https://kimdoubleb.github.io/news/2023/05/14/4-news",
            "title": "#4 News",
            "summary": "2023.05.14 News",
            "content_text": "한 주마다 뉴스를 적고자 했는데, 이직을 준비하고 직접 하면서 시간이 훌쩍 지나버렸다.어느 덧 이전 뉴스를 적은지 8개월. 8개월 전하고 지금의 상황과 마음은 참 많이 달라져있다.기술도 그렇고, 현재 내 상황과 느끼는 부분들도 그렇고.8개월 전 당시는 지금의 모습이 행복할거라 예상했겠지만(?), 막상 그렇진 않다.이것도 경험이겠지 하면서 살아가고 있다.더 많은 도전과 경험, 성장을 위해 뉴스를 다시 작성하기 시작! 4 번째 뉴스 시작!Monolith냐, MSA냐. 그것이 문제로다.(Link) Monoliths are not dinosaurs요즘 해외에서는 다시 ‘Monolith냐 MSA냐’에 불이 붙는 것 같다.그 시작은 아마존 프라임 모니터링 서비스를 모놀리스로 다시 재전환하면서 비용을 90%까지 절약할 수 있었다는 글이었다. 여러 AWS Lambda와 AWS Step Function으로 구성되어진 아키텍처를 ECS task로 넘어가며 비용을 줄였다는 이야기이다 (깊게 읽어보진 않음).  위 글을 읽고 Monolith Follower들은 ‘봐봐, 역시 Monolith가 더 좋은 경우가 많지.’라고 말하는게 참 보기 안좋다. 뒤에 설명하겠지만, 무조건 적으로 좋은게 어디있겠는가. (MSA를 해보기나 했을까?)Monolith와 MSA는 언제나 의견차이를 불러오는 주제이다. 내가 생각한 그 이유는 ‘상황에 따라 적합한 것’이 다르기 때문이다.여러 도메인, 바운디드 컨텍스트가 나뉘고, 관리하는 팀이 분리되며 배포주기가 다른 서비스들이라면 MSA가 적합할 수 있고(이것 또한 무조건 적인 것이 아님), 하나의 팀 서비스면서 서로 연관되어 배포되는 서비스라면 Monolith가 적합할 수 있을 것이다.중요한 것은 무조건 적인 것은 없다인데, Amazon CTO가 쓴 Monoliths are not dinosaurs 글이 그것을 잘 설명해주고 있다.사실 프로젝트가 커가면서 위와 같은 상황은 달라질 수 있다. 처음은 Monolith가 적합하다가도, 프로젝트가 커져감에 따라 MSA가 적합할 수 있기 때문.그렇기에 설계부터 진화 가능한 아키텍처를 생각해야하고(아키텍처가 변경될 것을 대비), 서비스가 성장할 때마다 아키텍처를 재검토하고 다음 단계 성장을 지원할 수 있는지 확인해야한다. 즉, 구조적으로도 리팩토링하는 시간이 필요하다는 것이다.진화 가능한 아키텍처(Evolvable Architecture)를 하기 위해서는 어떻게 해야할까? 시스템의 진화를 고려해 최소한의 종속성으로 시스템을 변경하고 확장할 수 있는 기반을 마련하는 것이 좋다.  이벤트 중심 아키텍처(EDA), MSA 등이 이러한 사례가 될 수 있겠다.  Amazon S3가 진화 가능한 아키텍처의 사례라고 한다. 결국 MSA 였는데, 몇 개의 마이크로서비스에서 시작해 현재는 300개 이상의 마이크로서비스로 관리된다고 한다.하지만 그 과정 속에서 서비스 요구사항이 동일하고, 단일 팀에서 관리하는 서비스라면 결합해 아키텍처를 간소화하는 것이 좋다. 비용적이면에서나 관리측면에서나.  개발자가 5명인 스타트업(소규모팀)에서 EDA/MSA가 적합할 수 있을까? 관리할 컴포넌트는 증가하고, 개발은 다 따로 해야하는 것이 번거로움이 될 수 있다는 것.결론적으로 요약하자면,  아키텍처에는 일방통행이 없다.  시스템을 정기적으로 평가하고, 상황에 맞게 리팩토링하는 것이 중요하다.한 팀에, 한 서비스에 오래 있다보면 새로운 것들에 대해 경계심이 생긴다. 이럴 때, 다른 것들을 무시하지말고 현재 자신의 상황에 적합한지도 살펴보고 어떤 게 어떨 때 적합한지도 생각해보고 할 필요가 있다고 생각한다.오픈소스 개발자를 위한 프로젝트(Link) Something new is brewingMac에서 개발 할 때, Brew를 사용해서 패키징 관리를 하곤 한다.보통 오픈소스 프로젝트/서비스를 사용할 때 기본적으로 활용하는데, 그 이유는 ‘편리함’이 크기 때문이다.하지만 사용하면서 누가 만들었고, 어떻게 운영되는지는 관심이 별로 없었는데 이 글을 읽으면서 처음 알게되었다.Brew를 만들었던 Max Howell은 현재는 Brew를 커뮤니티에 맡기고 tea라는 프로젝트를 시작했다.Brew에서 손을 땔 때는 Brew 자체가 훌륭하다고 생각해서 Brew2는 만들지 않을 것이라고 했는데, 어쩌다가 tea 프로젝트를 만들게 되었는지 설명하고 있다.최근 core-js 이야기도 그렇고 오픈소스 개발자들이 오픈소스로만으로는 삶을 감당할 수 없다고 한다. core-js 같은 경우 정말 많은 프레임워크/서비스의 근간이 되는 오픈소스이지만, 막상 개발자는 경제적으로 홀대받고 있는 것이다.결국엔 이렇게 되면 해당 오픈소스는 제대로 개발될 수 없게 되고 악영향이 발생할 수 있다(메인테이너는 그냥 자원봉사자가 되는 격). 이러한 문제가 커져 발생할 수 있는 문제를 The Nebraska Problem라고 한다 (실제로 Log4J, NPM 등에서 발생한 문제들이 있다).Brew에서도 마찬가지였다. Brew 또한 오픈소스였고, 이를 통해 여러 오픈소스를 다운로드/사용할 수 있었기 때문.Max Howell는 이러한 부정적인 고리를 어떻게 풀어낼까 고민하던 중 블록체인과 Web3에서 이 방법을 찾았고, 오픈소스 유지관리자가 마땅한 보상을 받을 수 있는 서비스인 tea를 개발하게 된 것이다.사실 블록체인, Web3는 잘 알지 못해서 이와 관련된 내용은 이해하지 못했으나, 블록체인이라는 기술을 통해 긍정적인 영향을 만들어낼 수 있다는 것은 참 좋은 아이디어 같다.개발자의 삶 속에서는 오픈소스를 빼놓지 못할텐데 사실 그 개발자(메인테이너)들에게 합당한 보상을 해주고 있는가? 라는 궁금증과 오픈소스인데 보상이 필요한가?라는 이기적인 생각도 들기도 한다.어찌됬든, tea 같은 프로젝트를 통해 사용자들로 하여금 보상을 받으면 오픈소스 생태계가 더 활성화 될 것 이라는 건 자명한 것 같다. 이런 프로젝트들이 많이 나왔으면 좋겠다.Transactional outboxing(Link) Transactional outboxing with Postgres push notifications위 글에서는 Transactional Outbox pattern을 PostgreSQL과 Spring boot 3.x에서 구현하는 법에 대해 설명한다.먼저 간단하게 Transactional Outbox pattern을 설명하고 있는데 간단히 설명하면 DB 변경과 이벤트 발행(Publishing)을 하나의 Transaction(트랜잭션) 안에서 동작하기 위한 방법이라고 볼 수 있다.  이는 MSA 구조의 DDD 같은 곳에서 도메인 이벤트를 발생하여 다른 컴포넌트에서 해당 이벤트로 하여금 트리거시키고 싶은 경우 등에 활용할 수 있다.그냥 @Trasnactional 걸고, DB 데이터 넣으면서 이벤트 발생시키면 안돼? 라고 할 수 있지만, Message broker에는 Database transaction을 함께 사용하지 못한다는 문제가 있다.데이터 변경은 성공했지만 이벤트 발행은 실패하거나, 반대로 이벤트 발행은 성공했으나 데이터 변경은 실패하는 경우가 발생할 수 있다. 즉, 데이터의 일관성이 깨질 수 있다는 것.  이러한 문제를 해결하기 위한 방법으로 Transaction Outbox pattern이 사용된다. MQ의 역할로서 Database table을 이용하자는 것이다.  Message broker에 이벤트를 발행하는 대신 OUTBOX DB table에 메시지 관련 데이터들을 저장한다. 별도의 Message Relay가 OUTBOX table을 폴링하면서 이벤트 데이터를 읽어 Message broker로 발행한다.  얼마나 자주 폴링하는가에 따라 데이터 변경과 이벤트 발행의 시차가 발생할 수는 있지만, 결과적으로 일관성(Eventual Consistency)은 유지할 수 있다. (참조: MSA에서 메시징 트랜잭션 처리하기)PostgreSQL에서는 LISTEN, NOTIFY 매커니즘을 통해 데이터베이스 연결 전반에 비동기적으로 메시지를 전달할 수 있는 기능을 제공한다.Spring integration에서 JdbcChannelMessageStore, PostgresChannelMessageTableSubsriber를 통해 이 푸시알림들을 받을 수 있도록 지원하는 것 같다.이를 통해 번거롭게 특정 테이블을 폴링하는 로직을 작성하지 않아도, 손쉽게 Listener(Message Relay)를 구현하고, Transactional Outbox Pattern을 구현할 수 있다.",
            "content_html": "<p>한 주마다 뉴스를 적고자 했는데, 이직을 준비하고 직접 하면서 시간이 훌쩍 지나버렸다.</p><p>어느 덧 이전 뉴스를 적은지 8개월. 8개월 전하고 지금의 상황과 마음은 참 많이 달라져있다.</p><p>기술도 그렇고, 현재 내 상황과 느끼는 부분들도 그렇고.</p><p>8개월 전 당시는 지금의 모습이 행복할거라 예상했겠지만(?), 막상 그렇진 않다.이것도 경험이겠지 하면서 살아가고 있다.</p><p>더 많은 도전과 경험, 성장을 위해 뉴스를 다시 작성하기 시작! 4 번째 뉴스 시작!</p><p><br /></p><hr /><h1 id=\"monolith냐-msa냐-그것이-문제로다\">Monolith냐, MSA냐. 그것이 문제로다.</h1><p><a href=\"https://www.allthingsdistributed.com/2023/05/monoliths-are-not-dinosaurs.html\">(Link) Monoliths are not dinosaurs</a></p><p>요즘 해외에서는 다시 ‘Monolith냐 MSA냐’에 불이 붙는 것 같다.</p><p>그 시작은 <a href=\"https://www.primevideotech.com/video-streaming/scaling-up-the-prime-video-audio-video-monitoring-service-and-reducing-costs-by-90\">아마존 프라임 모니터링 서비스를 모놀리스로 다시 재전환하면서 비용을 90%까지 절약할 수 있었다는 글</a>이었다. 여러 AWS Lambda와 AWS Step Function으로 구성되어진 아키텍처를 ECS task로 넘어가며 비용을 줄였다는 이야기이다 (깊게 읽어보진 않음).</p><ul>  <li>위 글을 읽고 Monolith Follower들은 ‘봐봐, 역시 Monolith가 더 좋은 경우가 많지.’라고 말하는게 참 보기 안좋다. 뒤에 설명하겠지만, 무조건 적으로 좋은게 어디있겠는가. (MSA를 해보기나 했을까?)</li></ul><p><br /></p><p>Monolith와 MSA는 언제나 의견차이를 불러오는 주제이다. 내가 생각한 그 이유는 ‘상황에 따라 적합한 것’이 다르기 때문이다.</p><p>여러 도메인, 바운디드 컨텍스트가 나뉘고, 관리하는 팀이 분리되며 배포주기가 다른 서비스들이라면 MSA가 적합할 수 있고(이것 또한 무조건 적인 것이 아님), 하나의 팀 서비스면서 서로 연관되어 배포되는 서비스라면 Monolith가 적합할 수 있을 것이다.</p><p><br /></p><p>중요한 것은 무조건 적인 것은 없다인데, Amazon CTO가 쓴 <code class=\"language-plaintext highlighter-rouge\">Monoliths are not dinosaurs</code> 글이 그것을 잘 설명해주고 있다.</p><p>사실 프로젝트가 커가면서 위와 같은 상황은 달라질 수 있다. 처음은 Monolith가 적합하다가도, 프로젝트가 커져감에 따라 MSA가 적합할 수 있기 때문.</p><p>그렇기에 설계부터 진화 가능한 아키텍처를 생각해야하고(아키텍처가 변경될 것을 대비), 서비스가 성장할 때마다 아키텍처를 재검토하고 다음 단계 성장을 지원할 수 있는지 확인해야한다. 즉, 구조적으로도 리팩토링하는 시간이 필요하다는 것이다.</p><p><br /></p><p><code class=\"language-plaintext highlighter-rouge\">진화 가능한 아키텍처(Evolvable Architecture)</code>를 하기 위해서는 어떻게 해야할까? 시스템의 진화를 고려해 최소한의 종속성으로 시스템을 변경하고 확장할 수 있는 기반을 마련하는 것이 좋다.</p><ul>  <li>이벤트 중심 아키텍처(EDA), MSA 등이 이러한 사례가 될 수 있겠다.</li>  <li>Amazon S3가 진화 가능한 아키텍처의 사례라고 한다. 결국 MSA 였는데, 몇 개의 마이크로서비스에서 시작해 현재는 300개 이상의 마이크로서비스로 관리된다고 한다.</li></ul><p><br /></p><p>하지만 그 과정 속에서 서비스 요구사항이 동일하고, 단일 팀에서 관리하는 서비스라면 결합해 아키텍처를 간소화하는 것이 좋다. 비용적이면에서나 관리측면에서나.</p><ul>  <li>개발자가 5명인 스타트업(소규모팀)에서 EDA/MSA가 적합할 수 있을까? 관리할 컴포넌트는 증가하고, 개발은 다 따로 해야하는 것이 번거로움이 될 수 있다는 것.</li></ul><p><br /></p><p>결론적으로 요약하자면,</p><ul>  <li>아키텍처에는 일방통행이 없다.</li>  <li>시스템을 정기적으로 평가하고, 상황에 맞게 리팩토링하는 것이 중요하다.</li></ul><p>한 팀에, 한 서비스에 오래 있다보면 새로운 것들에 대해 경계심이 생긴다. 이럴 때, 다른 것들을 무시하지말고 현재 자신의 상황에 적합한지도 살펴보고 어떤 게 어떨 때 적합한지도 생각해보고 할 필요가 있다고 생각한다.</p><p><br /></p><hr /><h1 id=\"오픈소스-개발자를-위한-프로젝트\">오픈소스 개발자를 위한 프로젝트</h1><p><a href=\"https://medium.com/teaxyz/tea-brew-478a9e736638\">(Link) Something new is brewing</a></p><p>Mac에서 개발 할 때, Brew를 사용해서 패키징 관리를 하곤 한다.보통 오픈소스 프로젝트/서비스를 사용할 때 기본적으로 활용하는데, 그 이유는 ‘편리함’이 크기 때문이다.</p><p>하지만 사용하면서 누가 만들었고, 어떻게 운영되는지는 관심이 별로 없었는데 이 글을 읽으면서 처음 알게되었다.</p><p>Brew를 만들었던 Max Howell은 현재는 Brew를 커뮤니티에 맡기고 tea라는 프로젝트를 시작했다.Brew에서 손을 땔 때는 Brew 자체가 훌륭하다고 생각해서 Brew2는 만들지 않을 것이라고 했는데, 어쩌다가 tea 프로젝트를 만들게 되었는지 설명하고 있다.</p><p><br /></p><p>최근 <a href=\"https://github.com/zloirock/core-js/blob/master/docs/2023-02-14-so-whats-next.md\">core-js 이야기</a>도 그렇고 오픈소스 개발자들이 오픈소스로만으로는 삶을 감당할 수 없다고 한다. core-js 같은 경우 정말 많은 프레임워크/서비스의 근간이 되는 오픈소스이지만, 막상 개발자는 경제적으로 홀대받고 있는 것이다.</p><p>결국엔 이렇게 되면 해당 오픈소스는 제대로 개발될 수 없게 되고 악영향이 발생할 수 있다(메인테이너는 그냥 자원봉사자가 되는 격). 이러한 문제가 커져 발생할 수 있는 문제를 <a href=\"https://www.researchgate.net/publication/364539939_The_Nebraska_problem_in_open_source_software_development\">The Nebraska Problem</a>라고 한다 (실제로 Log4J, NPM 등에서 발생한 문제들이 있다).</p><p>Brew에서도 마찬가지였다. Brew 또한 오픈소스였고, 이를 통해 여러 오픈소스를 다운로드/사용할 수 있었기 때문.</p><p><br /></p><p>Max Howell는 이러한 부정적인 고리를 어떻게 풀어낼까 고민하던 중 블록체인과 Web3에서 이 방법을 찾았고, 오픈소스 유지관리자가 마땅한 보상을 받을 수 있는 서비스인 tea를 개발하게 된 것이다.</p><p>사실 블록체인, Web3는 잘 알지 못해서 이와 관련된 내용은 이해하지 못했으나, 블록체인이라는 기술을 통해 긍정적인 영향을 만들어낼 수 있다는 것은 참 좋은 아이디어 같다.</p><p>개발자의 삶 속에서는 오픈소스를 빼놓지 못할텐데 사실 그 개발자(메인테이너)들에게 합당한 보상을 해주고 있는가? 라는 궁금증과 오픈소스인데 보상이 필요한가?라는 이기적인 생각도 들기도 한다.</p><p>어찌됬든, tea 같은 프로젝트를 통해 사용자들로 하여금 보상을 받으면 오픈소스 생태계가 더 활성화 될 것 이라는 건 자명한 것 같다. 이런 프로젝트들이 많이 나왔으면 좋겠다.</p><p><br /></p><hr /><h1 id=\"transactional-outboxing\">Transactional outboxing</h1><p><a href=\"https://medium.com/@lombos.monika/transactional-outboxing-with-postgres-push-notifications-5cebdad893fd\">(Link) Transactional outboxing with Postgres push notifications</a></p><p>위 글에서는 Transactional Outbox pattern을 PostgreSQL과 Spring boot 3.x에서 구현하는 법에 대해 설명한다.</p><p><br /></p><p>먼저 간단하게 <strong>Transactional Outbox pattern</strong>을 설명하고 있는데 간단히 설명하면 DB 변경과 이벤트 발행(Publishing)을 하나의 Transaction(트랜잭션) 안에서 동작하기 위한 방법이라고 볼 수 있다.</p><ul>  <li>이는 MSA 구조의 DDD 같은 곳에서 도메인 이벤트를 발생하여 다른 컴포넌트에서 해당 이벤트로 하여금 트리거시키고 싶은 경우 등에 활용할 수 있다.</li></ul><p><br /></p><p>그냥 <code class=\"language-plaintext highlighter-rouge\">@Trasnactional</code> 걸고, DB 데이터 넣으면서 이벤트 발생시키면 안돼? 라고 할 수 있지만, Message broker에는 Database transaction을 함께 사용하지 못한다는 문제가 있다.</p><p><strong>데이터 변경은 성공했지만 이벤트 발행은 실패하거나, 반대로 이벤트 발행은 성공했으나 데이터 변경은 실패하는 경우가 발생할 수 있다. 즉, 데이터의 일관성이 깨질 수 있다는 것.</strong></p><ul>  <li>이러한 문제를 해결하기 위한 방법으로 <strong>Transaction Outbox pattern이 사용</strong>된다. MQ의 역할로서 Database table을 이용하자는 것이다.</li>  <li>Message broker에 이벤트를 발행하는 대신 <code class=\"language-plaintext highlighter-rouge\">OUTBOX</code> DB table에 메시지 관련 데이터들을 저장한다. 별도의 Message Relay가 <code class=\"language-plaintext highlighter-rouge\">OUTBOX</code> table을 폴링하면서 이벤트 데이터를 읽어 Message broker로 발행한다.</li>  <li>얼마나 자주 폴링하는가에 따라 데이터 변경과 이벤트 발행의 시차가 발생할 수는 있지만, 결과적으로 일관성(Eventual Consistency)은 유지할 수 있다. (참조: <a href=\"https://www.popit.kr/msa%EC%97%90%EC%84%9C-%EB%A9%94%EC%8B%9C%EC%A7%95-%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98-%EC%B2%98%EB%A6%AC%ED%95%98%EA%B8%B0/\">MSA에서 메시징 트랜잭션 처리하기</a>)</li></ul><p><br /></p><p>PostgreSQL에서는 <code class=\"language-plaintext highlighter-rouge\">LISTEN</code>, <code class=\"language-plaintext highlighter-rouge\">NOTIFY</code> 매커니즘을 통해 데이터베이스 연결 전반에 비동기적으로 메시지를 전달할 수 있는 기능을 제공한다.</p><p>Spring integration에서 <code class=\"language-plaintext highlighter-rouge\">JdbcChannelMessageStore</code>, <code class=\"language-plaintext highlighter-rouge\">PostgresChannelMessageTableSubsriber</code>를 통해 이 푸시알림들을 받을 수 있도록 지원하는 것 같다.</p><p><img src=\"https://github.com/KimDoubleB/news/assets/37873745/e733059d-3f64-4b61-9892-7158e983570d\" alt=\"image\" /></p><p>이를 통해 번거롭게 특정 테이블을 폴링하는 로직을 작성하지 않아도, 손쉽게 Listener(Message Relay)를 구현하고, Transactional Outbox Pattern을 구현할 수 있다.</p><p><br /></p>",
            "url": "https://kimdoubleb.github.io/news/2023/05/14/4-news",
            
            
            
            "tags": ["monolith,","msa,","architecture,","aws,","opensource,","brew,","transactional-outboxing,","postgreSQL,","spring,","event,","message,","transaction"],
            
            "date_published": "2023-05-14T00:00:00+09:00",
            "date_modified": "2023-05-14T00:00:00+09:00",
            
                "author":  {
                "name": "KimDoubleB",
                "url": null,
                "avatar": null
                }
                
            
        },
    
        {
            "id": "https://kimdoubleb.github.io/news/2022/09/25/3-news",
            "title": "#3 News",
            "summary": "2022.09.25 News",
            "content_text": "가을이 오고 있다.올해도 어느덧 다 지나가고 있는 것 같다.더 뿌듯한, 자랑스러운 올해를 만들기 위해 노력해야지.그럼, 내 생일이기도 한 오늘의 뉴스도 시작.Spring data r2dbc pagination(Link) Spring data r2dbc pagination example최근 r2dbc, Spring data r2dbc를 사용하고 있다.JPA와 여러가지 차이가 있지만, 그래도 Spring data 측에서 Spring data jpa처럼 유사하게 제공을 하고 있어  사용하는 측면에서는 비슷하게 다룰 수 있다. (JPA와 차이에 대한 내용은 제 블로그 글 참조)근데 하나 차이가 있다면, Page 인터페이스이다.Spring data jpa를 사용한다면 Pageable 사용 시 다음과 같이 사용할 수 있다.public interface SomeRepository extends JpaRepository&lt;Some, Long&gt; {    Page&lt;Some&gt; findAllBy(Pageable pageable);}하지만 R2dbc의 경우, 이렇게 사용할 수 없다. Mono, Flux로 타입이 제한되기 때문이다.즉, 2개 이상의 데이터의 경우 Page, List가 아닌 Flux로 반환된다.public interface SomeRepository extends R2dbcRepository&lt;Some, Long&gt; {    Flux&lt;Some&gt; findAllBy(Pageable pageable);    Mono&lt;Page&lt;Some&gt;&gt; findAllBy(Pageable pageable); // 불가능    Flux&lt;Page&lt;Some&gt;&gt; findAllBy(Pageable pageable); // 불가능}위 R2dbc 예시에서 Parameter로 전달되는 Pageable 인터페이스(PageRequest 구현체)를 통해 Pagination은 구현은 잘 될 수 있다.근데 Page 타입을 사용한다는 것은 Page 정보(Page size, Page number 등)가 필요해 사용하는 경우가 많은데, 위에서는 그 정보를 받을 수 없다.그럼, 이 정보를 어떻게 얻을 수 있을까?그 해답은 count 쿼리를 수동으로 구성하고, 이를 사용해 PageImpl 인스턴스를 직접 만들어 반환하는 방법이다.@Servicepublic class ProductService {    @Autowired    private ProductRepository productRepository;    public Mono&lt;Page&lt;Product&gt;&gt; getProducts(PageRequest pageRequest){        return productRepository.findAllBy(pageRequest))                .collectList()                .zipWith(this.productRepository.count())                .map(t -&gt; new PageImpl&lt;&gt;(t.getT1(), pageRequest, t.getT2()));    }}  이렇게 구성하면, Mono&lt;Page&lt;Product&gt;&gt;를 반환할 수 있게 되어 Page 정보들을 반환할 수 있게 된다.참고로, 위 코드는 Transactional annotation이 붙지 않았다. 만약 붙이게 되면 오류가 발생할 수 있다.Transactional annotation이 붙으면 내부에서 하나의 Database connection을 사용하게 되고 zipWith는 병렬로 수행되기 때문에,  findAllBy 쿼리와 count 쿼리가 하나의 Connection에서 동시에 실행될 수 있기 때문이다.그러므로 Transactional 문제를 해결하기 위해서는 zipWith가 아닌 flatMap 같은 순차적으로 연산이 동작할 수 있게 구성하거나, 새로운 메서드로 만들어 Transacitonal propagation(전파) 속성을 이용해 새로운 Transaction 내에서 동작(REQUIRES_NEW)하도록 구성해야 한다. (새로운 메서드로 구성 시에는 self invocation 문제를 조심하자)Java Stream API는 왜 for-loop보다 느릴까?(Link) The Performance Model of Streams in Java 8(Link) 번역 및 해설 - Java Stream API는 왜 for-loop보다 느릴까?Java로 개발할 때, 거의 대부분 For loop 대신 Stream을 활용해 구성한다.선언식과 또 여러 함수형 메서드를 연결 지을 수 있다는 점, 코드가 간결해지고 사이드 이펙트를 방지할 수 있다는 점 등 장점이 엄청 많기 때문이다.근데 저 글에서 나와있듯 알고리즘 문제를 푸는 것에서는 손이 안가게 된다.나는 2가지 이유였다.  알고리즘 문제의 경우, loop 내에서 외부 값을 변경해야할 일이 많다. Stream Pipeline 상에서 값을 계속 주고받기에는 너무 복잡해진다.  for loop보다 느리게 동작한다. 결과 성공시간만 봐도 그렇다.2번째 이유에 대해 항상 궁금했었는데 찾아보다가 위 글을 보게 되었고, 엄청 재미있게 읽었다.처음에 primitive type int 배열 중 최대 값을 구하는 작업을 비교하는데 for loop가 Stream보다 15배 정도 빠르게 동작한다.  JIT compiler가 for loop에 대해 optimization이 잘되어 있기 때문 (즉, Compilation tier가 높게 잡혀 기계어로 동작하게 됨을 의미한다).Wrapped class인 Integer와 ArrayList를 사용하면 어떨까? for loop 성능이 엄청나게 느려진다. 그래도 Stream보다는 빠르다. 하지만 Stream과 차이가 1.27배 정도 밖에 나지 않는다.Integer class를 사용하면서 ArrayList를 활용하게 되었는데, 이를 순회하는 것은 매우 비싸기 때문이라고 한다. 어찌되었든 Wrapped class를 다루게되고, 이는 Stack이 아닌 Heap에 저장되게 된다.즉, Primitive type은 Stack에서 바로 접근해서 실제 내용을 가져올 수 있는 반면 Wrapped class는 Heap까지 가서 데이터를 찾아와야 하므로 성능에 영향을 주었다고 이야기한다.Loop 중 아주 비싼 연산(시간복잡도가 큰 작업)을 하게되면 어떻게 될까? 성능에 더 차이가 없게 된다.그 이유에 대해서는 자세히 나오지는 않는데, JIT Compiler의 최적화와 for loop을 구성하는데 부가적인 연산들이 들어가기 때문이라고 추측했다.결론적으로 '순회비용'과 '연산비용'이 큰 상황에서는 Stream과 For loop의 성능차이가 크지 않고, 만약 '순회비용'과 '연산비용'이 적다면 For loop 성능이 더 우수하다.  (사견) 성능이 중요한 애플리케이션이라면 이런 것들을 고려해야할 것이지만, 그런 것이 아니라면 사실 유지보수성을 위해 Stream을 활용하는 편이 좋지 않을까 싶다.병렬 스트림과 비교하는 부분도 있는데, 포크 조인 풀 및 어떤 상황에서 활용하는지 등에 대한 내용이 있는데 참고하면 좋을 것 같다.비밀번호 암호화 - Hash, Salt(Link) Adding Salt to Hashing: A Better Way to Store Passwords(Link) 패스워드의 암호화와 저장보안이라고는 학부 수준에서 학습했던 것 밖에 없어 계속 까먹게 된다.최근 Salt에 대한 이야기를 나눌 기회가 있었는데, ‘이전 프로젝트에서 다뤘었고 암호에 랜덤한 값을 추가한다’라는 이야기만 할 수 있었다.다시 볼 때가 되었구나 싶어 찾아보게 되었고, 잘 정리된 글이 있어서 보면서 다시 리마인드 했다.보통 비밀번호를 저장할 때 SHA-256 같은 단방향 해시함수를 통해 나온 결과를 저장한다. 이 때 이 결과를 다이제스트(digest)라고 한다.단방향 해시함수는 복호화가 불가능하기 때문에 추후 인증 과정에 들어온 값의 다이제스트과 저장한 다이제스트를 비교하여 인증 성공여부를 결정한다.그러면 이것만으로도 안전한 것 아닐까? 해시 값은 유출되더라도 복호화가 되지 않으니?라고 할 수 있지만, 실상은 그렇지 않다고 한다.왜냐하면 많이 사용되는 단방향 알고리즘에 대해서 다양한 문자열 비밀번호들에 대한 다이제스트를 모아놓는 ‘레인보우 테이블’들이 존재하고, 이를 활용해 비밀번호를 유추해볼 수 있기 때문이다.또한 이 뿐만 아니라 브루트포스 방식을 통해 비밀번호를 맞춰보려고 하는데, 단순한 해시함수를 사용한다면 적은 시간 내 더 많은 해시함수를 돌려서 비밀번호를 유추해볼 수 있으므로 해커에게 좋은 상황이 될 수 있다.그러면 이러한 문제를 해결하기 위해 어떠한 방법을 사용할까?글에서는 2가지 방법이 소개되었는데 Key stretching과 Salt이다. 또한, 이 둘을 혼합해 활용할 수도 있다.Key Stretching은 단방향 해시함수를 단 한 번 실행하는 것이 아니라 N번 수행하는 것이다.해시함수를 사용한 결과물에 대해 다시 해시함수를 적용하면서 기존 Plain 비밀번호를 더 숨키고자 하는 것이다.이를 사용하면 위에서 언급했던 레인보우 테이블에서 비밀번호를 유추하기 어려워지고, 해커 입장에서 브루트포스를 하는데 더 많은 연산이 들어가게 되어 많은 시간이 걸리게 만들 수 있다.하지만 레인보우 테이블에서도 특정 다이제스트에 대해 몇 번 해시함수를 수행하였는가까지 기록하고 있는 경우가 많다고 한다. 즉, N 번 실행하였어도 그 결과에 대한 원문을 유추해볼 수 있는 것이다.그리고 추가적인 문제가 있는데, 여러 사이트들이 다 같은 단방향 해시함수를 사용하고 있는 상황에서 유저가 여러 사이트에 대해 다 같은 비밀번호를 사용하고 있을 경우, 한 사이트에서 비밀번호가 유출되버리면 모든 사이트에 대해서도 유출된 것과 마찬가지가 되어버린다.이런 문제를 막기 위해 등장한 것이 Salt이다. 비밀번호에 특정 무작위한 문자열을 더해 기존 비밀번호에 복잡성/무작위성을 더하는 것이다 (음식에 소금치듯 말이다). Salt를 더한 비밀번호를 해시함수를 통해 암호화해서 저장하게 된다.특정 유저에 대해 Salt를 생성해 활용하는 과정에서 유저의 정보에 Salt도 저장해야만 한다. 추후 비밀번호 인증 시에도 Salt를 더해 인증해야하기 때문이다.결국, 이러한 Salt는 운영되는 사이트마다 다를 수 밖에 없고 한 사이트에서 다이제스트가 유출되어도 다른 사이트에서는 다 다르게 구성되어서 유추하기 더 어려워질 것이다. 또한 레인보우 테이블에서 원본 값이 찾아졌어도 Salt가 더해져있는 값이기에 Salt까지 알아내지 않는 한 비밀번호 원문을 유추하기 어려워진다.근데 당연히 Salt도 단순하게 만들거나 짧게 만들면 그렇게 효과적이지 못하다. 위 링크 글의 Generating a Good Random Salt을 참조하자.위에서 언급한 Key stretching 방식과 Salt 방식을 혼합해 활용하면 더 안전한 방식의 암호화가 가능해진다.근데 사실 위 링크 글에서는 이러한 과정을 직접 개발하는 것은 잘못 이해한 것을 바탕으로 만들어 질 수 있어서 오히려 위험이 될 수 있다고 이야기한다 (보안업체에서 작성한 글인 것을 감안할 것). 그러므로 원리를 이해하고 이미 잘 구현되어 있는 구현체들을 활용하는 편이 좋을 수도 있다는 생각이 들었다.  A misstep in your home-made security strategy may lead to extensive damage to your business, users, and reputation.",
            "content_html": "<p>가을이 오고 있다.</p><p>올해도 어느덧 다 지나가고 있는 것 같다.</p><p>더 뿌듯한, 자랑스러운 올해를 만들기 위해 노력해야지.</p><p>그럼, 내 생일이기도 한 오늘의 뉴스도 시작.</p><p><br /></p><hr /><h1 id=\"spring-data-r2dbc-pagination\">Spring data r2dbc pagination</h1><p><a href=\"https://prateek-ashtikar512.medium.com/r2dbc-pagination-example-1450a5dbdce8\">(Link) Spring data r2dbc pagination example</a></p><p>최근 r2dbc, Spring data r2dbc를 사용하고 있다.</p><p>JPA와 여러가지 차이가 있지만, 그래도 Spring data 측에서 Spring data jpa처럼 유사하게 제공을 하고 있어  사용하는 측면에서는 비슷하게 다룰 수 있다. (JPA와 차이에 대한 내용은 제 블로그 글 참조)</p><p><br /></p><p>근데 하나 차이가 있다면, <code class=\"language-plaintext highlighter-rouge\">Page</code> 인터페이스이다.</p><p>Spring data jpa를 사용한다면 Pageable 사용 시 다음과 같이 사용할 수 있다.</p><div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kd\">public</span> <span class=\"kd\">interface</span> <span class=\"nc\">SomeRepository</span> <span class=\"kd\">extends</span> <span class=\"nc\">JpaRepository</span><span class=\"o\">&lt;</span><span class=\"nc\">Some</span><span class=\"o\">,</span> <span class=\"nc\">Long</span><span class=\"o\">&gt;</span> <span class=\"o\">{</span>    <span class=\"nc\">Page</span><span class=\"o\">&lt;</span><span class=\"nc\">Some</span><span class=\"o\">&gt;</span> <span class=\"nf\">findAllBy</span><span class=\"o\">(</span><span class=\"nc\">Pageable</span> <span class=\"n\">pageable</span><span class=\"o\">);</span><span class=\"o\">}</span></code></pre></div></div><p><br /></p><p>하지만 R2dbc의 경우, 이렇게 사용할 수 없다. <code class=\"language-plaintext highlighter-rouge\">Mono</code>, <code class=\"language-plaintext highlighter-rouge\">Flux</code>로 타입이 제한되기 때문이다.</p><p>즉, 2개 이상의 데이터의 경우 <code class=\"language-plaintext highlighter-rouge\">Page</code>, <code class=\"language-plaintext highlighter-rouge\">List</code>가 아닌 <code class=\"language-plaintext highlighter-rouge\">Flux</code>로 반환된다.</p><div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kd\">public</span> <span class=\"kd\">interface</span> <span class=\"nc\">SomeRepository</span> <span class=\"kd\">extends</span> <span class=\"nc\">R2dbcRepository</span><span class=\"o\">&lt;</span><span class=\"nc\">Some</span><span class=\"o\">,</span> <span class=\"nc\">Long</span><span class=\"o\">&gt;</span> <span class=\"o\">{</span>    <span class=\"nc\">Flux</span><span class=\"o\">&lt;</span><span class=\"nc\">Some</span><span class=\"o\">&gt;</span> <span class=\"nf\">findAllBy</span><span class=\"o\">(</span><span class=\"nc\">Pageable</span> <span class=\"n\">pageable</span><span class=\"o\">);</span>    <span class=\"nc\">Mono</span><span class=\"o\">&lt;</span><span class=\"nc\">Page</span><span class=\"o\">&lt;</span><span class=\"nc\">Some</span><span class=\"o\">&gt;&gt;</span> <span class=\"nf\">findAllBy</span><span class=\"o\">(</span><span class=\"nc\">Pageable</span> <span class=\"n\">pageable</span><span class=\"o\">);</span> <span class=\"c1\">// 불가능</span>    <span class=\"nc\">Flux</span><span class=\"o\">&lt;</span><span class=\"nc\">Page</span><span class=\"o\">&lt;</span><span class=\"nc\">Some</span><span class=\"o\">&gt;&gt;</span> <span class=\"nf\">findAllBy</span><span class=\"o\">(</span><span class=\"nc\">Pageable</span> <span class=\"n\">pageable</span><span class=\"o\">);</span> <span class=\"c1\">// 불가능</span><span class=\"o\">}</span></code></pre></div></div><p>위 R2dbc 예시에서 Parameter로 전달되는 Pageable 인터페이스(PageRequest 구현체)를 통해 Pagination은 구현은 잘 될 수 있다.</p><p>근데 <code class=\"language-plaintext highlighter-rouge\">Page</code> 타입을 사용한다는 것은 Page 정보(Page size, Page number 등)가 필요해 사용하는 경우가 많은데, 위에서는 그 정보를 받을 수 없다.</p><p><br /></p><p>그럼, 이 정보를 어떻게 얻을 수 있을까?</p><p>그 해답은 count 쿼리를 수동으로 구성하고, 이를 사용해 <code class=\"language-plaintext highlighter-rouge\">PageImpl</code> 인스턴스를 직접 만들어 반환하는 방법이다.</p><div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"nd\">@Service</span><span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">ProductService</span> <span class=\"o\">{</span>    <span class=\"nd\">@Autowired</span>    <span class=\"kd\">private</span> <span class=\"nc\">ProductRepository</span> <span class=\"n\">productRepository</span><span class=\"o\">;</span>    <span class=\"kd\">public</span> <span class=\"nc\">Mono</span><span class=\"o\">&lt;</span><span class=\"nc\">Page</span><span class=\"o\">&lt;</span><span class=\"nc\">Product</span><span class=\"o\">&gt;&gt;</span> <span class=\"nf\">getProducts</span><span class=\"o\">(</span><span class=\"nc\">PageRequest</span> <span class=\"n\">pageRequest</span><span class=\"o\">){</span>        <span class=\"k\">return</span> <span class=\"n\">productRepository</span><span class=\"o\">.</span><span class=\"na\">findAllBy</span><span class=\"o\">(</span><span class=\"n\">pageRequest</span><span class=\"o\">))</span>                <span class=\"o\">.</span><span class=\"na\">collectList</span><span class=\"o\">()</span>                <span class=\"o\">.</span><span class=\"na\">zipWith</span><span class=\"o\">(</span><span class=\"k\">this</span><span class=\"o\">.</span><span class=\"na\">productRepository</span><span class=\"o\">.</span><span class=\"na\">count</span><span class=\"o\">())</span>                <span class=\"o\">.</span><span class=\"na\">map</span><span class=\"o\">(</span><span class=\"n\">t</span> <span class=\"o\">-&gt;</span> <span class=\"k\">new</span> <span class=\"nc\">PageImpl</span><span class=\"o\">&lt;&gt;(</span><span class=\"n\">t</span><span class=\"o\">.</span><span class=\"na\">getT1</span><span class=\"o\">(),</span> <span class=\"n\">pageRequest</span><span class=\"o\">,</span> <span class=\"n\">t</span><span class=\"o\">.</span><span class=\"na\">getT2</span><span class=\"o\">()));</span>    <span class=\"o\">}</span><span class=\"o\">}</span></code></pre></div></div><ul>  <li>이렇게 구성하면, <code class=\"language-plaintext highlighter-rouge\">Mono&lt;Page&lt;Product&gt;&gt;</code>를 반환할 수 있게 되어 Page 정보들을 반환할 수 있게 된다.</li></ul><p><br /></p><p>참고로, 위 코드는 <code class=\"language-plaintext highlighter-rouge\">Transactional</code> annotation이 붙지 않았다. 만약 붙이게 되면 오류가 발생할 수 있다.</p><p><code class=\"language-plaintext highlighter-rouge\">Transactional</code> annotation이 붙으면 내부에서 하나의 Database connection을 사용하게 되고 <code class=\"language-plaintext highlighter-rouge\">zipWith</code>는 병렬로 수행되기 때문에,  <code class=\"language-plaintext highlighter-rouge\">findAllBy</code> 쿼리와 <code class=\"language-plaintext highlighter-rouge\">count</code> 쿼리가 하나의 Connection에서 동시에 실행될 수 있기 때문이다.</p><p>그러므로 <code class=\"language-plaintext highlighter-rouge\">Transactional</code> 문제를 해결하기 위해서는 <code class=\"language-plaintext highlighter-rouge\">zipWith</code>가 아닌 <code class=\"language-plaintext highlighter-rouge\">flatMap</code> 같은 순차적으로 연산이 동작할 수 있게 구성하거나, 새로운 메서드로 만들어 Transacitonal propagation(전파) 속성을 이용해 새로운 Transaction 내에서 동작(<code class=\"language-plaintext highlighter-rouge\">REQUIRES_NEW</code>)하도록 구성해야 한다. (새로운 메서드로 구성 시에는 <code class=\"language-plaintext highlighter-rouge\">self invocation</code> 문제를 조심하자)</p><p><br /></p><hr /><h1 id=\"java-stream-api는-왜-for-loop보다-느릴까\">Java Stream API는 왜 for-loop보다 느릴까?</h1><p><a href=\"http://www.angelikalanger.com/Conferences/Videos/Conference-Video-GeeCon-2015-Performance-Model-of-Streams-in-Java-8-Angelika-Langer.html\">(Link) The Performance Model of Streams in Java 8</a></p><p><a href=\"https://jypthemiracle.medium.com/java-stream-api%EB%8A%94-%EC%99%9C-for-loop%EB%B3%B4%EB%8B%A4-%EB%8A%90%EB%A6%B4%EA%B9%8C-50dec4b9974b\">(Link) 번역 및 해설 - Java Stream API는 왜 for-loop보다 느릴까?</a></p><p>Java로 개발할 때, 거의 대부분 For loop 대신 Stream을 활용해 구성한다.</p><p>선언식과 또 여러 함수형 메서드를 연결 지을 수 있다는 점, 코드가 간결해지고 사이드 이펙트를 방지할 수 있다는 점 등 장점이 엄청 많기 때문이다.</p><p><br /></p><p>근데 저 글에서 나와있듯 알고리즘 문제를 푸는 것에서는 손이 안가게 된다.</p><p>나는 <strong>2가지 이유</strong>였다.</p><ol>  <li>알고리즘 문제의 경우, loop 내에서 외부 값을 변경해야할 일이 많다. Stream Pipeline 상에서 값을 계속 주고받기에는 너무 복잡해진다.</li>  <li>for loop보다 느리게 동작한다. 결과 성공시간만 봐도 그렇다.</li></ol><p>2번째 이유에 대해 항상 궁금했었는데 찾아보다가 위 글을 보게 되었고, 엄청 재미있게 읽었다.</p><p><br /></p><p>처음에 primitive type int 배열 중 최대 값을 구하는 작업을 비교하는데 for loop가 Stream보다 <strong>15배 정도 빠르게</strong> 동작한다.</p><ul>  <li>JIT compiler가 for loop에 대해 optimization이 잘되어 있기 때문 (즉, Compilation tier가 높게 잡혀 기계어로 동작하게 됨을 의미한다).</li></ul><p><br /></p><p><code class=\"language-plaintext highlighter-rouge\">Wrapped class인 Integer와 ArrayList를 사용하면 어떨까?</code> for loop 성능이 엄청나게 느려진다. 그래도 Stream보다는 빠르다. 하지만 Stream과 차이가 1.27배 정도 밖에 나지 않는다.</p><p>Integer class를 사용하면서 ArrayList를 활용하게 되었는데, 이를 순회하는 것은 매우 비싸기 때문이라고 한다. 어찌되었든 Wrapped class를 다루게되고, 이는 Stack이 아닌 Heap에 저장되게 된다.</p><p>즉, Primitive type은 Stack에서 바로 접근해서 실제 내용을 가져올 수 있는 반면 Wrapped class는 Heap까지 가서 데이터를 찾아와야 하므로 성능에 영향을 주었다고 이야기한다.</p><p><br /></p><p><code class=\"language-plaintext highlighter-rouge\">Loop 중 아주 비싼 연산(시간복잡도가 큰 작업)을 하게되면 어떻게 될까?</code> 성능에 더 차이가 없게 된다.</p><p>그 이유에 대해서는 자세히 나오지는 않는데, JIT Compiler의 최적화와 for loop을 구성하는데 부가적인 연산들이 들어가기 때문이라고 추측했다.</p><p><br /></p><p><code class=\"language-plaintext highlighter-rouge\">결론적으로 '순회비용'과 '연산비용'이 큰 상황에서는 Stream과 For loop의 성능차이가 크지 않고, 만약 '순회비용'과 '연산비용'이 적다면 For loop 성능이 더 우수하다.</code></p><ul>  <li>(사견) 성능이 중요한 애플리케이션이라면 이런 것들을 고려해야할 것이지만, 그런 것이 아니라면 사실 유지보수성을 위해 Stream을 활용하는 편이 좋지 않을까 싶다.</li></ul><p><br /></p><p>병렬 스트림과 비교하는 부분도 있는데, 포크 조인 풀 및 어떤 상황에서 활용하는지 등에 대한 내용이 있는데 참고하면 좋을 것 같다.</p><p><br /></p><hr /><h1 id=\"비밀번호-암호화---hash-salt\">비밀번호 암호화 - Hash, Salt</h1><p><a href=\"https://auth0.com/blog/adding-salt-to-hashing-a-better-way-to-store-passwords/\">(Link) Adding Salt to Hashing: A Better Way to Store Passwords</a></p><p><a href=\"https://st-lab.tistory.com/100\">(Link) 패스워드의 암호화와 저장</a></p><p>보안이라고는 학부 수준에서 학습했던 것 밖에 없어 계속 까먹게 된다.</p><p>최근 Salt에 대한 이야기를 나눌 기회가 있었는데, ‘이전 프로젝트에서 다뤘었고 암호에 랜덤한 값을 추가한다’라는 이야기만 할 수 있었다.</p><p>다시 볼 때가 되었구나 싶어 찾아보게 되었고, 잘 정리된 글이 있어서 보면서 다시 리마인드 했다.</p><p><br /></p><p>보통 비밀번호를 저장할 때 <code class=\"language-plaintext highlighter-rouge\">SHA-256</code> 같은 단방향 해시함수를 통해 나온 결과를 저장한다. 이 때 이 결과를 <code class=\"language-plaintext highlighter-rouge\">다이제스트(digest)</code>라고 한다.</p><p>단방향 해시함수는 복호화가 불가능하기 때문에 추후 인증 과정에 들어온 값의 다이제스트과 저장한 다이제스트를 비교하여 인증 성공여부를 결정한다.</p><p><br /></p><p>그러면 <code class=\"language-plaintext highlighter-rouge\">이것만으로도 안전한 것 아닐까? 해시 값은 유출되더라도 복호화가 되지 않으니?</code>라고 할 수 있지만, 실상은 그렇지 않다고 한다.</p><p>왜냐하면 많이 사용되는 단방향 알고리즘에 대해서 다양한 문자열 비밀번호들에 대한 다이제스트를 모아놓는 ‘레인보우 테이블’들이 존재하고, 이를 활용해 비밀번호를 유추해볼 수 있기 때문이다.</p><p>또한 이 뿐만 아니라 브루트포스 방식을 통해 비밀번호를 맞춰보려고 하는데, 단순한 해시함수를 사용한다면 적은 시간 내 더 많은 해시함수를 돌려서 비밀번호를 유추해볼 수 있으므로 해커에게 좋은 상황이 될 수 있다.</p><p><br /></p><p>그러면 이러한 문제를 해결하기 위해 어떠한 방법을 사용할까?</p><p>글에서는 2가지 방법이 소개되었는데 Key stretching과 Salt이다. 또한, 이 둘을 혼합해 활용할 수도 있다.</p><p><br /></p><p><strong>Key Stretching은 단방향 해시함수를 단 한 번 실행하는 것이 아니라 N번 수행하는 것이다.</strong></p><p>해시함수를 사용한 결과물에 대해 다시 해시함수를 적용하면서 기존 Plain 비밀번호를 더 숨키고자 하는 것이다.</p><p>이를 사용하면 위에서 언급했던 레인보우 테이블에서 비밀번호를 유추하기 어려워지고, 해커 입장에서 브루트포스를 하는데 더 많은 연산이 들어가게 되어 많은 시간이 걸리게 만들 수 있다.</p><p><br /></p><p>하지만 레인보우 테이블에서도 특정 다이제스트에 대해 몇 번 해시함수를 수행하였는가까지 기록하고 있는 경우가 많다고 한다. 즉, N 번 실행하였어도 그 결과에 대한 원문을 유추해볼 수 있는 것이다.</p><p>그리고 추가적인 문제가 있는데, 여러 사이트들이 다 같은 단방향 해시함수를 사용하고 있는 상황에서 유저가 여러 사이트에 대해 다 같은 비밀번호를 사용하고 있을 경우, 한 사이트에서 비밀번호가 유출되버리면 모든 사이트에 대해서도 유출된 것과 마찬가지가 되어버린다.</p><p><strong>이런 문제를 막기 위해 등장한 것이 Salt이다. 비밀번호에 특정 무작위한 문자열을 더해 기존 비밀번호에 복잡성/무작위성을 더하는 것이다 (음식에 소금치듯 말이다). Salt를 더한 비밀번호를 해시함수를 통해 암호화해서 저장하게 된다.</strong></p><p>특정 유저에 대해 Salt를 생성해 활용하는 과정에서 유저의 정보에 Salt도 저장해야만 한다. 추후 비밀번호 인증 시에도 Salt를 더해 인증해야하기 때문이다.</p><p>결국, 이러한 Salt는 운영되는 사이트마다 다를 수 밖에 없고 한 사이트에서 다이제스트가 유출되어도 다른 사이트에서는 다 다르게 구성되어서 유추하기 더 어려워질 것이다. 또한 레인보우 테이블에서 원본 값이 찾아졌어도 Salt가 더해져있는 값이기에 Salt까지 알아내지 않는 한 비밀번호 원문을 유추하기 어려워진다.</p><p>근데 당연히 Salt도 단순하게 만들거나 짧게 만들면 그렇게 효과적이지 못하다. 위 링크 글의 <code class=\"language-plaintext highlighter-rouge\">Generating a Good Random Salt</code>을 참조하자.</p><p><br /></p><p>위에서 언급한 Key stretching 방식과 Salt 방식을 혼합해 활용하면 더 안전한 방식의 암호화가 가능해진다.</p><p><img src=\"https://user-images.githubusercontent.com/37873745/192129075-133bc37d-d7cb-4c4f-a6e9-26d3ecd1b71e.png\" alt=\"hashsalt\" /></p><p>근데 사실 위 링크 글에서는 이러한 과정을 직접 개발하는 것은 잘못 이해한 것을 바탕으로 만들어 질 수 있어서 오히려 위험이 될 수 있다고 이야기한다 (보안업체에서 작성한 글인 것을 감안할 것). 그러므로 원리를 이해하고 이미 잘 구현되어 있는 구현체들을 활용하는 편이 좋을 수도 있다는 생각이 들었다.</p><blockquote>  <p>A misstep in your home-made security strategy may lead to extensive damage to your business, users, and reputation.</p></blockquote><p><br /></p>",
            "url": "https://kimdoubleb.github.io/news/2022/09/25/3-news",
            
            
            
            "tags": ["r2dbc,","pagination,","java,","stream,","encryption,","salt,","security"],
            
            "date_published": "2022-09-25T00:00:00+09:00",
            "date_modified": "2022-09-25T00:00:00+09:00",
            
                "author":  {
                "name": "KimDoubleB",
                "url": null,
                "avatar": null
                }
                
            
        },
    
        {
            "id": "https://kimdoubleb.github.io/news/2022/09/11/2-news",
            "title": "#2 News",
            "summary": "2022.09.11 News",
            "content_text": "요즘 개발 기본 원리들을 다시 학습하고 있는데, 오히려 새로운 것(Application 사용법 등)을 익힐 때보다 더 성장하고 있다는 느낌이 든다.원리에 대해 파악하니 A 기술이 이렇게 구현됬었겠구나하며 일종의 지식적 쾌락(?)을 느끼고 있다. 회사에서 하던 작업들에 대해 아이디어가 떠오르기도 하고 말이다.그럼, 이번 주의 뉴스 시작!Spatial queries with MySQL(Link) Spatial queries with MySQLMySQL에서는 공간 데이터, 연산을 지원하고 있다.  포인트(좌표)/라인/폴리곤 등의 데이터들을 정의하고 저장할 수 있다.중요한 것이 저장 뿐 아니라 Query를 통해 연산을 지원한다는 것이다.공간 관계(Relation)함수와 연산(Operator)함수로 나뉜다.  공간 관계함수: 두 공간 데이터 간의 관계를 연산해 반환한다.          동일한지?(ST_Equals), 겹치는 곳이 있는지?(ST_Disjoint, …), 안에 속하는지?(ST_Within), 접점이 있는지?(ST_Touches) 등        공간 연산함수: 두 공간 데이터 간의 연산을 통해 새로운 공간 데이터를 반환한다.          교집합 공간 구하기(ST_Intersection), 합집합 공간 구하기(ST_Union), 차집합 공간 구하기(ST_Difference), 최소 MBR(Minimum Bounding Rectangle) 폴리곤 구하기(ST_Envelope) 등      이 타입과 함수들을 사용하면 GPS 상의 데이터들로 여러 로직을 구성할 수 있다. 이번에 해커톤에서 GPS 좌표 데이터를 이용해 폴리곤을 구성했고, ST_Within 연산을 통해 특정 폴리곤에 속하는 폴리곤들의 목록을 반환해주는 작업을 진행했었다.속도 측면에서 모르겠지만, 만약 고성능/복잡한 연산이 필요하다면 PostgreSQL의 PostGIS가 더 적합할 수 있다고 한다. 만약 MySQL을 사용하고 있고, Spatial data 저장 및 연산이 필요하다면 활용해보는 것도 좋을 것 같다.INFCON 2022(Link) INFCON 2022 보기인프런 Inflearn에서 주최한 컨퍼런스인 INFCON 2022가 코엑스에서 열렸다.단순히 개발 언어/프레임워크에 초점을 맞춘 것이 아니라 ‘성장’에 초점을 맞춘 듯 했다. 그래서 그런지 가볍게 볼 수 있는? 또 다른 컨퍼런스에서 볼 수 없던? 강연들이 있어서 보기 좋았다.      성공하는 스터디를 만드는 10가지 방법, 나와 팀을 성장시키는 리뷰들, 어느 날 고민 많은 주니어 개발자가 찾아왔다 등 성장에 초점을 맞춘 강연들이 있기도 하고,        서버비 0원 클라우드 큐 도입으로 해냈습니다!, 이 이력서 누구 거에요? 등 제목으로 관심이 쏠리는 강연들도 있다.  아직 거의 보진 못했는데, 시간날 때마다 차차 보면 좋을 것 같다.프로그래머가 이메일에 대해 믿는 거짓들(Link) 프로그래머가 이메일에 대해 믿는 거짓들GeekNews에 소개된 글이다. 원본은 여기이다. 개발자가 이메일을 활용한 로직을 구성할 때, 이러한 거짓들을 바탕으로 개발해서는 안된다를 염두에 두고 작성한 글이다.엄청나게 많은 거짓들?이 존재하는데, ‘엥, 이건 당연히 믿으면 안되는거 아니야?’라는 생각이 들다가도, ‘엥? 이건 맞는거 아니였어?’라는 생각도 든다.웃겼던 항목이 사용자들이 자신이 이메일 주소를 알고 있다 였다. 당연히 알 것이라고 생각하고 로직을 구성하지는 말자. (이메일 찾기라도 구성해놓자)Awesome Falsehood(Link) Github Awesome Falsehood위에서 언급한 이메일에 대해 믿는 거짓들 처럼, 여러 개발 항목들에 대해 믿는 거짓들을 큐레이팅하고 있는 Github 저장소이다.Email 부터 Date/Time, Phone Numbers, Geography, Networks 등 항목들이 있다.만약 해당 도메인을 다룬다거나 한다면, 개발 전에 한번 읽어보고 믿지 말아야 하는 것들을 리마인드 해보는 것도 좋겠다.iPhone 14 Pro 및 iPhone 14 Pro Max(Link) Apple, iPhone 14 Pro 및 iPhone 14 Pro Max 첫 공개IPhone 14 Pro, IPhone 14 Pro Max가 공개되었다 (IPhone 14, AirPods Pro2, … 등도 함께 공되었다).제일 인상 깊었던 것은 Dynamic Island이다.  기본적인 외형(폼팩터)은 차이가 별로 없지만, 펀치홀 디스플레이가 들어갔다. 근데 Apple은 이를 Dynamic Island로 정의하고, 이 펀치홀 디자인을 적극적으로 활용한 UI를 추가했다.이전 안드로이드 진영에서도 전면 카메라를 최대한 숨기기 위한 방식으로 펀치홀 디스플레이를 많이 사용했으나, 이를 활용한 기능적 요소는 존재하지 않았다. 오히려 하드웨어 방면에서 더 나아가 펀치홀을 아예 없애는 기술들을 사용해왔다.하지만 Apple은 Apple인가보다. 사람들에게 어색할 수 있는? 아름답게 느껴지지 않는 펀치홀 디자인을 UI요소로, 사용자와의 Interaction요소로 추가해 활용하고, 또 이에 맞는 완벽한 단어인 Dynamic Island 로 마케팅을 한다니. 존경스럽다.Kubernetes Security Checklist(Link) Security Checklist쿠버네티스 공식문서에서 제공하고 있는 보안 체크리스트이다.어느정도 쿠버네티스를 활용할 줄 알고 사용하고 있다면, 해당 체크리스트를 통해 얼마나 잘 지키고 있는지 확인해보자.  이 문서의 Caution에서 설명하고 있듯 이 보안 체크리스트를 완벽히 했다고 보안적으로 완벽한 것은 아니다. 보안은 계속적인 관심(attention)과 향상(imporovement)가 중요하기 때문에 오히려 이 보안 체크리스트는 우수한 보안을 위한 첫 번째 스텝일 수 있다고 설명하고 있다.Authentication &amp; Authorization, Network Security, Pod Security, Secrets 등의 항목으로 체크리스트를 제공하고 있고, 하위에 그 항목에 대한 설명도 제공한다.예를 들어, 아래와 같은 항목들이 있다.  ConfigMaps 는 Confidential data를 가지고 있어서는 안된다.  Ingress, egress network policy가 클러스터의 모든 workload들에 적용되어져 있다.  컨테이너 이미지들은 불필요한 컨텐츠를 최소화한다.  컨테이너 이미지는 생성 및 배포 중에 정기적으로 스캔되며 취약하다고 알려진 소프트웨어는 패치된다.Architecture Notes(Link) Architecture Notes - System Design &amp; Software Architectures Explained여러 기술의 아키텍처를 설명하는 사이트이다.그림을 통해 Overview를 제공하고 글로 설명하는데, 엄청 깔끔하고 중요한 부분만 딱 적어놓았다.메모리 타입, 암호화 방식 같은 기본적 요소에 대한 설명부터 데이터베이스에 대해 알아야하는 것들, 레디스 구조 등 많이 활용되는 애플리케이션에 대한 내용도 있다.이것도 시간 날 때(심심할 때), 한번 씩 읽어보면 좋을 것 같다. 재밌는 내용이 많아 보인다.",
            "content_html": "<p>요즘 개발 기본 원리들을 다시 학습하고 있는데, 오히려 새로운 것(Application 사용법 등)을 익힐 때보다 더 성장하고 있다는 느낌이 든다.</p><p>원리에 대해 파악하니 <code class=\"language-plaintext highlighter-rouge\">A 기술이 이렇게 구현됬었겠구나</code>하며 일종의 지식적 쾌락(?)을 느끼고 있다. 회사에서 하던 작업들에 대해 아이디어가 떠오르기도 하고 말이다.</p><p>그럼, 이번 주의 뉴스 시작!</p><p><br /></p><hr /><h1 id=\"spatial-queries-with-mysql\">Spatial queries with MySQL</h1><p><a href=\"https://www.endpointdev.com/blog/2021/03/spatial-queries-with-mysql/\">(Link) Spatial queries with MySQL</a></p><p>MySQL에서는 공간 데이터, 연산을 지원하고 있다.</p><ul>  <li>포인트(좌표)/라인/폴리곤 등의 데이터들을 정의하고 저장할 수 있다.</li></ul><p><br /></p><p>중요한 것이 저장 뿐 아니라 Query를 통해 연산을 지원한다는 것이다.</p><p>공간 관계(Relation)함수와 연산(Operator)함수로 나뉜다.</p><ul>  <li>공간 관계함수: 두 공간 데이터 간의 관계를 연산해 반환한다.    <ul>      <li>동일한지?(<code class=\"language-plaintext highlighter-rouge\">ST_Equals</code>), 겹치는 곳이 있는지?(<code class=\"language-plaintext highlighter-rouge\">ST_Disjoint</code>, …), 안에 속하는지?(<code class=\"language-plaintext highlighter-rouge\">ST_Within</code>), 접점이 있는지?(<code class=\"language-plaintext highlighter-rouge\">ST_Touches</code>) 등</li>    </ul>  </li>  <li>공간 연산함수: 두 공간 데이터 간의 연산을 통해 새로운 공간 데이터를 반환한다.    <ul>      <li>교집합 공간 구하기(<code class=\"language-plaintext highlighter-rouge\">ST_Intersection</code>), 합집합 공간 구하기(<code class=\"language-plaintext highlighter-rouge\">ST_Union</code>), 차집합 공간 구하기(<code class=\"language-plaintext highlighter-rouge\">ST_Difference</code>), 최소 MBR(Minimum Bounding Rectangle) 폴리곤 구하기(<code class=\"language-plaintext highlighter-rouge\">ST_Envelope</code>) 등</li>    </ul>  </li></ul><p><br /></p><p>이 타입과 함수들을 사용하면 GPS 상의 데이터들로 여러 로직을 구성할 수 있다. 이번에 해커톤에서 GPS 좌표 데이터를 이용해 폴리곤을 구성했고, <code class=\"language-plaintext highlighter-rouge\">ST_Within</code> 연산을 통해 <a href=\"https://github.com/Hurry-Pizza/Mine-Server/blob/master/src/main/java/com/hurrypizza/mine/domain/path/PathRouteRepository.java#L35\">특정 폴리곤에 속하는 폴리곤들의 목록을 반환해주는 작업</a>을 진행했었다.</p><p>속도 측면에서 모르겠지만, 만약 고성능/복잡한 연산이 필요하다면 PostgreSQL의 PostGIS가 더 적합할 수 있다고 한다. 만약 MySQL을 사용하고 있고, Spatial data 저장 및 연산이 필요하다면 활용해보는 것도 좋을 것 같다.</p><p><br /></p><hr /><h1 id=\"infcon-2022\">INFCON 2022</h1><p><a href=\"https://www.inflearn.com/course/infcon2022\">(Link) INFCON 2022 보기</a></p><p><a href=\"https://www.inflearn.com/\">인프런 Inflearn</a>에서 주최한 컨퍼런스인 INFCON 2022가 코엑스에서 열렸다.</p><p>단순히 개발 언어/프레임워크에 초점을 맞춘 것이 아니라 ‘성장’에 초점을 맞춘 듯 했다. 그래서 그런지 가볍게 볼 수 있는? 또 다른 컨퍼런스에서 볼 수 없던? 강연들이 있어서 보기 좋았다.</p><ul>  <li>    <p>성공하는 스터디를 만드는 10가지 방법, 나와 팀을 성장시키는 리뷰들, 어느 날 고민 많은 주니어 개발자가 찾아왔다 등 성장에 초점을 맞춘 강연들이 있기도 하고,</p>  </li>  <li>    <p>서버비 0원 클라우드 큐 도입으로 해냈습니다!, 이 이력서 누구 거에요? 등 제목으로 관심이 쏠리는 강연들도 있다.</p>  </li></ul><p>아직 거의 보진 못했는데, 시간날 때마다 차차 보면 좋을 것 같다.</p><p><br /></p><hr /><h1 id=\"프로그래머가-이메일에-대해-믿는-거짓들\">프로그래머가 이메일에 대해 믿는 거짓들</h1><p><a href=\"https://news.hada.io/topic?id=7332&amp;utm_source=slack&amp;utm_medium=bot&amp;utm_campaign=T012P6ABDHQ\">(Link) 프로그래머가 이메일에 대해 믿는 거짓들</a></p><p>GeekNews에 소개된 글이다. 원본은 <a href=\"https://beesbuzz.biz/code/439-Falsehoods-programmers-believe-about-email\">여기</a>이다. <code class=\"language-plaintext highlighter-rouge\">개발자가 이메일을 활용한 로직을 구성할 때, 이러한 거짓들을 바탕으로 개발해서는 안된다</code>를 염두에 두고 작성한 글이다.</p><p>엄청나게 많은 거짓들?이 존재하는데, ‘엥, 이건 당연히 믿으면 안되는거 아니야?’라는 생각이 들다가도, ‘엥? 이건 맞는거 아니였어?’라는 생각도 든다.</p><p>웃겼던 항목이 <code class=\"language-plaintext highlighter-rouge\">사용자들이 자신이 이메일 주소를 알고 있다</code> 였다. 당연히 알 것이라고 생각하고 로직을 구성하지는 말자. (이메일 찾기라도 구성해놓자)</p><p><br /></p><hr /><h1 id=\"awesome-falsehood\">Awesome Falsehood</h1><p><a href=\"https://github.com/kdeldycke/awesome-falsehood\">(Link) Github Awesome Falsehood</a></p><p>위에서 언급한 이메일에 대해 믿는 거짓들 처럼, 여러 개발 항목들에 대해 믿는 거짓들을 큐레이팅하고 있는 Github 저장소이다.</p><p>Email 부터 Date/Time, Phone Numbers, Geography, Networks 등 항목들이 있다.</p><p>만약 해당 도메인을 다룬다거나 한다면, 개발 전에 한번 읽어보고 믿지 말아야 하는 것들을 리마인드 해보는 것도 좋겠다.</p><p><br /></p><hr /><h1 id=\"iphone-14-pro-및-iphone-14-pro-max\">iPhone 14 Pro 및 iPhone 14 Pro Max</h1><p><a href=\"https://www.apple.com/kr/newsroom/2022/09/apple-debuts-iphone-14-pro-and-iphone-14-pro-max/\">(Link) Apple, iPhone 14 Pro 및 iPhone 14 Pro Max 첫 공개</a></p><p>IPhone 14 Pro, IPhone 14 Pro Max가 공개되었다 (IPhone 14, AirPods Pro2, … 등도 함께 공되었다).</p><p>제일 인상 깊었던 것은 <code class=\"language-plaintext highlighter-rouge\">Dynamic Island</code>이다.</p><ul>  <li>기본적인 외형(폼팩터)은 차이가 별로 없지만, 펀치홀 디스플레이가 들어갔다. 근데 Apple은 이를 <code class=\"language-plaintext highlighter-rouge\">Dynamic Island</code>로 정의하고, 이 펀치홀 디자인을 적극적으로 활용한 UI를 추가했다.</li></ul><p>이전 안드로이드 진영에서도 전면 카메라를 최대한 숨기기 위한 방식으로 펀치홀 디스플레이를 많이 사용했으나, 이를 활용한 기능적 요소는 존재하지 않았다. 오히려 하드웨어 방면에서 더 나아가 펀치홀을 아예 없애는 기술들을 사용해왔다.</p><p>하지만 Apple은 Apple인가보다. 사람들에게 어색할 수 있는? 아름답게 느껴지지 않는 펀치홀 디자인을 UI요소로, 사용자와의 Interaction요소로 추가해 활용하고, 또 이에 맞는 완벽한 단어인 <code class=\"language-plaintext highlighter-rouge\">Dynamic Island</code> 로 마케팅을 한다니. 존경스럽다.</p><p><br /></p><hr /><h1 id=\"kubernetes-security-checklist\">Kubernetes Security Checklist</h1><p><a href=\"https://kubernetes.io/docs/concepts/security/security-checklist/\">(Link) Security Checklist</a></p><p>쿠버네티스 공식문서에서 제공하고 있는 보안 체크리스트이다.</p><p>어느정도 쿠버네티스를 활용할 줄 알고 사용하고 있다면, 해당 체크리스트를 통해 얼마나 잘 지키고 있는지 확인해보자.</p><ul>  <li>이 문서의 <code class=\"language-plaintext highlighter-rouge\">Caution</code>에서 설명하고 있듯 이 보안 체크리스트를 완벽히 했다고 보안적으로 완벽한 것은 아니다. 보안은 계속적인 관심(attention)과 향상(imporovement)가 중요하기 때문에 오히려 이 보안 체크리스트는 우수한 보안을 위한 첫 번째 스텝일 수 있다고 설명하고 있다.</li></ul><p><br /></p><p><code class=\"language-plaintext highlighter-rouge\">Authentication &amp; Authorization</code>, <code class=\"language-plaintext highlighter-rouge\">Network Security</code>, <code class=\"language-plaintext highlighter-rouge\">Pod Security</code>, <code class=\"language-plaintext highlighter-rouge\">Secrets</code> 등의 항목으로 체크리스트를 제공하고 있고, 하위에 그 항목에 대한 설명도 제공한다.</p><p>예를 들어, 아래와 같은 항목들이 있다.</p><ul>  <li><code class=\"language-plaintext highlighter-rouge\">ConfigMaps</code> 는 Confidential data를 가지고 있어서는 안된다.</li>  <li>Ingress, egress network policy가 클러스터의 모든 workload들에 적용되어져 있다.</li>  <li>컨테이너 이미지들은 불필요한 컨텐츠를 최소화한다.</li>  <li>컨테이너 이미지는 생성 및 배포 중에 정기적으로 스캔되며 취약하다고 알려진 소프트웨어는 패치된다.</li></ul><p><br /></p><hr /><h1 id=\"architecture-notes\">Architecture Notes</h1><p><a href=\"https://architecturenotes.co/\">(Link) Architecture Notes - System Design &amp; Software Architectures Explained</a></p><p>여러 기술의 아키텍처를 설명하는 사이트이다.</p><p>그림을 통해 Overview를 제공하고 글로 설명하는데, 엄청 깔끔하고 중요한 부분만 딱 적어놓았다.</p><p>메모리 타입, 암호화 방식 같은 기본적 요소에 대한 설명부터 데이터베이스에 대해 알아야하는 것들, 레디스 구조 등 많이 활용되는 애플리케이션에 대한 내용도 있다.</p><p>이것도 시간 날 때(심심할 때), 한번 씩 읽어보면 좋을 것 같다. 재밌는 내용이 많아 보인다.</p><p><br /></p>",
            "url": "https://kimdoubleb.github.io/news/2022/09/11/2-news",
            
            
            
            "tags": ["spatial","mysql","kubernetes","falsehood","iphone","architecture"],
            
            "date_published": "2022-09-11T00:00:00+09:00",
            "date_modified": "2022-09-11T00:00:00+09:00",
            
                "author":  {
                "name": "KimDoubleB",
                "url": null,
                "avatar": null
                }
                
            
        },
    
        {
            "id": "https://kimdoubleb.github.io/news/2022/09/04/1-news",
            "title": "#1 News",
            "summary": "2022.09.04 News",
            "content_text": "첫 News !여러가지 일로 갑자기 바빠져서 많이는 정리하지 못했다.다음엔 개발 뿐 아니라 여러 방면으로 더 넓혀가봐야겠다.Reactor expand와 Pagination(Link) Pagination in a reactive applicationReactor type(Mono, Flux)에서 expand method를 사용해 Pagination을 구현한 방법에 대해 설명한 글이다.사실 이번 글을 통해 expand method를 처음 알았다. BFS를 지원하는 메서드이며, 재귀적으로 data를 쌓아 조회할 수 있다. DFS를 위해서는 expandDeep method를 사용할 수 있다. 사용하는 법에 대해 잘 모르면 이 글을 참조하자.expand를 사용하면 특수한 경우의 Pagination를 구현할 수 있다. 위 글에서는 특정 조건의 모든 비디오를 조회하고 싶은 경우인데, Pagination이 구현되어있어 조건을 붙여서 조회하면 특정 페이지에 대해서만 결과물이 나와 문제가 있는 경우를 제시한다.이런 경우 따로 모든 비디오에 대해 특정 조건으로 검색하는 method를 만들거나 지원해야한다. 하지만 expand를 사용하면 여러 페이지를 재귀적으로 조회하며 조건에 맞는 모든 비디오를 찾을 수 있다.Flux&lt;Video&gt; getAllVideosByPlaylist(String playlistId) {    Flux&lt;PlaylistVideos&gt; expanded = getVideosByPlaylist(playlistId, null)        .expand(playlistVideos -&gt; {            var nextPageToken = playlistVideos.nextPageToken();            if (!StringUtils.hasText(nextPageToken)) {                // 마지막 페이지인 경우, empty를 반환해서 종료.                return Mono.empty();            }            else {                // 재귀적으로 데이터를 쌓을 수 있게 설정.                return getVideosByPlaylist(playlistId, nextPageToken);             }        });    return expanded        .flatMap(plv-&gt;Flux.fromIterable(plv.videos()));}이에 대해 직접 코드를 구성해 테스트 해보았는데, 필요한 상황에 활용하면 가독성을 향상 시키면서 깔끔하게 코드를 작성할 수 있을 것 같다.  근데 직접 Persistent Layer에서 이를 사용해 직접 쿼리를 DB로 날리게 구성하면, 재귀 횟수에 따라 특정 횟수 이상의 쿼리를 전송할 것 같다. 그런 것은 유의해야 되지 않을까?오픈소스 대체제가 나오는 데까지 걸리는 시간(Link) TIME TILL OPEN SOURCE ALTERNATIVEGeekNews에서 소개 된 글이다.상용 소프트웨어에 대한 오픈소스 대체제가 만들어지는데 평균적으로 7년이 걸린다고 한다.상용 소프트웨어의 오픈소스 대체제의 예시는 다음과 같다.  Unix -&gt; GNU/Linux  Photoshop -&gt; GIMP  1Password -&gt; Bitwarden  Slack -&gt; Mattermost7년이면 엄청 짧다고 생각했는데, 글에 의하면 독점 소프트웨어가 수익을 내기에는 충분한 시간이라고 한다.상용 서비스를 이미 도입한 업체에서는 다른 서비스(오픈소스…)로 변경하기 어렵다는 점도 생각해야할 것 같고, 오픈소스로 만들어진 대체제가 완벽히 모든 기능을 대체할 수 있는가도 고려해야할 것 같다.또 중요한게 오픈소스 대체제들은 거의 self hosted로 운영될 것 같은데, 이걸 고려하면 관리해야 할 담당자가 있어야 한다는 것을 의미하고, 그 대체제로부터 발생하는 문제의 책임은 누가 질 것인가도 생각해야 할 것 같다.  Slack 대신 Mattermost로 전환했다가 Server/DB가 날라가면 어떻게 될까…? (거의 그럴 일 없겠지만)기술이 발달되고 오픈소스 생태계가 확장됨에 따라 이런 7년이라는 시간도 점점 짧아지고 있다고 한다.  소프트웨어가 만들어지기 쉬워지기도 했고, 어느정도 유명한 오픈소스가 되면 많은 기여자들이 생겨 개발에 속도가 붙는 것도 영향이 있을 것 같다.옛날에도 소프트웨어를 만들어 돈을 번다는게 어렵다고 생각했는데, 이런 걸 보면 정말 독보적인게 아닌 이상 소프트웨어로 돈 벌기는 더 어려워지는 것 같다. 대신 다른 부분에서 돈을 벌 수 있는 방향이나 긍정적 영향이 늘어나겠지만 말이다.CountDownLatch 이용하기(Link) CountDownLatch 사용방법최근에 이전에 작성했던 코드를 보던 중 CountDownLatch를 사용해 테스트를 구성했던 것을 보게 되었다.작성할 땐, 찾아보면서 학습해 적용했던 것 같은데 (선배 개발자 분이 사용법을 설명해주시기도 했고) 오랫동안 활용을 안했더니 오랜만에 본 코드를 깔끔하게 이해할 수가 없었다 🥲. 그래서 이에 대해 다시 한 번 학습했다.CountDownLatch는 Concurrency (병행성)에 관련되어 Java에서 제공하는 기능이다 (java.util.concurrent 패키지 내 존재).큰 기능만 소개하면 여러 Thread를 관리할 때 다른 Thread 작업이 완료될 때까지 기다리게 만들 수 있다. 즉, Thread 간의 순서를 조작하는데 사용할 수 있다.간략히 설명하면 지원하는 기능은 다음과 같다.// CountDownLatch 선언 - 5개의 CountDown 설정CountDownLatch countDownLatch = new CountDownLatch(5);// Latch의 숫자가 1개씩 내려간다.countDownLatch.countDown();// Latch가 0이 될 때까지 기다린다.countDownLatch.await();// Latch가 0이 될 때까지 기다린다. 하지만 5초가 지나면, 그냥 다음 코드를 진행한다.countDownLatch.await(5, TimeUnit.SECONDS);코드에서 볼 수 있듯 await을 통해 Thread 작업을 묶어둘 수 있다.코드 흐름이 가끔 헷갈릴 수 있는데 Latch는 ‘자물쇠’라는 뜻으로 CountDownLatch는 ‘카운트 다운이 끝나면 열리는 자물쇠’라고 해석하면 이해하기 쉽다 (개인적인 의견).CountDownLatch를 활용해 아래와 같이 Test code를 구성했었다. (Code Link)@Testpublic void testWithSynchronousQueue() {    ThreadPoolBulkhead bulkhead = ThreadPoolBulkhead        .of(\"test\", ThreadPoolBulkheadConfig.custom()            .maxThreadPoolSize(2)            .coreThreadPoolSize(1)            .queueCapacity(0)            .build());    given(helloWorldService.returnHelloWorld()).willReturn(\"Hello world\");    CountDownLatch latch = new CountDownLatch(1);    bulkhead.executeRunnable(CheckedRunnable.of(latch::await).unchecked());    bulkhead.executeRunnable(CheckedRunnable.of(latch::await).unchecked());    assertThatThrownBy(() -&gt;         bulkhead.executeCallable(helloWorldService::returnHelloWorld))        .isInstanceOf(BulkheadFullException.class);    assertThat(bulkhead.getMetrics().getQueueDepth()).isZero();    assertThat(bulkhead.getMetrics().getRemainingQueueCapacity()).isZero();    assertThat(bulkhead.getMetrics().getQueueCapacity()).isZero();    assertThat(bulkhead.getMetrics().getActiveThreadCount()).isEqualTo(2);    assertThat(bulkhead.getMetrics().getThreadPoolSize()).isEqualTo(2);    latch.countDown();}  2개의 쓰레드를 멈춰놓고, Resilience4j bulkhead ThreadPool 값이 올바른가 확인하는 테스트 코드etc 디렉터리(Link) etc 디렉터리에 있는 소중한 아이들넷마블의 보안개발팀에서 작성한 기술 블로그이다. Linux /etc 디렉터리 내 보안적으로 중요한 설정파일들에 대해 이야기한다.사실 회사에서는 보안팀에서 관리 및 설정 해주셔서 직접 신경 쓸 생각을 못했는데, 간단하게 보기 좋았던 것 같다.  /etc/hosts 같은 경우 사내 사이트를 도메인으로 접속하기 위해 로컬에서 설정을 바꿔 활용하는 경우가 있는데, 이걸 이용해 불법적인 행위(해킹 등)을 할 수 있다는 것이 리마인드 됬다.위 글 말고도, 넷마블 보안팀에서 작성하는 것 같은데 관련 보안 시리즈 글들이 있다. Linux의 보안을 생각해야할 때 적혀있는 팁들이여서 필요할 때 훑어봐도 좋을 것 같다.Java 17 기능들(Link) 자바 17의 새로운 기능들, 3년 만에 LTS 버전 릴리즈!회사/혼자 개발할 때, 거의 Java 17을 사용하고 있다. LTS 버전이기도 하고, 버전이 올라갈 수록 편한 기능들과 성능적으로도 향상되었다고 알고 있기에 사용하고 있다.회사 내에서 Java 17을 도입할 때, 팀 내 리서치 공유 해주셨었는데 좀 써오다보니 맨날 쓰던 기능만 사용해서 어떤 기능들이 새로 생겼는지 맨날 까먹어서 이번에 다시 정리했다.  (주의) Java 17에서 새롭게 나온 기능이라기보다 Java 11과 비교했을 때 새로운 기능이다. Java 11 후의 버전에서 나온 기능들이라고 생각하면 된다.앗, 내가 맨날 사용한 Java 17 기능 (Java 11과 비교해)은 다음과 같다.  record 사용  String block 사용 (Query, Test code 때 사용하면 좋다)  Collectors.toList() 대신 Stream.toList() 사용위 기능들을 제외하고, 다른 새로운 기능들 중 살펴볼 만한 것은 다음과 같다.Pattern Matchinginstanceof를 통해 type conversion을 하며 사용했었는데, type conversion을 따로 수동으로 작성해주지 않아도 뒤에 변환 할 변수명을 선언해줌으로써 바로 사용할 수 있다.// AS-ISif (user instanceof OAuthUser) {    // type conversion 필요    OAuthUser oauthUser = (OAuthUser) user;     // ... }// TO-BEif (user instanceof OAuthUser oauthUser) {    // type conversion 불필욘    // ...}switch문에서도 이를 활용할 수 있다 (Preview여서 설정 따로 필요).// AS-ISstatic double getDoubleUsingIf(Object o) {    double result;    if (o instanceof Integer) {        result = ((Integer) o).doubleValue();    } else if (o instanceof Float) {        result = ((Float) o).doubleValue();    } else if (o instanceof String) {        result = Double.parseDouble(((String) o));    } else {        result = 0d;    }    return result;}// TO-BEstatic double getDoubleUsingSwitch(Object o) {    return switch (o) {        case Integer i -&gt; i.doubleValue();        case Float f -&gt; f.doubleValue();        case String s -&gt; Double.parseDouble(s);        default -&gt; 0d;    };}Sealed classes말 그대로 클래스를 봉인하는 기능. ‘엥 그럼 final과 뭐가 다르지?’ 할 수 있는데, final class는 절대 상속이 불가능하지만 sealed class는 허용할 class만이 상속해 확장할 수 있다.  봉인(sealed), 허용(permit), 봉인해제(non-sealed) 키워드들이 사용된다.아래 코드는 위 참조 링크에서 나온 예시.// `Person`는 허용된(permits) 서브 클래스만 확장할 수 있다.sealed class Person    permits Developer, Designer {}// `Developer` 클래스는 봉인이 해제되었다.non-sealed class Developer extends Person {}// 봉인이 해제된 `Student` 클래스는 다른 서브 클래스에서 확장 가능하다.// 그리고 자기 자신을 Developer 봉인(sealed)할 수 있다. sealed class Student extends Developer     permits HighSchoolStudent, MiddleSchoolStudent {    // 이 클래스는 `HighSchoolStudent`, `MiddleSchoolStudent` 클래스만 확장 가능하다.}// permitted 서브 클래스는 확장을 못하게 하거나(final),// 서브 클래스를 가진채로 자신을 봉인하거나(sealed), 봉인을 해제(non-sealed)해야만 한다.final class HighSchoolStudent extends Student {}non-sealed class MiddleSchoolStudent extends Student {}Stable Diffusion(Link) Stable Diffusion Is the Most Important AI Art Model Ever요즘 딥러닝, 더 자세히 말하면 Computer vision 쪽에서는 이미지를 만들어내는 기술들이 핫한 것 같다.얼마 전까지 DALL·E 2를 접하고 정말 딥러닝이 갈수록 대단하구나 하는 생각이 들었다. 역시 미래는 여긴가… 이런 생각도 하고….  DALL·E 2는 특정 Sentence를 입력하면 그에 대한 이미지를 생성하는 학습 모델이다.이번엔 오픈소스로 나온 Stable Diffusion도 DALL·E 2보다 우수한 품질의 이미지를 생성하는 모델이라고 한다.직접 Dreamstudio에서 문장을 통해 생성할 수 있다. 직접 해봤는데, 어느정도 정확한?(상상했던?) 이미지가 나온다.이러한 모델, 서비스를 보면 이미지 생성이라는 핵심을 통해 여러 서비스로 전파가 될 수 있지 않을까 싶다.  게임? 예술 교육? Getty images 같은 이미지 판매?이런 트렌드를 놓치고 있지 않아야 겠다는 생각이 든다.",
            "content_html": "<p>첫 News !</p><p>여러가지 일로 갑자기 바빠져서 많이는 정리하지 못했다.</p><p>다음엔 개발 뿐 아니라 여러 방면으로 더 넓혀가봐야겠다.</p><p><br /></p><hr /><h1 id=\"reactor-expand와-pagination\">Reactor expand와 Pagination</h1><p><a href=\"https://joshlong.com/jl/blogpost/pagination_in_a_reactive_application.html\">(Link) Pagination in a reactive application</a></p><p>Reactor type(Mono, Flux)에서 <code class=\"language-plaintext highlighter-rouge\">expand</code> method를 사용해 Pagination을 구현한 방법에 대해 설명한 글이다.</p><p>사실 이번 글을 통해 <code class=\"language-plaintext highlighter-rouge\">expand</code> method를 처음 알았다. BFS를 지원하는 메서드이며, 재귀적으로 data를 쌓아 조회할 수 있다. DFS를 위해서는 <code class=\"language-plaintext highlighter-rouge\">expandDeep</code> method를 사용할 수 있다. 사용하는 법에 대해 잘 모르면 <a href=\"https://www.vinsguru.com/flux-expand-vs-expanddeep/\">이 글을 참조</a>하자.</p><p><code class=\"language-plaintext highlighter-rouge\">expand</code>를 사용하면 특수한 경우의 Pagination를 구현할 수 있다. 위 글에서는 특정 조건의 모든 비디오를 조회하고 싶은 경우인데, Pagination이 구현되어있어 조건을 붙여서 조회하면 특정 페이지에 대해서만 결과물이 나와 문제가 있는 경우를 제시한다.</p><p>이런 경우 따로 모든 비디오에 대해 특정 조건으로 검색하는 method를 만들거나 지원해야한다. 하지만 <code class=\"language-plaintext highlighter-rouge\">expand</code>를 사용하면 여러 페이지를 재귀적으로 조회하며 조건에 맞는 모든 비디오를 찾을 수 있다.</p><div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"nc\">Flux</span><span class=\"o\">&lt;</span><span class=\"nc\">Video</span><span class=\"o\">&gt;</span> <span class=\"nf\">getAllVideosByPlaylist</span><span class=\"o\">(</span><span class=\"nc\">String</span> <span class=\"n\">playlistId</span><span class=\"o\">)</span> <span class=\"o\">{</span>    <span class=\"nc\">Flux</span><span class=\"o\">&lt;</span><span class=\"nc\">PlaylistVideos</span><span class=\"o\">&gt;</span> <span class=\"n\">expanded</span> <span class=\"o\">=</span> <span class=\"n\">getVideosByPlaylist</span><span class=\"o\">(</span><span class=\"n\">playlistId</span><span class=\"o\">,</span> <span class=\"kc\">null</span><span class=\"o\">)</span>        <span class=\"o\">.</span><span class=\"na\">expand</span><span class=\"o\">(</span><span class=\"n\">playlistVideos</span> <span class=\"o\">-&gt;</span> <span class=\"o\">{</span>            <span class=\"kt\">var</span> <span class=\"n\">nextPageToken</span> <span class=\"o\">=</span> <span class=\"n\">playlistVideos</span><span class=\"o\">.</span><span class=\"na\">nextPageToken</span><span class=\"o\">();</span>            <span class=\"k\">if</span> <span class=\"o\">(!</span><span class=\"nc\">StringUtils</span><span class=\"o\">.</span><span class=\"na\">hasText</span><span class=\"o\">(</span><span class=\"n\">nextPageToken</span><span class=\"o\">))</span> <span class=\"o\">{</span>                <span class=\"c1\">// 마지막 페이지인 경우, empty를 반환해서 종료.</span>                <span class=\"k\">return</span> <span class=\"nc\">Mono</span><span class=\"o\">.</span><span class=\"na\">empty</span><span class=\"o\">();</span>            <span class=\"o\">}</span>            <span class=\"k\">else</span> <span class=\"o\">{</span>                <span class=\"c1\">// 재귀적으로 데이터를 쌓을 수 있게 설정.</span>                <span class=\"k\">return</span> <span class=\"nf\">getVideosByPlaylist</span><span class=\"o\">(</span><span class=\"n\">playlistId</span><span class=\"o\">,</span> <span class=\"n\">nextPageToken</span><span class=\"o\">);</span>             <span class=\"o\">}</span>        <span class=\"o\">});</span>    <span class=\"k\">return</span> <span class=\"n\">expanded</span>        <span class=\"o\">.</span><span class=\"na\">flatMap</span><span class=\"o\">(</span><span class=\"n\">plv</span><span class=\"o\">-&gt;</span><span class=\"nc\">Flux</span><span class=\"o\">.</span><span class=\"na\">fromIterable</span><span class=\"o\">(</span><span class=\"n\">plv</span><span class=\"o\">.</span><span class=\"na\">videos</span><span class=\"o\">()));</span><span class=\"o\">}</span></code></pre></div></div><p>이에 대해 <a href=\"https://github.com/KimDoubleB/spring-learning/blob/master/reactor-exapnd/src/main/java/com/example/reactorexapnd/ReactorExapndTest.java#L27-L33\">직접 코드를 구성해 테스트</a> 해보았는데, 필요한 상황에 활용하면 가독성을 향상 시키면서 깔끔하게 코드를 작성할 수 있을 것 같다.</p><blockquote>  <p>근데 직접 Persistent Layer에서 이를 사용해 직접 쿼리를 DB로 날리게 구성하면, 재귀 횟수에 따라 특정 횟수 이상의 쿼리를 전송할 것 같다. 그런 것은 유의해야 되지 않을까?</p></blockquote><p><br /></p><hr /><h1 id=\"오픈소스-대체제가-나오는-데까지-걸리는-시간\">오픈소스 대체제가 나오는 데까지 걸리는 시간</h1><p><a href=\"https://staltz.com/time-till-open-source-alternative.html\">(Link) TIME TILL OPEN SOURCE ALTERNATIVE</a></p><p><a href=\"https://news.hada.io/topic?id=7281&amp;utm_source=slack&amp;utm_medium=bot&amp;utm_campaign=T012P6ABDHQ\">GeekNews에서 소개 된 글</a>이다.</p><p>상용 소프트웨어에 대한 오픈소스 대체제가 만들어지는데 평균적으로 7년이 걸린다고 한다.</p><p><code class=\"language-plaintext highlighter-rouge\">상용 소프트웨어의 오픈소스 대체제</code>의 예시는 다음과 같다.</p><ul>  <li>Unix -&gt; GNU/Linux</li>  <li>Photoshop -&gt; GIMP</li>  <li>1Password -&gt; Bitwarden</li>  <li>Slack -&gt; Mattermost</li></ul><p>7년이면 엄청 짧다고 생각했는데, 글에 의하면 <em>독점 소프트웨어가 수익을 내기에는 충분한 시간</em>이라고 한다.</p><p>상용 서비스를 이미 도입한 업체에서는 다른 서비스(오픈소스…)로 변경하기 어렵다는 점도 생각해야할 것 같고, 오픈소스로 만들어진 대체제가 완벽히 모든 기능을 대체할 수 있는가도 고려해야할 것 같다.</p><p>또 중요한게 오픈소스 대체제들은 거의 self hosted로 운영될 것 같은데, 이걸 고려하면 관리해야 할 담당자가 있어야 한다는 것을 의미하고, 그 대체제로부터 발생하는 문제의 책임은 누가 질 것인가도 생각해야 할 것 같다.</p><blockquote>  <p>Slack 대신 Mattermost로 전환했다가 Server/DB가 날라가면 어떻게 될까…? (거의 그럴 일 없겠지만)</p></blockquote><p><br /></p><p>기술이 발달되고 오픈소스 생태계가 확장됨에 따라 이런 7년이라는 시간도 점점 짧아지고 있다고 한다.</p><ul>  <li>소프트웨어가 만들어지기 쉬워지기도 했고, 어느정도 유명한 오픈소스가 되면 많은 기여자들이 생겨 개발에 속도가 붙는 것도 영향이 있을 것 같다.</li></ul><p>옛날에도 소프트웨어를 만들어 돈을 번다는게 어렵다고 생각했는데, 이런 걸 보면 정말 독보적인게 아닌 이상 소프트웨어로 돈 벌기는 더 어려워지는 것 같다. 대신 다른 부분에서 돈을 벌 수 있는 방향이나 긍정적 영향이 늘어나겠지만 말이다.</p><p><br /></p><hr /><h1 id=\"countdownlatch-이용하기\">CountDownLatch 이용하기</h1><p><a href=\"https://codechacha.com/ko/java-countdownlatch/\">(Link) CountDownLatch 사용방법</a></p><p>최근에 이전에 작성했던 코드를 보던 중 <code class=\"language-plaintext highlighter-rouge\">CountDownLatch</code>를 사용해 테스트를 구성했던 것을 보게 되었다.</p><p>작성할 땐, 찾아보면서 학습해 적용했던 것 같은데 (선배 개발자 분이 사용법을 설명해주시기도 했고) 오랫동안 활용을 안했더니 오랜만에 본 코드를 깔끔하게 이해할 수가 없었다 🥲. 그래서 이에 대해 다시 한 번 학습했다.</p><p><code class=\"language-plaintext highlighter-rouge\">CountDownLatch</code>는 Concurrency (병행성)에 관련되어 Java에서 제공하는 기능이다 (<code class=\"language-plaintext highlighter-rouge\">java.util.concurrent</code> 패키지 내 존재).</p><p>큰 기능만 소개하면 여러 Thread를 관리할 때 다른 Thread 작업이 완료될 때까지 기다리게 만들 수 있다. 즉, Thread 간의 순서를 조작하는데 사용할 수 있다.</p><p>간략히 설명하면 지원하는 기능은 다음과 같다.</p><div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"c1\">// CountDownLatch 선언 - 5개의 CountDown 설정</span><span class=\"nc\">CountDownLatch</span> <span class=\"n\">countDownLatch</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"nc\">CountDownLatch</span><span class=\"o\">(</span><span class=\"mi\">5</span><span class=\"o\">);</span><span class=\"c1\">// Latch의 숫자가 1개씩 내려간다.</span><span class=\"n\">countDownLatch</span><span class=\"o\">.</span><span class=\"na\">countDown</span><span class=\"o\">();</span><span class=\"c1\">// Latch가 0이 될 때까지 기다린다.</span><span class=\"n\">countDownLatch</span><span class=\"o\">.</span><span class=\"na\">await</span><span class=\"o\">();</span><span class=\"c1\">// Latch가 0이 될 때까지 기다린다. 하지만 5초가 지나면, 그냥 다음 코드를 진행한다.</span><span class=\"n\">countDownLatch</span><span class=\"o\">.</span><span class=\"na\">await</span><span class=\"o\">(</span><span class=\"mi\">5</span><span class=\"o\">,</span> <span class=\"nc\">TimeUnit</span><span class=\"o\">.</span><span class=\"na\">SECONDS</span><span class=\"o\">);</span></code></pre></div></div><p>코드에서 볼 수 있듯 <code class=\"language-plaintext highlighter-rouge\">await</code>을 통해 Thread 작업을 묶어둘 수 있다.</p><p>코드 흐름이 가끔 헷갈릴 수 있는데 <code class=\"language-plaintext highlighter-rouge\">Latch</code>는 ‘자물쇠’라는 뜻으로 <code class=\"language-plaintext highlighter-rouge\">CountDownLatch</code>는 ‘카운트 다운이 끝나면 열리는 자물쇠’라고 해석하면 이해하기 쉽다 (개인적인 의견).</p><p><code class=\"language-plaintext highlighter-rouge\">CountDownLatch</code>를 활용해 아래와 같이 Test code를 구성했었다. (<a href=\"https://github.com/resilience4j/resilience4j/blob/19e8b5e5835b219938ae7a787583ed0b08ee1956/resilience4j-bulkhead/src/test/java/io/github/resilience4j/bulkhead/ThreadPoolBulkheadTest.java#L213-L235\">Code Link</a>)</p><div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"nd\">@Test</span><span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">testWithSynchronousQueue</span><span class=\"o\">()</span> <span class=\"o\">{</span>    <span class=\"nc\">ThreadPoolBulkhead</span> <span class=\"n\">bulkhead</span> <span class=\"o\">=</span> <span class=\"nc\">ThreadPoolBulkhead</span>        <span class=\"o\">.</span><span class=\"na\">of</span><span class=\"o\">(</span><span class=\"s\">\"test\"</span><span class=\"o\">,</span> <span class=\"nc\">ThreadPoolBulkheadConfig</span><span class=\"o\">.</span><span class=\"na\">custom</span><span class=\"o\">()</span>            <span class=\"o\">.</span><span class=\"na\">maxThreadPoolSize</span><span class=\"o\">(</span><span class=\"mi\">2</span><span class=\"o\">)</span>            <span class=\"o\">.</span><span class=\"na\">coreThreadPoolSize</span><span class=\"o\">(</span><span class=\"mi\">1</span><span class=\"o\">)</span>            <span class=\"o\">.</span><span class=\"na\">queueCapacity</span><span class=\"o\">(</span><span class=\"mi\">0</span><span class=\"o\">)</span>            <span class=\"o\">.</span><span class=\"na\">build</span><span class=\"o\">());</span>    <span class=\"n\">given</span><span class=\"o\">(</span><span class=\"n\">helloWorldService</span><span class=\"o\">.</span><span class=\"na\">returnHelloWorld</span><span class=\"o\">()).</span><span class=\"na\">willReturn</span><span class=\"o\">(</span><span class=\"s\">\"Hello world\"</span><span class=\"o\">);</span>    <span class=\"nc\">CountDownLatch</span> <span class=\"n\">latch</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"nc\">CountDownLatch</span><span class=\"o\">(</span><span class=\"mi\">1</span><span class=\"o\">);</span>    <span class=\"n\">bulkhead</span><span class=\"o\">.</span><span class=\"na\">executeRunnable</span><span class=\"o\">(</span><span class=\"nc\">CheckedRunnable</span><span class=\"o\">.</span><span class=\"na\">of</span><span class=\"o\">(</span><span class=\"nl\">latch:</span><span class=\"o\">:</span><span class=\"n\">await</span><span class=\"o\">).</span><span class=\"na\">unchecked</span><span class=\"o\">());</span>    <span class=\"n\">bulkhead</span><span class=\"o\">.</span><span class=\"na\">executeRunnable</span><span class=\"o\">(</span><span class=\"nc\">CheckedRunnable</span><span class=\"o\">.</span><span class=\"na\">of</span><span class=\"o\">(</span><span class=\"nl\">latch:</span><span class=\"o\">:</span><span class=\"n\">await</span><span class=\"o\">).</span><span class=\"na\">unchecked</span><span class=\"o\">());</span>    <span class=\"n\">assertThatThrownBy</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span>         <span class=\"n\">bulkhead</span><span class=\"o\">.</span><span class=\"na\">executeCallable</span><span class=\"o\">(</span><span class=\"nl\">helloWorldService:</span><span class=\"o\">:</span><span class=\"n\">returnHelloWorld</span><span class=\"o\">))</span>        <span class=\"o\">.</span><span class=\"na\">isInstanceOf</span><span class=\"o\">(</span><span class=\"nc\">BulkheadFullException</span><span class=\"o\">.</span><span class=\"na\">class</span><span class=\"o\">);</span>    <span class=\"n\">assertThat</span><span class=\"o\">(</span><span class=\"n\">bulkhead</span><span class=\"o\">.</span><span class=\"na\">getMetrics</span><span class=\"o\">().</span><span class=\"na\">getQueueDepth</span><span class=\"o\">()).</span><span class=\"na\">isZero</span><span class=\"o\">();</span>    <span class=\"n\">assertThat</span><span class=\"o\">(</span><span class=\"n\">bulkhead</span><span class=\"o\">.</span><span class=\"na\">getMetrics</span><span class=\"o\">().</span><span class=\"na\">getRemainingQueueCapacity</span><span class=\"o\">()).</span><span class=\"na\">isZero</span><span class=\"o\">();</span>    <span class=\"n\">assertThat</span><span class=\"o\">(</span><span class=\"n\">bulkhead</span><span class=\"o\">.</span><span class=\"na\">getMetrics</span><span class=\"o\">().</span><span class=\"na\">getQueueCapacity</span><span class=\"o\">()).</span><span class=\"na\">isZero</span><span class=\"o\">();</span>    <span class=\"n\">assertThat</span><span class=\"o\">(</span><span class=\"n\">bulkhead</span><span class=\"o\">.</span><span class=\"na\">getMetrics</span><span class=\"o\">().</span><span class=\"na\">getActiveThreadCount</span><span class=\"o\">()).</span><span class=\"na\">isEqualTo</span><span class=\"o\">(</span><span class=\"mi\">2</span><span class=\"o\">);</span>    <span class=\"n\">assertThat</span><span class=\"o\">(</span><span class=\"n\">bulkhead</span><span class=\"o\">.</span><span class=\"na\">getMetrics</span><span class=\"o\">().</span><span class=\"na\">getThreadPoolSize</span><span class=\"o\">()).</span><span class=\"na\">isEqualTo</span><span class=\"o\">(</span><span class=\"mi\">2</span><span class=\"o\">);</span>    <span class=\"n\">latch</span><span class=\"o\">.</span><span class=\"na\">countDown</span><span class=\"o\">();</span><span class=\"o\">}</span></code></pre></div></div><ul>  <li>2개의 쓰레드를 멈춰놓고, Resilience4j bulkhead ThreadPool 값이 올바른가 확인하는 테스트 코드</li></ul><p><br /></p><hr /><h1 id=\"etc-디렉터리\">etc 디렉터리</h1><p><a href=\"https://netmarble.engineering/watch-out-important-files-in-etc-directory/?fbclid=IwAR3oCtQmWQDCHEEIazydZJ3k4zDAVD_TLTeJCULCBsUMGxWg8VBC7qGJYEw\">(Link) etc 디렉터리에 있는 소중한 아이들</a></p><p>넷마블의 보안개발팀에서 작성한 기술 블로그이다. Linux <code class=\"language-plaintext highlighter-rouge\">/etc</code> 디렉터리 내 보안적으로 중요한 설정파일들에 대해 이야기한다.</p><p>사실 회사에서는 보안팀에서 관리 및 설정 해주셔서 직접 신경 쓸 생각을 못했는데, 간단하게 보기 좋았던 것 같다.</p><ul>  <li><code class=\"language-plaintext highlighter-rouge\">/etc/hosts</code> 같은 경우 사내 사이트를 도메인으로 접속하기 위해 로컬에서 설정을 바꿔 활용하는 경우가 있는데, 이걸 이용해 불법적인 행위(해킹 등)을 할 수 있다는 것이 리마인드 됬다.</li></ul><p>위 글 말고도, 넷마블 보안팀에서 작성하는 것 같은데 <a href=\"https://netmarble.engineering/tag/%ec%97%ac%ea%b8%b0%eb%b3%b4%ea%b8%b0/\">관련 보안 시리즈 글들</a>이 있다. Linux의 보안을 생각해야할 때 적혀있는 팁들이여서 필요할 때 훑어봐도 좋을 것 같다.</p><p><br /></p><hr /><h1 id=\"java-17-기능들\">Java 17 기능들</h1><p><a href=\"https://madplay.github.io/post/what-is-new-java-17\">(Link) 자바 17의 새로운 기능들, 3년 만에 LTS 버전 릴리즈!</a></p><p>회사/혼자 개발할 때, 거의 Java 17을 사용하고 있다. LTS 버전이기도 하고, 버전이 올라갈 수록 편한 기능들과 성능적으로도 향상되었다고 알고 있기에 사용하고 있다.</p><p>회사 내에서 Java 17을 도입할 때, 팀 내 리서치 공유 해주셨었는데 좀 써오다보니 맨날 쓰던 기능만 사용해서 어떤 기능들이 새로 생겼는지 맨날 까먹어서 이번에 다시 정리했다.</p><blockquote>  <p>(주의) Java 17에서 새롭게 나온 기능이라기보다 Java 11과 비교했을 때 새로운 기능이다. Java 11 후의 버전에서 나온 기능들이라고 생각하면 된다.</p></blockquote><p>앗, 내가 맨날 사용한 Java 17 기능 (Java 11과 비교해)은 다음과 같다.</p><ul>  <li><code class=\"language-plaintext highlighter-rouge\">record</code> 사용</li>  <li>String block 사용 (Query, Test code 때 사용하면 좋다)</li>  <li><code class=\"language-plaintext highlighter-rouge\">Collectors.toList()</code> 대신 <code class=\"language-plaintext highlighter-rouge\">Stream.toList()</code> 사용</li></ul><p>위 기능들을 제외하고, 다른 새로운 기능들 중 살펴볼 만한 것은 다음과 같다.</p><h3 id=\"pattern-matching\">Pattern Matching</h3><p><code class=\"language-plaintext highlighter-rouge\">instanceof</code>를 통해 type conversion을 하며 사용했었는데, type conversion을 따로 수동으로 작성해주지 않아도 뒤에 변환 할 변수명을 선언해줌으로써 바로 사용할 수 있다.</p><div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"c1\">// AS-IS</span><span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">user</span> <span class=\"k\">instanceof</span> <span class=\"nc\">OAuthUser</span><span class=\"o\">)</span> <span class=\"o\">{</span>    <span class=\"c1\">// type conversion 필요</span>    <span class=\"nc\">OAuthUser</span> <span class=\"n\">oauthUser</span> <span class=\"o\">=</span> <span class=\"o\">(</span><span class=\"nc\">OAuthUser</span><span class=\"o\">)</span> <span class=\"n\">user</span><span class=\"o\">;</span>     <span class=\"c1\">// ... </span><span class=\"o\">}</span><span class=\"c1\">// TO-BE</span><span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">user</span> <span class=\"k\">instanceof</span> <span class=\"nc\">OAuthUser</span> <span class=\"n\">oauthUser</span><span class=\"o\">)</span> <span class=\"o\">{</span>    <span class=\"c1\">// type conversion 불필욘</span>    <span class=\"c1\">// ...</span><span class=\"o\">}</span></code></pre></div></div><p><code class=\"language-plaintext highlighter-rouge\">switch</code>문에서도 이를 활용할 수 있다 (Preview여서 설정 따로 필요).</p><div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"c1\">// AS-IS</span><span class=\"kd\">static</span> <span class=\"kt\">double</span> <span class=\"nf\">getDoubleUsingIf</span><span class=\"o\">(</span><span class=\"nc\">Object</span> <span class=\"n\">o</span><span class=\"o\">)</span> <span class=\"o\">{</span>    <span class=\"kt\">double</span> <span class=\"n\">result</span><span class=\"o\">;</span>    <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">o</span> <span class=\"k\">instanceof</span> <span class=\"nc\">Integer</span><span class=\"o\">)</span> <span class=\"o\">{</span>        <span class=\"n\">result</span> <span class=\"o\">=</span> <span class=\"o\">((</span><span class=\"nc\">Integer</span><span class=\"o\">)</span> <span class=\"n\">o</span><span class=\"o\">).</span><span class=\"na\">doubleValue</span><span class=\"o\">();</span>    <span class=\"o\">}</span> <span class=\"k\">else</span> <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">o</span> <span class=\"k\">instanceof</span> <span class=\"nc\">Float</span><span class=\"o\">)</span> <span class=\"o\">{</span>        <span class=\"n\">result</span> <span class=\"o\">=</span> <span class=\"o\">((</span><span class=\"nc\">Float</span><span class=\"o\">)</span> <span class=\"n\">o</span><span class=\"o\">).</span><span class=\"na\">doubleValue</span><span class=\"o\">();</span>    <span class=\"o\">}</span> <span class=\"k\">else</span> <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">o</span> <span class=\"k\">instanceof</span> <span class=\"nc\">String</span><span class=\"o\">)</span> <span class=\"o\">{</span>        <span class=\"n\">result</span> <span class=\"o\">=</span> <span class=\"nc\">Double</span><span class=\"o\">.</span><span class=\"na\">parseDouble</span><span class=\"o\">(((</span><span class=\"nc\">String</span><span class=\"o\">)</span> <span class=\"n\">o</span><span class=\"o\">));</span>    <span class=\"o\">}</span> <span class=\"k\">else</span> <span class=\"o\">{</span>        <span class=\"n\">result</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"n\">d</span><span class=\"o\">;</span>    <span class=\"o\">}</span>    <span class=\"k\">return</span> <span class=\"n\">result</span><span class=\"o\">;</span><span class=\"o\">}</span><span class=\"c1\">// TO-BE</span><span class=\"kd\">static</span> <span class=\"kt\">double</span> <span class=\"nf\">getDoubleUsingSwitch</span><span class=\"o\">(</span><span class=\"nc\">Object</span> <span class=\"n\">o</span><span class=\"o\">)</span> <span class=\"o\">{</span>    <span class=\"k\">return</span> <span class=\"nf\">switch</span> <span class=\"o\">(</span><span class=\"n\">o</span><span class=\"o\">)</span> <span class=\"o\">{</span>        <span class=\"k\">case</span> <span class=\"nc\">Integer</span> <span class=\"n\">i</span> <span class=\"o\">-&gt;</span> <span class=\"n\">i</span><span class=\"o\">.</span><span class=\"na\">doubleValue</span><span class=\"o\">();</span>        <span class=\"k\">case</span> <span class=\"nc\">Float</span> <span class=\"n\">f</span> <span class=\"o\">-&gt;</span> <span class=\"n\">f</span><span class=\"o\">.</span><span class=\"na\">doubleValue</span><span class=\"o\">();</span>        <span class=\"k\">case</span> <span class=\"nc\">String</span> <span class=\"n\">s</span> <span class=\"o\">-&gt;</span> <span class=\"nc\">Double</span><span class=\"o\">.</span><span class=\"na\">parseDouble</span><span class=\"o\">(</span><span class=\"n\">s</span><span class=\"o\">);</span>        <span class=\"k\">default</span> <span class=\"o\">-&gt;</span> <span class=\"mi\">0</span><span class=\"n\">d</span><span class=\"o\">;</span>    <span class=\"o\">};</span><span class=\"o\">}</span></code></pre></div></div><h3 id=\"sealed-classes\">Sealed classes</h3><p>말 그대로 클래스를 봉인하는 기능. ‘엥 그럼 <code class=\"language-plaintext highlighter-rouge\">final</code>과 뭐가 다르지?’ 할 수 있는데, <code class=\"language-plaintext highlighter-rouge\">final</code> class는 절대 상속이 불가능하지만 <code class=\"language-plaintext highlighter-rouge\">sealed</code> class는 허용할 class만이 상속해 확장할 수 있다.</p><ul>  <li>봉인(<code class=\"language-plaintext highlighter-rouge\">sealed</code>), 허용(<code class=\"language-plaintext highlighter-rouge\">permit</code>), 봉인해제(<code class=\"language-plaintext highlighter-rouge\">non-sealed</code>) 키워드들이 사용된다.</li></ul><p>아래 코드는 <a href=\"https://madplay.github.io/post/what-is-new-java-17\">위 참조 링크</a>에서 나온 예시.</p><div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"c1\">// `Person`는 허용된(permits) 서브 클래스만 확장할 수 있다.</span><span class=\"n\">sealed</span> <span class=\"kd\">class</span> <span class=\"nc\">Person</span>    <span class=\"n\">permits</span> <span class=\"nc\">Developer</span><span class=\"o\">,</span> <span class=\"nc\">Designer</span> <span class=\"o\">{</span><span class=\"o\">}</span><span class=\"c1\">// `Developer` 클래스는 봉인이 해제되었다.</span><span class=\"n\">non</span><span class=\"o\">-</span><span class=\"n\">sealed</span> <span class=\"kd\">class</span> <span class=\"nc\">Developer</span> <span class=\"kd\">extends</span> <span class=\"nc\">Person</span> <span class=\"o\">{</span><span class=\"o\">}</span><span class=\"c1\">// 봉인이 해제된 `Student` 클래스는 다른 서브 클래스에서 확장 가능하다.</span><span class=\"c1\">// 그리고 자기 자신을 Developer 봉인(sealed)할 수 있다. </span><span class=\"n\">sealed</span> <span class=\"kd\">class</span> <span class=\"nc\">Student</span> <span class=\"kd\">extends</span> <span class=\"nc\">Developer</span>     <span class=\"n\">permits</span> <span class=\"nc\">HighSchoolStudent</span><span class=\"o\">,</span> <span class=\"nc\">MiddleSchoolStudent</span> <span class=\"o\">{</span>    <span class=\"c1\">// 이 클래스는 `HighSchoolStudent`, `MiddleSchoolStudent` 클래스만 확장 가능하다.</span><span class=\"o\">}</span><span class=\"c1\">// permitted 서브 클래스는 확장을 못하게 하거나(final),</span><span class=\"c1\">// 서브 클래스를 가진채로 자신을 봉인하거나(sealed), 봉인을 해제(non-sealed)해야만 한다.</span><span class=\"kd\">final</span> <span class=\"kd\">class</span> <span class=\"nc\">HighSchoolStudent</span> <span class=\"kd\">extends</span> <span class=\"nc\">Student</span> <span class=\"o\">{</span><span class=\"o\">}</span><span class=\"n\">non</span><span class=\"o\">-</span><span class=\"n\">sealed</span> <span class=\"kd\">class</span> <span class=\"nc\">MiddleSchoolStudent</span> <span class=\"kd\">extends</span> <span class=\"nc\">Student</span> <span class=\"o\">{</span><span class=\"o\">}</span></code></pre></div></div><p><br /></p><hr /><h1 id=\"stable-diffusion\">Stable Diffusion</h1><p><a href=\"https://thealgorithmicbridge.substack.com/p/stable-diffusion-is-the-most-important\">(Link) Stable Diffusion Is the Most Important AI Art Model Ever</a></p><p>요즘 딥러닝, 더 자세히 말하면 Computer vision 쪽에서는 이미지를 만들어내는 기술들이 핫한 것 같다.</p><p>얼마 전까지 <a href=\"https://openai.com/dall-e-2/\">DALL·E 2</a>를 접하고 정말 딥러닝이 갈수록 대단하구나 하는 생각이 들었다. 역시 미래는 여긴가… 이런 생각도 하고….</p><ul>  <li>DALL·E 2는 특정 Sentence를 입력하면 그에 대한 이미지를 생성하는 학습 모델이다.</li></ul><p>이번엔 오픈소스로 나온 <code class=\"language-plaintext highlighter-rouge\">Stable Diffusion</code>도 DALL·E 2보다 우수한 품질의 이미지를 생성하는 모델이라고 한다.직접 <a href=\"https://beta.dreamstudio.ai/dream\">Dreamstudio</a>에서 문장을 통해 생성할 수 있다. 직접 해봤는데, 어느정도 정확한?(상상했던?) 이미지가 나온다.</p><p>이러한 모델, 서비스를 보면 <code class=\"language-plaintext highlighter-rouge\">이미지 생성</code>이라는 핵심을 통해 여러 서비스로 전파가 될 수 있지 않을까 싶다.</p><ul>  <li>게임? 예술 교육? Getty images 같은 이미지 판매?</li></ul><p>이런 트렌드를 놓치고 있지 않아야 겠다는 생각이 든다.</p><p><br /></p>",
            "url": "https://kimdoubleb.github.io/news/2022/09/04/1-news",
            
            
            
            "tags": ["reactor","opensource","java"],
            
            "date_published": "2022-09-04T00:00:00+09:00",
            "date_modified": "2022-09-04T00:00:00+09:00",
            
                "author":  {
                "name": "KimDoubleB",
                "url": null,
                "avatar": null
                }
                
            
        },
    
        {
            "id": "https://kimdoubleb.github.io/news/2022/08/28/weekly-tech-news",
            "title": "KimDoubleB의 Weekly tech news !",
            "summary": "Weekly tech news를 시작해보겠습니다.",
            "content_text": "배우는 것을 정리하며 블로그 글을 작성하고 있지만, 글을 작성하는 시간이 꽤 걸리다보니 배운 것들을 다 정리하지 못하고 노션에 기록만 해두는 것이 많다.근데 이런 것들을 혼자 기록해두면 볼 일이 없기도 하고 까먹는 경우도 많고, 언제 어떤 것을 학습했고, 조사했고, 고심했는지 기록이 남지 않았다.그래서 이런 것들을 아주 가볍게 정리라도 하고자 Weekly tech news를 작성해보고자 한다.  이 방식은 Outsider님의 블로그의 기술뉴스에서 영감받았다.한 주에 배운 것들, 영감받은 것들, 흥미로웠던 것들 등 아주 가볍게 주제와 참고 링크만이라도 정리하자.",
            "content_html": "<p>배우는 것을 정리하며 <a href=\"https://binux.tistory.com/\">블로그 글</a>을 작성하고 있지만, 글을 작성하는 시간이 꽤 걸리다보니 배운 것들을 다 정리하지 못하고 노션에 기록만 해두는 것이 많다.</p><p>근데 이런 것들을 혼자 기록해두면 볼 일이 없기도 하고 까먹는 경우도 많고, 언제 어떤 것을 학습했고, 조사했고, 고심했는지 기록이 남지 않았다.</p><p>그래서 이런 것들을 아주 가볍게 정리라도 하고자 <code class=\"language-plaintext highlighter-rouge\">Weekly tech news</code>를 작성해보고자 한다.</p><ul>  <li>이 방식은 <a href=\"https://blog.outsider.ne.kr/\">Outsider님의 블로그</a>의 <code class=\"language-plaintext highlighter-rouge\">기술뉴스</code>에서 영감받았다.</li></ul><p><br /></p><p>한 주에 배운 것들, 영감받은 것들, 흥미로웠던 것들 등 아주 가볍게 주제와 참고 링크만이라도 정리하자.</p>",
            "url": "https://kimdoubleb.github.io/news/2022/08/28/weekly-tech-news",
            
            
            
            "tags": ["blog","tech"],
            
            "date_published": "2022-08-28T00:00:00+09:00",
            "date_modified": "2022-08-28T00:00:00+09:00",
            
                "author":  {
                "name": "KimDoubleB",
                "url": null,
                "avatar": null
                }
                
            
        }
    
    ]
}